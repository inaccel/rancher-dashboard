{"version":3,"file":"js/codemirror.c6668a7a.js","mappings":"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","sources":["webpack://dashboard/./node_modules/codemirror/addon/hint/show-hint.css","webpack://dashboard/./node_modules/codemirror/addon/lint/lint.css","webpack://dashboard/./node_modules/codemirror/theme/base16-dark.css","webpack://dashboard/./node_modules/codemirror/theme/base16-light.css","webpack://dashboard/./shell/plugins/codemirror.js","webpack://dashboard/./node_modules/codemirror/addon/dialog/dialog.js","webpack://dashboard/./node_modules/codemirror/addon/edit/matchbrackets.js","webpack://dashboard/./node_modules/codemirror/addon/hint/anyword-hint.js","webpack://dashboard/./node_modules/codemirror/addon/hint/show-hint.js","webpack://dashboard/./node_modules/codemirror/addon/lint/lint.js","webpack://dashboard/./node_modules/codemirror/addon/lint/yaml-lint.js","webpack://dashboard/./node_modules/codemirror/addon/search/searchcursor.js","webpack://dashboard/./node_modules/codemirror/keymap/emacs.js","webpack://dashboard/./node_modules/codemirror/keymap/sublime.js","webpack://dashboard/./node_modules/codemirror/keymap/vim.js","webpack://dashboard/./node_modules/codemirror/mode/javascript/javascript.js","webpack://dashboard/./node_modules/codemirror/mode/yaml/yaml.js","webpack://dashboard/./node_modules/codemirror/addon/hint/show-hint.css?ad7d","webpack://dashboard/./node_modules/codemirror/addon/lint/lint.css?b43c","webpack://dashboard/./node_modules/codemirror/theme/base16-dark.css?48cc","webpack://dashboard/./node_modules/codemirror/theme/base16-light.css?2ba0"],"sourcesContent":["// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../../../@vue/cli-service/node_modules/css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../@vue/cli-service/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.CodeMirror-hints{position:absolute;z-index:10;overflow:hidden;list-style:none;margin:0;padding:2px;box-shadow:2px 3px 5px rgba(0,0,0,.2);border-radius:3px;border:1px solid silver;background:#fff;font-size:90%;font-family:monospace;max-height:20em;overflow-y:auto;box-sizing:border-box}.CodeMirror-hint{margin:0;padding:0 4px;border-radius:2px;white-space:pre;color:#000;cursor:pointer}li.CodeMirror-hint-active{background:#08f;color:#fff}`, \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../../../@vue/cli-service/node_modules/css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../@vue/cli-service/node_modules/css-loader/dist/runtime/api.js\";\nimport ___CSS_LOADER_GET_URL_IMPORT___ from \"../../../@vue/cli-service/node_modules/css-loader/dist/runtime/getUrl.js\";\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=\", import.meta.url);\nvar ___CSS_LOADER_URL_IMPORT_1___ = new URL(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==\", import.meta.url);\nvar ___CSS_LOADER_URL_IMPORT_2___ = new URL(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=\", import.meta.url);\nvar ___CSS_LOADER_URL_IMPORT_3___ = new URL(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=\", import.meta.url);\nvar ___CSS_LOADER_URL_IMPORT_4___ = new URL(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC\", import.meta.url);\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);\nvar ___CSS_LOADER_URL_REPLACEMENT_2___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_2___);\nvar ___CSS_LOADER_URL_REPLACEMENT_3___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_3___);\nvar ___CSS_LOADER_URL_REPLACEMENT_4___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_4___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.CodeMirror-lint-markers{width:16px}.CodeMirror-lint-tooltip{background-color:#ffd;border:1px solid #000;border-radius:4px 4px 4px 4px;color:#000;font-family:monospace;font-size:10pt;overflow:hidden;padding:2px 5px;position:fixed;white-space:pre;white-space:pre-wrap;z-index:100;max-width:600px;opacity:0;transition:opacity .4s;-moz-transition:opacity .4s;-webkit-transition:opacity .4s;-o-transition:opacity .4s;-ms-transition:opacity .4s}.CodeMirror-lint-mark{background-position:0 100%;background-repeat:repeat-x}.CodeMirror-lint-mark-warning{background-image:url(${___CSS_LOADER_URL_REPLACEMENT_0___})}.CodeMirror-lint-mark-error{background-image:url(${___CSS_LOADER_URL_REPLACEMENT_1___})}.CodeMirror-lint-marker{background-position:50%;background-repeat:no-repeat;cursor:pointer;display:inline-block;height:16px;width:16px;vertical-align:middle;position:relative}.CodeMirror-lint-message{padding-left:18px;background-position:0 0;background-repeat:no-repeat}.CodeMirror-lint-marker-warning,.CodeMirror-lint-message-warning{background-image:url(${___CSS_LOADER_URL_REPLACEMENT_2___})}.CodeMirror-lint-marker-error,.CodeMirror-lint-message-error{background-image:url(${___CSS_LOADER_URL_REPLACEMENT_3___})}.CodeMirror-lint-marker-multiple{background-image:url(${___CSS_LOADER_URL_REPLACEMENT_4___});background-repeat:no-repeat;background-position:100% 100%;width:100%;height:100%}.CodeMirror-lint-line-error{background-color:rgba(183,76,81,.08)}.CodeMirror-lint-line-warning{background-color:rgba(255,211,0,.1)}`, \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../../@vue/cli-service/node_modules/css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../@vue/cli-service/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.cm-s-base16-dark.CodeMirror{background:#151515;color:#e0e0e0}.cm-s-base16-dark div.CodeMirror-selected{background:#303030}.cm-s-base16-dark .CodeMirror-line::selection,.cm-s-base16-dark .CodeMirror-line>span::selection,.cm-s-base16-dark .CodeMirror-line>span>span::selection{background:rgba(48,48,48,.99)}.cm-s-base16-dark .CodeMirror-line::-moz-selection,.cm-s-base16-dark .CodeMirror-line>span::-moz-selection,.cm-s-base16-dark .CodeMirror-line>span>span::-moz-selection{background:rgba(48,48,48,.99)}.cm-s-base16-dark .CodeMirror-gutters{background:#151515;border-right:0}.cm-s-base16-dark .CodeMirror-guttermarker{color:#ac4142}.cm-s-base16-dark .CodeMirror-guttermarker-subtle,.cm-s-base16-dark .CodeMirror-linenumber{color:#505050}.cm-s-base16-dark .CodeMirror-cursor{border-left:1px solid #b0b0b0}.cm-s-base16-dark .cm-animate-fat-cursor,.cm-s-base16-dark.cm-fat-cursor .CodeMirror-cursor{background-color:#8e8d8875!important}.cm-s-base16-dark span.cm-comment{color:#8f5536}.cm-s-base16-dark span.cm-atom,.cm-s-base16-dark span.cm-number{color:#aa759f}.cm-s-base16-dark span.cm-attribute,.cm-s-base16-dark span.cm-property{color:#90a959}.cm-s-base16-dark span.cm-keyword{color:#ac4142}.cm-s-base16-dark span.cm-string{color:#f4bf75}.cm-s-base16-dark span.cm-variable{color:#90a959}.cm-s-base16-dark span.cm-variable-2{color:#6a9fb5}.cm-s-base16-dark span.cm-def{color:#d28445}.cm-s-base16-dark span.cm-bracket{color:#e0e0e0}.cm-s-base16-dark span.cm-tag{color:#ac4142}.cm-s-base16-dark span.cm-link{color:#aa759f}.cm-s-base16-dark span.cm-error{background:#ac4142;color:#b0b0b0}.cm-s-base16-dark .CodeMirror-activeline-background{background:#202020}.cm-s-base16-dark .CodeMirror-matchingbracket{text-decoration:underline;color:#fff!important}`, \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../../@vue/cli-service/node_modules/css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../@vue/cli-service/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.cm-s-base16-light.CodeMirror{background:#f5f5f5;color:#202020}.cm-s-base16-light div.CodeMirror-selected{background:#e0e0e0}.cm-s-base16-light .CodeMirror-line::selection,.cm-s-base16-light .CodeMirror-line>span::selection,.cm-s-base16-light .CodeMirror-line>span>span::selection{background:#e0e0e0}.cm-s-base16-light .CodeMirror-line::-moz-selection,.cm-s-base16-light .CodeMirror-line>span::-moz-selection,.cm-s-base16-light .CodeMirror-line>span>span::-moz-selection{background:#e0e0e0}.cm-s-base16-light .CodeMirror-gutters{background:#f5f5f5;border-right:0}.cm-s-base16-light .CodeMirror-guttermarker{color:#ac4142}.cm-s-base16-light .CodeMirror-guttermarker-subtle,.cm-s-base16-light .CodeMirror-linenumber{color:#b0b0b0}.cm-s-base16-light .CodeMirror-cursor{border-left:1px solid #505050}.cm-s-base16-light span.cm-comment{color:#8f5536}.cm-s-base16-light span.cm-atom,.cm-s-base16-light span.cm-number{color:#aa759f}.cm-s-base16-light span.cm-attribute,.cm-s-base16-light span.cm-property{color:#90a959}.cm-s-base16-light span.cm-keyword{color:#ac4142}.cm-s-base16-light span.cm-string{color:#f4bf75}.cm-s-base16-light span.cm-variable{color:#90a959}.cm-s-base16-light span.cm-variable-2{color:#6a9fb5}.cm-s-base16-light span.cm-def{color:#d28445}.cm-s-base16-light span.cm-bracket{color:#202020}.cm-s-base16-light span.cm-tag{color:#ac4142}.cm-s-base16-light span.cm-link{color:#aa759f}.cm-s-base16-light span.cm-error{background:#ac4142;color:#505050}.cm-s-base16-light .CodeMirror-activeline-background{background:#dddcdc}.cm-s-base16-light .CodeMirror-matchingbracket{color:#f5f5f5!important;background-color:#6a9fb5!important}`, \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","/*\n * NOTE: This isn't actually a real plugin anymore, it's is dynamically loaded in components/CodeMirror.vue\n * so that it doesn't all get loaded put into vendor.js\n */\n\nimport CodeMirror from 'codemirror';\n\nimport 'codemirror/lib/codemirror.css';\nimport 'codemirror/mode/yaml/yaml.js';\nimport 'codemirror/mode/javascript/javascript.js';\n\nimport 'codemirror/theme/base16-light.css';\nimport 'codemirror/theme/base16-dark.css';\n\nimport 'codemirror/keymap/vim.js';\nimport 'codemirror/keymap/emacs.js';\nimport 'codemirror/keymap/sublime.js';\n\nimport 'codemirror/addon/lint/lint.css';\nimport 'codemirror/addon/lint/lint.js';\nimport 'codemirror/addon/lint/yaml-lint.js';\n\nimport 'codemirror/addon/fold/foldgutter.css';\nimport 'codemirror/addon/fold/foldgutter.js';\n\nimport 'codemirror/addon/hint/show-hint.css';\nimport 'codemirror/addon/hint/show-hint.js';\nimport 'codemirror/addon/hint/anyword-hint.js';\n\nimport { strPad } from '@shell/utils/string';\n\nfunction isLineComment(cm, lineNo) {\n  return /\\bcomment\\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, 0)));\n}\n\nfunction commentIndent(cm, lineNo) {\n  const text = cm.getLine(lineNo).substr(1);\n  const spaceTo = text.search(/\\S/);\n\n  if (spaceTo === -1 ) {\n    return -1;\n  }\n\n  const out = CodeMirror.countColumn(text, null, cm.getOption('tabSize'));\n\n  return out;\n}\n\n// Like the regular indent in codemirror, but treat a YAML array\n// item that's at the same level as the parent key as intented on level more\n//\n// foo:\n// - a\n// - b\nfunction lineIndent(cm, lineNo) {\n  let text = cm.getLine(lineNo);\n  const match = text.match(/(\\s*(-\\s+)?)(\\S.*)/);\n\n  if ( !match ) {\n    return -1;\n  }\n\n  const spaceTo = match[1].length;\n\n  text = strPad('', spaceTo) + match[3];\n\n  if ( /\\bcomment\\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, spaceTo + 1)))) {\n    return -1;\n  }\n\n  return CodeMirror.countColumn(text, null, cm.getOption('tabSize'));\n}\n\n// https://github.com/codemirror/CodeMirror/blob/master/addon/fold/indent-fold.js\nCodeMirror.registerHelper('fold', 'indent', (cm, start) => {\n  const myIndent = lineIndent(cm, start.line);\n\n  if (myIndent < 0) {\n    return;\n  }\n  let lastLineInFold = null;\n\n  // Go through lines until we find a line that definitely doesn't belong in\n  // the block we're folding, or to the end.\n  for (let i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {\n    const indent = lineIndent(cm, i);\n\n    if (indent === -1) {\n    } else if (indent > myIndent) {\n      // Lines with a greater indent are considered part of the block.\n      lastLineInFold = i;\n    } else {\n      // If this line has non-space, non-comment content, and is\n      // indented less or equal to the start line, it is the start of\n      // another block.\n      break;\n    }\n  }\n  if (lastLineInFold) {\n    return {\n      from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),\n      to:   CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)\n    };\n  }\n});\n\nCodeMirror.defineExtension('foldLinesMatching', function(regex) {\n  this.operation(() => {\n    for (let i = this.firstLine(), e = this.lastLine(); i <= e; i++) {\n      const line = this.getLine(i);\n\n      if ( line.match(regex) ) {\n        this.foldCode(CodeMirror.Pos(i, 0), null, 'fold');\n      }\n    }\n  });\n});\n\nfunction countSpaces(line) {\n  for (let i = 0; i < line.length; i++) {\n    if (line[i] !== ' ') {\n      return i;\n    }\n  }\n\n  return line.length;\n}\n\nCodeMirror.defineExtension('foldYaml', function(path) {\n  this.operation(() => {\n    let elements = [];\n\n    for (let i = this.firstLine(), e = this.lastLine(); i <= e; i++) {\n      const line = this.getLine(i);\n      const index = countSpaces(line);\n      const trimmed = line.trim();\n\n      if (trimmed.endsWith(':') || trimmed.endsWith(': >-')) {\n        const name = trimmed.split(':')[0].substr(0, trimmed.length - 1);\n\n        // Remove all elements of the same are greater index\n        elements = elements.filter((e) => e.index < index);\n\n        // Add on this one\n        elements.push({\n          index,\n          name\n        });\n\n        const currentPath = elements.map((e) => e.name).join('.');\n\n        if (currentPath === path) {\n          this.foldCode(CodeMirror.Pos(i, 0), null, 'fold');\n        }\n      }\n    }\n  });\n});\n\nCodeMirror.registerHelper('fold', 'yamlcomments', (cm, start) => {\n  if ( !isLineComment(cm, start.line) ) {\n    return;\n  }\n\n  const myIndent = commentIndent(cm, start.line);\n\n  if (myIndent < 0) {\n    return;\n  }\n\n  let lastLineInFold = null;\n\n  // Go through lines until we find a line that definitely doesn't belong in\n  // the block we're folding, or to the end.\n  for (let i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {\n    if ( !isLineComment(cm, i) ) {\n      break;\n    }\n\n    const indent = commentIndent(cm, i);\n\n    if (indent === -1) {\n      // empty?\n    } else if (indent > myIndent) {\n      // Lines with a greater indent are considered part of the block.\n      lastLineInFold = i;\n    } else {\n      // If this line has non-space, non-comment content, and is\n      // indented less or equal to the start line, it is the start of\n      // another block.\n      break;\n    }\n  }\n\n  if (lastLineInFold) {\n    return {\n      from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),\n      to:   CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)\n    };\n  }\n});\n\n/**\n * It display a dot for each space character in the text;\n * used in combination with 'as-text-area' css properties in CodeMirror.vue to display line break markdowns\n */\nCodeMirror.defineOption('showMarkdownLineBreaks', false, (codeMirror) => {\n  codeMirror.addOverlay({\n    name:  'show-markdown-line-breaks',\n    token: (stream) => {\n      if (stream.string[stream.pos].match(/\\s/)) {\n        stream.next();\n\n        return stream.pos % 2 === 0 ? 'markdown-single-trailing-space-even' : 'markdown-single-trailing-space-odd';\n      }\n\n      stream.next();\n\n      return null;\n    }\n  });\n});\n\n/**\n * It enables the text color selection in CodeMirror.vue\n * references:\n *   demo:   https://codemirror.net/5/demo/markselection.html#\n *   add-on: https://codemirror.net/5/doc/manual.html#addon_mark-selection\n *   source: https://codemirror.net/5/addon/selection/mark-selection.js\n */\nCodeMirror.defineOption('styleSelectedText', false, (cm, val, old) => {\n  const prev = old && old !== CodeMirror.Init;\n\n  if (val && !prev) {\n    cm.state.markedSelection = [];\n    cm.state.markedSelectionStyle = typeof val === 'string' ? val : 'CodeMirror-selectedtext';\n    reset(cm);\n    cm.on('cursorActivity', onCursorActivity);\n    cm.on('change', onChange);\n  } else if (!val && prev) {\n    cm.off('cursorActivity', onCursorActivity);\n    cm.off('change', onChange);\n    clear(cm);\n    cm.state.markedSelection = cm.state.markedSelectionStyle = null;\n  }\n});\n\nfunction onCursorActivity(cm) {\n  if (cm.state.markedSelection) {\n    cm.operation(() => {\n      update(cm);\n    });\n  }\n}\n\nfunction onChange(cm) {\n  if (cm.state.markedSelection && cm.state.markedSelection.length) {\n    cm.operation(() => {\n      clear(cm);\n    });\n  }\n}\n\nconst CHUNK_SIZE = 8;\nconst Pos = CodeMirror.Pos;\nconst cmp = CodeMirror.cmpPos;\n\nfunction coverRange(cm, from, to, addAt) {\n  if (cmp(from, to) === 0) {\n    return;\n  }\n  const array = cm.state.markedSelection;\n  const cls = cm.state.markedSelectionStyle;\n\n  for (let line = from.line;;) {\n    const start = line === from.line ? from : Pos(line, 0);\n    const endLine = line + CHUNK_SIZE; const atEnd = endLine >= to.line;\n    const end = atEnd ? to : Pos(endLine, 0);\n    const mark = cm.markText(start, end, { className: cls });\n\n    if (addAt === null || addAt === undefined) {\n      array.push(mark);\n    } else {\n      array.splice(addAt++, 0, mark);\n    }\n    if (atEnd) {\n      break;\n    }\n    line = endLine;\n  }\n}\n\nfunction clear(cm) {\n  const array = cm.state.markedSelection;\n\n  for (let i = 0; i < array.length; ++i) {\n    array[i].clear();\n  }\n  array.length = 0;\n}\n\nfunction reset(cm) {\n  clear(cm);\n  const ranges = cm.listSelections();\n\n  for (let i = 0; i < ranges.length; i++) {\n    coverRange(cm, ranges[i].from(), ranges[i].to());\n  }\n}\n\nfunction update(cm) {\n  if (!cm.somethingSelected()) {\n    return clear(cm);\n  }\n  if (cm.listSelections().length > 1) {\n    return reset(cm);\n  }\n\n  const from = cm.getCursor('start'); const to = cm.getCursor('end');\n\n  const array = cm.state.markedSelection;\n\n  if (!array.length) {\n    return coverRange(cm, from, to);\n  }\n\n  let coverStart = array[0].find(); let coverEnd = array[array.length - 1].find();\n\n  if (!coverStart || !coverEnd || to.line - from.line <= CHUNK_SIZE ||\n      cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0) {\n    return reset(cm);\n  }\n\n  while (cmp(from, coverStart.from) > 0) {\n    array.shift().clear();\n    coverStart = array[0].find();\n  }\n  if (cmp(from, coverStart.from) < 0) {\n    if (coverStart.to.line - from.line < CHUNK_SIZE) {\n      array.shift().clear();\n      coverRange(cm, from, coverStart.to, 0);\n    } else {\n      coverRange(cm, from, coverStart.from, 0);\n    }\n  }\n\n  while (cmp(to, coverEnd.to) < 0) {\n    array.pop().clear();\n    coverEnd = array[array.length - 1].find();\n  }\n  if (cmp(to, coverEnd.to) > 0) {\n    if (to.line - coverEnd.from.line < CHUNK_SIZE) {\n      array.pop().clear();\n      coverRange(cm, coverEnd.from, to);\n    } else {\n      coverRange(cm, coverEnd.to, to);\n    }\n  }\n}\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// Open simple dialogs on top of an editor. Relies on dialog.css.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  function dialogDiv(cm, template, bottom) {\n    var wrap = cm.getWrapperElement();\n    var dialog;\n    dialog = wrap.appendChild(document.createElement(\"div\"));\n    if (bottom)\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-bottom\";\n    else\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-top\";\n\n    if (typeof template == \"string\") {\n      dialog.innerHTML = template;\n    } else { // Assuming it's a detached DOM element.\n      dialog.appendChild(template);\n    }\n    CodeMirror.addClass(wrap, 'dialog-opened');\n    return dialog;\n  }\n\n  function closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n      cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n  }\n\n  CodeMirror.defineExtension(\"openDialog\", function(template, callback, options) {\n    if (!options) options = {};\n\n    closeNotification(this, null);\n\n    var dialog = dialogDiv(this, template, options.bottom);\n    var closed = false, me = this;\n    function close(newVal) {\n      if (typeof newVal == 'string') {\n        inp.value = newVal;\n      } else {\n        if (closed) return;\n        closed = true;\n        CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n        dialog.parentNode.removeChild(dialog);\n        me.focus();\n\n        if (options.onClose) options.onClose(dialog);\n      }\n    }\n\n    var inp = dialog.getElementsByTagName(\"input\")[0], button;\n    if (inp) {\n      inp.focus();\n\n      if (options.value) {\n        inp.value = options.value;\n        if (options.selectValueOnOpen !== false) {\n          inp.select();\n        }\n      }\n\n      if (options.onInput)\n        CodeMirror.on(inp, \"input\", function(e) { options.onInput(e, inp.value, close);});\n      if (options.onKeyUp)\n        CodeMirror.on(inp, \"keyup\", function(e) {options.onKeyUp(e, inp.value, close);});\n\n      CodeMirror.on(inp, \"keydown\", function(e) {\n        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }\n        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n          inp.blur();\n          CodeMirror.e_stop(e);\n          close();\n        }\n        if (e.keyCode == 13) callback(inp.value, e);\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(dialog, \"focusout\", function (evt) {\n        if (evt.relatedTarget !== null) close();\n      });\n    } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n      CodeMirror.on(button, \"click\", function() {\n        close();\n        me.focus();\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n\n      button.focus();\n    }\n    return close;\n  });\n\n  CodeMirror.defineExtension(\"openConfirm\", function(template, callbacks, options) {\n    closeNotification(this, null);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var buttons = dialog.getElementsByTagName(\"button\");\n    var closed = false, me = this, blurring = 1;\n    function close() {\n      if (closed) return;\n      closed = true;\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n      dialog.parentNode.removeChild(dialog);\n      me.focus();\n    }\n    buttons[0].focus();\n    for (var i = 0; i < buttons.length; ++i) {\n      var b = buttons[i];\n      (function(callback) {\n        CodeMirror.on(b, \"click\", function(e) {\n          CodeMirror.e_preventDefault(e);\n          close();\n          if (callback) callback(me);\n        });\n      })(callbacks[i]);\n      CodeMirror.on(b, \"blur\", function() {\n        --blurring;\n        setTimeout(function() { if (blurring <= 0) close(); }, 200);\n      });\n      CodeMirror.on(b, \"focus\", function() { ++blurring; });\n    }\n  });\n\n  /*\n   * openNotification\n   * Opens a notification, that can be closed with an optional timer\n   * (default 5000ms timer) and always closes on click.\n   *\n   * If a notification is opened while another is opened, it will close the\n   * currently opened one and open the new one immediately.\n   */\n  CodeMirror.defineExtension(\"openNotification\", function(template, options) {\n    closeNotification(this, close);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var closed = false, doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n\n    function close() {\n      if (closed) return;\n      closed = true;\n      clearTimeout(doneTimer);\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n      dialog.parentNode.removeChild(dialog);\n    }\n\n    CodeMirror.on(dialog, 'click', function(e) {\n      CodeMirror.e_preventDefault(e);\n      close();\n    });\n\n    if (duration)\n      doneTimer = setTimeout(close, duration);\n\n    return close;\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\", \"<\": \">>\", \">\": \"<<\"};\n\n  function bracketRegex(config) {\n    return config && config.bracketRegex || /[(){}[\\]]/\n  }\n\n  function findMatchingBracket(cm, where, config) {\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n    var afterCursor = config && config.afterCursor\n    if (afterCursor == null)\n      afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className)\n    var re = bracketRegex(config)\n\n    // A cursor is defined as between two characters, but in in vim command mode\n    // (i.e. not insert mode), the cursor is visually represented as a\n    // highlighted box on top of the 2nd character. Otherwise, we allow matches\n    // from before or after the cursor.\n    var match = (!afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)]) ||\n        re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (config && config.strict && (dir > 0) != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config);\n    if (found == null) return null;\n    return {from: Pos(where.line, pos), to: found && found.pos,\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\n  }\n\n  // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n\n    var stack = [];\n    var re = bracketRegex(config)\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n        if (re.test(ch) && (style === undefined ||\n                            (cm.getTokenTypeAt(Pos(lineNo, pos + 1)) || \"\") == (style || \"\"))) {\n          var match = matching[ch];\n          if (match && (match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n          else stack.pop();\n        }\n      }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000,\n      highlightNonMatching = config && config.highlightNonMatching;\n    var marks = [], ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);\n      if (match && (match.match || highlightNonMatching !== false) && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textarea whenever this fires.\n      if (ie_lt8 && cm.state.focused) cm.focus();\n\n      var clear = function() {\n        cm.operation(function() {\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\n        });\n      };\n      if (autoclear) setTimeout(clear, 800);\n      else return clear;\n    }\n  }\n\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (cm.state.matchBrackets.currentlyHighlighted) {\n        cm.state.matchBrackets.currentlyHighlighted();\n        cm.state.matchBrackets.currentlyHighlighted = null;\n      }\n      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  function clearHighlighted(cm) {\n    if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {\n      cm.state.matchBrackets.currentlyHighlighted();\n      cm.state.matchBrackets.currentlyHighlighted = null;\n    }\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.off(\"cursorActivity\", doMatchBrackets);\n      cm.off(\"focus\", doMatchBrackets)\n      cm.off(\"blur\", clearHighlighted)\n      clearHighlighted(cm);\n    }\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n      cm.on(\"focus\", doMatchBrackets)\n      cm.on(\"blur\", clearHighlighted)\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, config, oldConfig){\n    // Backwards-compatibility kludge\n    if (oldConfig || typeof config == \"boolean\") {\n      if (!oldConfig) {\n        config = config ? {strict: true} : null\n      } else {\n        oldConfig.strict = config\n        config = oldConfig\n      }\n    }\n    return findMatchingBracket(this, pos, config)\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var WORD = /[\\w$]+/, RANGE = 500;\n\n  CodeMirror.registerHelper(\"hint\", \"anyword\", function(editor, options) {\n    var word = options && options.word || WORD;\n    var range = options && options.range || RANGE;\n    var cur = editor.getCursor(), curLine = editor.getLine(cur.line);\n    var end = cur.ch, start = end;\n    while (start && word.test(curLine.charAt(start - 1))) --start;\n    var curWord = start != end && curLine.slice(start, end);\n\n    var list = options && options.list || [], seen = {};\n    var re = new RegExp(word.source, \"g\");\n    for (var dir = -1; dir <= 1; dir += 2) {\n      var line = cur.line, endLine = Math.min(Math.max(line + dir * range, editor.firstLine()), editor.lastLine()) + dir;\n      for (; line != endLine; line += dir) {\n        var text = editor.getLine(line), m;\n        while (m = re.exec(text)) {\n          if (line == cur.line && m[0] === curWord) continue;\n          if ((!curWord || m[0].lastIndexOf(curWord, 0) == 0) && !Object.prototype.hasOwnProperty.call(seen, m[0])) {\n            seen[m[0]] = true;\n            list.push(m[0]);\n          }\n        }\n      }\n    }\n    return {list: list, from: CodeMirror.Pos(cur.line, start), to: CodeMirror.Pos(cur.line, end)};\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// declare global: DOMRect\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var HINT_ELEMENT_CLASS        = \"CodeMirror-hint\";\n  var ACTIVE_HINT_ELEMENT_CLASS = \"CodeMirror-hint-active\";\n\n  // This is the old interface, kept around for now to stay\n  // backwards-compatible.\n  CodeMirror.showHint = function(cm, getHints, options) {\n    if (!getHints) return cm.showHint(options);\n    if (options && options.async) getHints.async = true;\n    var newOpts = {hint: getHints};\n    if (options) for (var prop in options) newOpts[prop] = options[prop];\n    return cm.showHint(newOpts);\n  };\n\n  CodeMirror.defineExtension(\"showHint\", function(options) {\n    options = parseOptions(this, this.getCursor(\"start\"), options);\n    var selections = this.listSelections()\n    if (selections.length > 1) return;\n    // By default, don't allow completion when something is selected.\n    // A hint function can have a `supportsSelection` property to\n    // indicate that it can handle selections.\n    if (this.somethingSelected()) {\n      if (!options.hint.supportsSelection) return;\n      // Don't try with cross-line selections\n      for (var i = 0; i < selections.length; i++)\n        if (selections[i].head.line != selections[i].anchor.line) return;\n    }\n\n    if (this.state.completionActive) this.state.completionActive.close();\n    var completion = this.state.completionActive = new Completion(this, options);\n    if (!completion.options.hint) return;\n\n    CodeMirror.signal(this, \"startCompletion\", this);\n    completion.update(true);\n  });\n\n  CodeMirror.defineExtension(\"closeHint\", function() {\n    if (this.state.completionActive) this.state.completionActive.close()\n  })\n\n  function Completion(cm, options) {\n    this.cm = cm;\n    this.options = options;\n    this.widget = null;\n    this.debounce = 0;\n    this.tick = 0;\n    this.startPos = this.cm.getCursor(\"start\");\n    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;\n\n    if (this.options.updateOnCursorActivity) {\n      var self = this;\n      cm.on(\"cursorActivity\", this.activityFunc = function() { self.cursorActivity(); });\n    }\n  }\n\n  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {\n    return setTimeout(fn, 1000/60);\n  };\n  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n\n  Completion.prototype = {\n    close: function() {\n      if (!this.active()) return;\n      this.cm.state.completionActive = null;\n      this.tick = null;\n      if (this.options.updateOnCursorActivity) {\n        this.cm.off(\"cursorActivity\", this.activityFunc);\n      }\n\n      if (this.widget && this.data) CodeMirror.signal(this.data, \"close\");\n      if (this.widget) this.widget.close();\n      CodeMirror.signal(this.cm, \"endCompletion\", this.cm);\n    },\n\n    active: function() {\n      return this.cm.state.completionActive == this;\n    },\n\n    pick: function(data, i) {\n      var completion = data.list[i], self = this;\n      this.cm.operation(function() {\n        if (completion.hint)\n          completion.hint(self.cm, data, completion);\n        else\n          self.cm.replaceRange(getText(completion), completion.from || data.from,\n                               completion.to || data.to, \"complete\");\n        CodeMirror.signal(data, \"pick\", completion);\n        self.cm.scrollIntoView();\n      });\n      if (this.options.closeOnPick) {\n        this.close();\n      }\n    },\n\n    cursorActivity: function() {\n      if (this.debounce) {\n        cancelAnimationFrame(this.debounce);\n        this.debounce = 0;\n      }\n\n      var identStart = this.startPos;\n      if(this.data) {\n        identStart = this.data.from;\n      }\n\n      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);\n      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||\n          pos.ch < identStart.ch || this.cm.somethingSelected() ||\n          (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {\n        this.close();\n      } else {\n        var self = this;\n        this.debounce = requestAnimationFrame(function() {self.update();});\n        if (this.widget) this.widget.disable();\n      }\n    },\n\n    update: function(first) {\n      if (this.tick == null) return\n      var self = this, myTick = ++this.tick\n      fetchHints(this.options.hint, this.cm, this.options, function(data) {\n        if (self.tick == myTick) self.finishUpdate(data, first)\n      })\n    },\n\n    finishUpdate: function(data, first) {\n      if (this.data) CodeMirror.signal(this.data, \"update\");\n\n      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);\n      if (this.widget) this.widget.close();\n\n      this.data = data;\n\n      if (data && data.list.length) {\n        if (picked && data.list.length == 1) {\n          this.pick(data, 0);\n        } else {\n          this.widget = new Widget(this, data);\n          CodeMirror.signal(data, \"shown\");\n        }\n      }\n    }\n  };\n\n  function parseOptions(cm, pos, options) {\n    var editor = cm.options.hintOptions;\n    var out = {};\n    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];\n    if (editor) for (var prop in editor)\n      if (editor[prop] !== undefined) out[prop] = editor[prop];\n    if (options) for (var prop in options)\n      if (options[prop] !== undefined) out[prop] = options[prop];\n    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)\n    return out;\n  }\n\n  function getText(completion) {\n    if (typeof completion == \"string\") return completion;\n    else return completion.text;\n  }\n\n  function buildKeyMap(completion, handle) {\n    var baseMap = {\n      Up: function() {handle.moveFocus(-1);},\n      Down: function() {handle.moveFocus(1);},\n      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},\n      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},\n      Home: function() {handle.setFocus(0);},\n      End: function() {handle.setFocus(handle.length - 1);},\n      Enter: handle.pick,\n      Tab: handle.pick,\n      Esc: handle.close\n    };\n\n    var mac = /Mac/.test(navigator.platform);\n\n    if (mac) {\n      baseMap[\"Ctrl-P\"] = function() {handle.moveFocus(-1);};\n      baseMap[\"Ctrl-N\"] = function() {handle.moveFocus(1);};\n    }\n\n    var custom = completion.options.customKeys;\n    var ourMap = custom ? {} : baseMap;\n    function addBinding(key, val) {\n      var bound;\n      if (typeof val != \"string\")\n        bound = function(cm) { return val(cm, handle); };\n      // This mechanism is deprecated\n      else if (baseMap.hasOwnProperty(val))\n        bound = baseMap[val];\n      else\n        bound = val;\n      ourMap[key] = bound;\n    }\n    if (custom)\n      for (var key in custom) if (custom.hasOwnProperty(key))\n        addBinding(key, custom[key]);\n    var extra = completion.options.extraKeys;\n    if (extra)\n      for (var key in extra) if (extra.hasOwnProperty(key))\n        addBinding(key, extra[key]);\n    return ourMap;\n  }\n\n  function getHintElement(hintsElement, el) {\n    while (el && el != hintsElement) {\n      if (el.nodeName.toUpperCase() === \"LI\" && el.parentNode == hintsElement) return el;\n      el = el.parentNode;\n    }\n  }\n\n  function Widget(completion, data) {\n    this.id = \"cm-complete-\" + Math.floor(Math.random(1e6))\n    this.completion = completion;\n    this.data = data;\n    this.picked = false;\n    var widget = this, cm = completion.cm;\n    var ownerDocument = cm.getInputField().ownerDocument;\n    var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;\n\n    var hints = this.hints = ownerDocument.createElement(\"ul\");\n    hints.setAttribute(\"role\", \"listbox\")\n    hints.setAttribute(\"aria-expanded\", \"true\")\n    hints.id = this.id\n    var theme = completion.cm.options.theme;\n    hints.className = \"CodeMirror-hints \" + theme;\n    this.selectedHint = data.selectedHint || 0;\n\n    var completions = data.list;\n    for (var i = 0; i < completions.length; ++i) {\n      var elt = hints.appendChild(ownerDocument.createElement(\"li\")), cur = completions[i];\n      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? \"\" : \" \" + ACTIVE_HINT_ELEMENT_CLASS);\n      if (cur.className != null) className = cur.className + \" \" + className;\n      elt.className = className;\n      if (i == this.selectedHint) elt.setAttribute(\"aria-selected\", \"true\")\n      elt.id = this.id + \"-\" + i\n      elt.setAttribute(\"role\", \"option\")\n      if (cur.render) cur.render(elt, data, cur);\n      else elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));\n      elt.hintId = i;\n    }\n\n    var container = completion.options.container || ownerDocument.body;\n    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);\n    var left = pos.left, top = pos.bottom, below = true;\n    var offsetLeft = 0, offsetTop = 0;\n    if (container !== ownerDocument.body) {\n      // We offset the cursor position because left and top are relative to the offsetParent's top left corner.\n      var isContainerPositioned = ['absolute', 'relative', 'fixed'].indexOf(parentWindow.getComputedStyle(container).position) !== -1;\n      var offsetParent = isContainerPositioned ? container : container.offsetParent;\n      var offsetParentPosition = offsetParent.getBoundingClientRect();\n      var bodyPosition = ownerDocument.body.getBoundingClientRect();\n      offsetLeft = (offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft);\n      offsetTop = (offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop);\n    }\n    hints.style.left = (left - offsetLeft) + \"px\";\n    hints.style.top = (top - offsetTop) + \"px\";\n\n    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.\n    var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);\n    var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);\n    container.appendChild(hints);\n    cm.getInputField().setAttribute(\"aria-autocomplete\", \"list\")\n    cm.getInputField().setAttribute(\"aria-owns\", this.id)\n    cm.getInputField().setAttribute(\"aria-activedescendant\", this.id + \"-\" + this.selectedHint)\n\n    var box = completion.options.moveOnOverlap ? hints.getBoundingClientRect() : new DOMRect();\n    var scrolls = completion.options.paddingForScrollbar ? hints.scrollHeight > hints.clientHeight + 1 : false;\n\n    // Compute in the timeout to avoid reflow on init\n    var startScroll;\n    setTimeout(function() { startScroll = cm.getScrollInfo(); });\n\n    var overlapY = box.bottom - winH;\n    if (overlapY > 0) { // Does not fit below\n      var height = box.bottom - box.top, spaceAbove = box.top - (pos.bottom - pos.top) - 2\n      if (winH - box.top < spaceAbove) { // More room at the top\n        if (height > spaceAbove) hints.style.height = (height = spaceAbove) + \"px\";\n        hints.style.top = ((top = pos.top - height) + offsetTop) + \"px\";\n        below = false;\n      } else {\n        hints.style.height = (winH - box.top - 2) + \"px\";\n      }\n    }\n    var overlapX = box.right - winW;\n    if (scrolls) overlapX += cm.display.nativeBarWidth;\n    if (overlapX > 0) {\n      if (box.right - box.left > winW) {\n        hints.style.width = (winW - 5) + \"px\";\n        overlapX -= (box.right - box.left) - winW;\n      }\n      hints.style.left = (left = Math.max(pos.left - overlapX - offsetLeft, 0)) + \"px\";\n    }\n    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)\n      node.style.paddingRight = cm.display.nativeBarWidth + \"px\"\n\n    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {\n      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },\n      setFocus: function(n) { widget.changeActive(n); },\n      menuSize: function() { return widget.screenAmount(); },\n      length: completions.length,\n      close: function() { completion.close(); },\n      pick: function() { widget.pick(); },\n      data: data\n    }));\n\n    if (completion.options.closeOnUnfocus) {\n      var closingOnBlur;\n      cm.on(\"blur\", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });\n      cm.on(\"focus\", this.onFocus = function() { clearTimeout(closingOnBlur); });\n    }\n\n    cm.on(\"scroll\", this.onScroll = function() {\n      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();\n      if (!startScroll) startScroll = cm.getScrollInfo();\n      var newTop = top + startScroll.top - curScroll.top;\n      var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);\n      if (!below) point += hints.offsetHeight;\n      if (point <= editor.top || point >= editor.bottom) return completion.close();\n      hints.style.top = newTop + \"px\";\n      hints.style.left = (left + startScroll.left - curScroll.left) + \"px\";\n    });\n\n    CodeMirror.on(hints, \"dblclick\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}\n    });\n\n    CodeMirror.on(hints, \"click\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {\n        widget.changeActive(t.hintId);\n        if (completion.options.completeOnSingleClick) widget.pick();\n      }\n    });\n\n    CodeMirror.on(hints, \"mousedown\", function() {\n      setTimeout(function(){cm.focus();}, 20);\n    });\n\n    // The first hint doesn't need to be scrolled to on init\n    var selectedHintRange = this.getSelectedHintRange();\n    if (selectedHintRange.from !== 0 || selectedHintRange.to !== 0) {\n      this.scrollToActive();\n    }\n\n    CodeMirror.signal(data, \"select\", completions[this.selectedHint], hints.childNodes[this.selectedHint]);\n    return true;\n  }\n\n  Widget.prototype = {\n    close: function() {\n      if (this.completion.widget != this) return;\n      this.completion.widget = null;\n      if (this.hints.parentNode) this.hints.parentNode.removeChild(this.hints);\n      this.completion.cm.removeKeyMap(this.keyMap);\n      var input = this.completion.cm.getInputField()\n      input.removeAttribute(\"aria-activedescendant\")\n      input.removeAttribute(\"aria-owns\")\n\n      var cm = this.completion.cm;\n      if (this.completion.options.closeOnUnfocus) {\n        cm.off(\"blur\", this.onBlur);\n        cm.off(\"focus\", this.onFocus);\n      }\n      cm.off(\"scroll\", this.onScroll);\n    },\n\n    disable: function() {\n      this.completion.cm.removeKeyMap(this.keyMap);\n      var widget = this;\n      this.keyMap = {Enter: function() { widget.picked = true; }};\n      this.completion.cm.addKeyMap(this.keyMap);\n    },\n\n    pick: function() {\n      this.completion.pick(this.data, this.selectedHint);\n    },\n\n    changeActive: function(i, avoidWrap) {\n      if (i >= this.data.list.length)\n        i = avoidWrap ? this.data.list.length - 1 : 0;\n      else if (i < 0)\n        i = avoidWrap ? 0  : this.data.list.length - 1;\n      if (this.selectedHint == i) return;\n      var node = this.hints.childNodes[this.selectedHint];\n      if (node) {\n        node.className = node.className.replace(\" \" + ACTIVE_HINT_ELEMENT_CLASS, \"\");\n        node.removeAttribute(\"aria-selected\")\n      }\n      node = this.hints.childNodes[this.selectedHint = i];\n      node.className += \" \" + ACTIVE_HINT_ELEMENT_CLASS;\n      node.setAttribute(\"aria-selected\", \"true\")\n      this.completion.cm.getInputField().setAttribute(\"aria-activedescendant\", node.id)\n      this.scrollToActive()\n      CodeMirror.signal(this.data, \"select\", this.data.list[this.selectedHint], node);\n    },\n\n    scrollToActive: function() {\n      var selectedHintRange = this.getSelectedHintRange();\n      var node1 = this.hints.childNodes[selectedHintRange.from];\n      var node2 = this.hints.childNodes[selectedHintRange.to];\n      var firstNode = this.hints.firstChild;\n      if (node1.offsetTop < this.hints.scrollTop)\n        this.hints.scrollTop = node1.offsetTop - firstNode.offsetTop;\n      else if (node2.offsetTop + node2.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)\n        this.hints.scrollTop = node2.offsetTop + node2.offsetHeight - this.hints.clientHeight + firstNode.offsetTop;\n    },\n\n    screenAmount: function() {\n      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n    },\n\n    getSelectedHintRange: function() {\n      var margin = this.completion.options.scrollMargin || 0;\n      return {\n        from: Math.max(0, this.selectedHint - margin),\n        to: Math.min(this.data.list.length - 1, this.selectedHint + margin),\n      };\n    }\n  };\n\n  function applicableHelpers(cm, helpers) {\n    if (!cm.somethingSelected()) return helpers\n    var result = []\n    for (var i = 0; i < helpers.length; i++)\n      if (helpers[i].supportsSelection) result.push(helpers[i])\n    return result\n  }\n\n  function fetchHints(hint, cm, options, callback) {\n    if (hint.async) {\n      hint(cm, callback, options)\n    } else {\n      var result = hint(cm, options)\n      if (result && result.then) result.then(callback)\n      else callback(result)\n    }\n  }\n\n  function resolveAutoHints(cm, pos) {\n    var helpers = cm.getHelpers(pos, \"hint\"), words\n    if (helpers.length) {\n      var resolved = function(cm, callback, options) {\n        var app = applicableHelpers(cm, helpers);\n        function run(i) {\n          if (i == app.length) return callback(null)\n          fetchHints(app[i], cm, options, function(result) {\n            if (result && result.list.length > 0) callback(result)\n            else run(i + 1)\n          })\n        }\n        run(0)\n      }\n      resolved.async = true\n      resolved.supportsSelection = true\n      return resolved\n    } else if (words = cm.getHelper(cm.getCursor(), \"hintWords\")) {\n      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }\n    } else if (CodeMirror.hint.anyword) {\n      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }\n    } else {\n      return function() {}\n    }\n  }\n\n  CodeMirror.registerHelper(\"hint\", \"auto\", {\n    resolve: resolveAutoHints\n  });\n\n  CodeMirror.registerHelper(\"hint\", \"fromList\", function(cm, options) {\n    var cur = cm.getCursor(), token = cm.getTokenAt(cur)\n    var term, from = CodeMirror.Pos(cur.line, token.start), to = cur\n    if (token.start < cur.ch && /\\w/.test(token.string.charAt(cur.ch - token.start - 1))) {\n      term = token.string.substr(0, cur.ch - token.start)\n    } else {\n      term = \"\"\n      from = cur\n    }\n    var found = [];\n    for (var i = 0; i < options.words.length; i++) {\n      var word = options.words[i];\n      if (word.slice(0, term.length) == term)\n        found.push(word);\n    }\n\n    if (found.length) return {list: found, from: from, to: to};\n  });\n\n  CodeMirror.commands.autocomplete = CodeMirror.showHint;\n\n  var defaultOptions = {\n    hint: CodeMirror.hint.auto,\n    completeSingle: true,\n    alignWithWord: true,\n    closeCharacters: /[\\s()\\[\\]{};:>,]/,\n    closeOnPick: true,\n    closeOnUnfocus: true,\n    updateOnCursorActivity: true,\n    completeOnSingleClick: true,\n    container: null,\n    customKeys: null,\n    extraKeys: null,\n    paddingForScrollbar: true,\n    moveOnOverlap: true,\n  };\n\n  CodeMirror.defineOption(\"hintOptions\", null);\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var GUTTER_ID = \"CodeMirror-lint-markers\";\n  var LINT_LINE_ID = \"CodeMirror-lint-line-\";\n\n  function showTooltip(cm, e, content) {\n    var tt = document.createElement(\"div\");\n    tt.className = \"CodeMirror-lint-tooltip cm-s-\" + cm.options.theme;\n    tt.appendChild(content.cloneNode(true));\n    if (cm.state.lint.options.selfContain)\n      cm.getWrapperElement().appendChild(tt);\n    else\n      document.body.appendChild(tt);\n\n    function position(e) {\n      if (!tt.parentNode) return CodeMirror.off(document, \"mousemove\", position);\n      var top = Math.max(0, e.clientY - tt.offsetHeight - 5);\n      var left = Math.max(0, Math.min(e.clientX + 5, tt.ownerDocument.defaultView.innerWidth - tt.offsetWidth));\n      tt.style.top = top + \"px\"\n      tt.style.left = left + \"px\";\n    }\n    CodeMirror.on(document, \"mousemove\", position);\n    position(e);\n    if (tt.style.opacity != null) tt.style.opacity = 1;\n    return tt;\n  }\n  function rm(elt) {\n    if (elt.parentNode) elt.parentNode.removeChild(elt);\n  }\n  function hideTooltip(tt) {\n    if (!tt.parentNode) return;\n    if (tt.style.opacity == null) rm(tt);\n    tt.style.opacity = 0;\n    setTimeout(function() { rm(tt); }, 600);\n  }\n\n  function showTooltipFor(cm, e, content, node) {\n    var tooltip = showTooltip(cm, e, content);\n    function hide() {\n      CodeMirror.off(node, \"mouseout\", hide);\n      if (tooltip) { hideTooltip(tooltip); tooltip = null; }\n    }\n    var poll = setInterval(function() {\n      if (tooltip) for (var n = node;; n = n.parentNode) {\n        if (n && n.nodeType == 11) n = n.host;\n        if (n == document.body) return;\n        if (!n) { hide(); break; }\n      }\n      if (!tooltip) return clearInterval(poll);\n    }, 400);\n    CodeMirror.on(node, \"mouseout\", hide);\n  }\n\n  function LintState(cm, conf, hasGutter) {\n    this.marked = [];\n    if (conf instanceof Function) conf = {getAnnotations: conf};\n    if (!conf || conf === true) conf = {};\n    this.options = {};\n    this.linterOptions = conf.options || {};\n    for (var prop in defaults) this.options[prop] = defaults[prop];\n    for (var prop in conf) {\n      if (defaults.hasOwnProperty(prop)) {\n        if (conf[prop] != null) this.options[prop] = conf[prop];\n      } else if (!conf.options) {\n        this.linterOptions[prop] = conf[prop];\n      }\n    }\n    this.timeout = null;\n    this.hasGutter = hasGutter;\n    this.onMouseOver = function(e) { onMouseOver(cm, e); };\n    this.waitingFor = 0\n  }\n\n  var defaults = {\n    highlightLines: false,\n    tooltips: true,\n    delay: 500,\n    lintOnChange: true,\n    getAnnotations: null,\n    async: false,\n    selfContain: null,\n    formatAnnotation: null,\n    onUpdateLinting: null\n  }\n\n  function clearMarks(cm) {\n    var state = cm.state.lint;\n    if (state.hasGutter) cm.clearGutter(GUTTER_ID);\n    if (state.options.highlightLines) clearErrorLines(cm);\n    for (var i = 0; i < state.marked.length; ++i)\n      state.marked[i].clear();\n    state.marked.length = 0;\n  }\n\n  function clearErrorLines(cm) {\n    cm.eachLine(function(line) {\n      var has = line.wrapClass && /\\bCodeMirror-lint-line-\\w+\\b/.exec(line.wrapClass);\n      if (has) cm.removeLineClass(line, \"wrap\", has[0]);\n    })\n  }\n\n  function makeMarker(cm, labels, severity, multiple, tooltips) {\n    var marker = document.createElement(\"div\"), inner = marker;\n    marker.className = \"CodeMirror-lint-marker CodeMirror-lint-marker-\" + severity;\n    if (multiple) {\n      inner = marker.appendChild(document.createElement(\"div\"));\n      inner.className = \"CodeMirror-lint-marker CodeMirror-lint-marker-multiple\";\n    }\n\n    if (tooltips != false) CodeMirror.on(inner, \"mouseover\", function(e) {\n      showTooltipFor(cm, e, labels, inner);\n    });\n\n    return marker;\n  }\n\n  function getMaxSeverity(a, b) {\n    if (a == \"error\") return a;\n    else return b;\n  }\n\n  function groupByLine(annotations) {\n    var lines = [];\n    for (var i = 0; i < annotations.length; ++i) {\n      var ann = annotations[i], line = ann.from.line;\n      (lines[line] || (lines[line] = [])).push(ann);\n    }\n    return lines;\n  }\n\n  function annotationTooltip(ann) {\n    var severity = ann.severity;\n    if (!severity) severity = \"error\";\n    var tip = document.createElement(\"div\");\n    tip.className = \"CodeMirror-lint-message CodeMirror-lint-message-\" + severity;\n    if (typeof ann.messageHTML != 'undefined') {\n      tip.innerHTML = ann.messageHTML;\n    } else {\n      tip.appendChild(document.createTextNode(ann.message));\n    }\n    return tip;\n  }\n\n  function lintAsync(cm, getAnnotations) {\n    var state = cm.state.lint\n    var id = ++state.waitingFor\n    function abort() {\n      id = -1\n      cm.off(\"change\", abort)\n    }\n    cm.on(\"change\", abort)\n    getAnnotations(cm.getValue(), function(annotations, arg2) {\n      cm.off(\"change\", abort)\n      if (state.waitingFor != id) return\n      if (arg2 && annotations instanceof CodeMirror) annotations = arg2\n      cm.operation(function() {updateLinting(cm, annotations)})\n    }, state.linterOptions, cm);\n  }\n\n  function startLinting(cm) {\n    var state = cm.state.lint;\n    if (!state) return;\n    var options = state.options;\n    /*\n     * Passing rules in `options` property prevents JSHint (and other linters) from complaining\n     * about unrecognized rules like `onUpdateLinting`, `delay`, `lintOnChange`, etc.\n     */\n    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), \"lint\");\n    if (!getAnnotations) return;\n    if (options.async || getAnnotations.async) {\n      lintAsync(cm, getAnnotations)\n    } else {\n      var annotations = getAnnotations(cm.getValue(), state.linterOptions, cm);\n      if (!annotations) return;\n      if (annotations.then) annotations.then(function(issues) {\n        cm.operation(function() {updateLinting(cm, issues)})\n      });\n      else cm.operation(function() {updateLinting(cm, annotations)})\n    }\n  }\n\n  function updateLinting(cm, annotationsNotSorted) {\n    var state = cm.state.lint;\n    if (!state) return;\n    var options = state.options;\n    clearMarks(cm);\n\n    var annotations = groupByLine(annotationsNotSorted);\n\n    for (var line = 0; line < annotations.length; ++line) {\n      var anns = annotations[line];\n      if (!anns) continue;\n\n      var maxSeverity = null;\n      var tipLabel = state.hasGutter && document.createDocumentFragment();\n\n      for (var i = 0; i < anns.length; ++i) {\n        var ann = anns[i];\n        var severity = ann.severity;\n        if (!severity) severity = \"error\";\n        maxSeverity = getMaxSeverity(maxSeverity, severity);\n\n        if (options.formatAnnotation) ann = options.formatAnnotation(ann);\n        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));\n\n        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {\n          className: \"CodeMirror-lint-mark CodeMirror-lint-mark-\" + severity,\n          __annotation: ann\n        }));\n      }\n      if (state.hasGutter)\n        cm.setGutterMarker(line, GUTTER_ID, makeMarker(cm, tipLabel, maxSeverity, anns.length > 1,\n                                                       options.tooltips));\n\n      if (options.highlightLines)\n        cm.addLineClass(line, \"wrap\", LINT_LINE_ID + maxSeverity);\n    }\n    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.lint;\n    if (!state) return;\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay);\n  }\n\n  function popupTooltips(cm, annotations, e) {\n    var target = e.target || e.srcElement;\n    var tooltip = document.createDocumentFragment();\n    for (var i = 0; i < annotations.length; i++) {\n      var ann = annotations[i];\n      tooltip.appendChild(annotationTooltip(ann));\n    }\n    showTooltipFor(cm, e, tooltip, target);\n  }\n\n  function onMouseOver(cm, e) {\n    var target = e.target || e.srcElement;\n    if (!/\\bCodeMirror-lint-mark-/.test(target.className)) return;\n    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;\n    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, \"client\"));\n\n    var annotations = [];\n    for (var i = 0; i < spans.length; ++i) {\n      var ann = spans[i].__annotation;\n      if (ann) annotations.push(ann);\n    }\n    if (annotations.length) popupTooltips(cm, annotations, e);\n  }\n\n  CodeMirror.defineOption(\"lint\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      clearMarks(cm);\n      if (cm.state.lint.options.lintOnChange !== false)\n        cm.off(\"change\", onChange);\n      CodeMirror.off(cm.getWrapperElement(), \"mouseover\", cm.state.lint.onMouseOver);\n      clearTimeout(cm.state.lint.timeout);\n      delete cm.state.lint;\n    }\n\n    if (val) {\n      var gutters = cm.getOption(\"gutters\"), hasLintGutter = false;\n      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;\n      var state = cm.state.lint = new LintState(cm, val, hasLintGutter);\n      if (state.options.lintOnChange)\n        cm.on(\"change\", onChange);\n      if (state.options.tooltips != false && state.options.tooltips != \"gutter\")\n        CodeMirror.on(cm.getWrapperElement(), \"mouseover\", state.onMouseOver);\n\n      startLinting(cm);\n    }\n  });\n\n  CodeMirror.defineExtension(\"performLint\", function() {\n    startLinting(this);\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\n// Depends on js-yaml.js from https://github.com/nodeca/js-yaml\n\n// declare global: jsyaml\n\nCodeMirror.registerHelper(\"lint\", \"yaml\", function(text) {\n  var found = [];\n  if (!window.jsyaml) {\n    if (window.console) {\n      window.console.error(\"Error: window.jsyaml not defined, CodeMirror YAML linting cannot run.\");\n    }\n    return found;\n  }\n  try { jsyaml.loadAll(text); }\n  catch(e) {\n      var loc = e.mark,\n          // js-yaml YAMLException doesn't always provide an accurate lineno\n          // e.g., when there are multiple yaml docs\n          // ---\n          // ---\n          // foo:bar\n          from = loc ? CodeMirror.Pos(loc.line, loc.column) : CodeMirror.Pos(0, 0),\n          to = from;\n      found.push({ from: from, to: to, message: e.message });\n  }\n  return found;\n});\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n  var Pos = CodeMirror.Pos\n\n  function regexpFlags(regexp) {\n    var flags = regexp.flags\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\")\n      + (regexp.global ? \"g\" : \"\")\n      + (regexp.multiline ? \"m\" : \"\")\n  }\n\n  function ensureFlags(regexp, flags) {\n    var current = regexpFlags(regexp), target = current\n    for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1)\n      target += flags.charAt(i)\n    return current == target ? regexp : new RegExp(regexp.source, target)\n  }\n\n  function maybeMultiline(regexp) {\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source)\n  }\n\n  function searchRegexpForward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n      regexp.lastIndex = ch\n      var string = doc.getLine(line), match = regexp.exec(string)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpForwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)\n\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunk = 1\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\n      // This grows the search buffer in exponentially-sized chunks\n      // between matches, so that nearby matches are fast and don't\n      // require concatenating the whole document (in case we're\n      // searching for something that has tons of matches), but at the\n      // same time, the amount of retries is limited.\n      for (var i = 0; i < chunk; i++) {\n        if (line > last) break\n        var curLine = doc.getLine(line++)\n        string = string == null ? curLine : string + \"\\n\" + curLine\n      }\n      chunk = chunk * 2\n      regexp.lastIndex = start.ch\n      var match = regexp.exec(string)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  function lastMatchIn(string, regexp, endMargin) {\n    var match, from = 0\n    while (from <= string.length) {\n      regexp.lastIndex = from\n      var newMatch = regexp.exec(string)\n      if (!newMatch) break\n      var end = newMatch.index + newMatch[0].length\n      if (end > string.length - endMargin) break\n      if (!match || end > match.index + match[0].length)\n        match = newMatch\n      from = newMatch.index + 1\n    }\n    return match\n  }\n\n  function searchRegexpBackward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n      var string = doc.getLine(line)\n      var match = lastMatchIn(string, regexp, ch < 0 ? 0 : string.length - ch)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpBackward(doc, regexp, start)\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunkSize = 1, endMargin = doc.getLine(start.line).length - start.ch\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\n      for (var i = 0; i < chunkSize && line >= first; i++) {\n        var curLine = doc.getLine(line--)\n        string = string == null ? curLine : curLine + \"\\n\" + string\n      }\n      chunkSize *= 2\n\n      var match = lastMatchIn(string, regexp, endMargin)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = line + before.length, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  var doFold, noFold\n  if (String.prototype.normalize) {\n    doFold = function(str) { return str.normalize(\"NFD\").toLowerCase() }\n    noFold = function(str) { return str.normalize(\"NFD\") }\n  } else {\n    doFold = function(str) { return str.toLowerCase() }\n    noFold = function(str) { return str }\n  }\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos, foldFunc) {\n    if (orig.length == folded.length) return pos\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\n      if (min == max) return min\n      var mid = (min + max) >> 1\n      var len = foldFunc(orig.slice(0, mid)).length\n      if (len == pos) return mid\n      else if (len > pos) max = mid\n      else min = mid + 1\n    }\n  }\n\n  function searchStringForward(doc, query, start, caseFold) {\n    // Empty string would match anything and never progress, so we\n    // define it to match nothing instead.\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n      var orig = doc.getLine(line).slice(ch), string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.indexOf(lines[0])\n        if (found == -1) continue search\n        var start = adjustPos(orig, string, found, fold) + ch\n        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}\n      } else {\n        var cutFrom = string.length - lines[0].length\n        if (string.slice(cutFrom) != lines[0]) continue search\n        for (var i = 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search\n        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]\n        if (endString.slice(0, lastLine.length) != lastLine) continue search\n        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function searchStringBackward(doc, query, start, caseFold) {\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n      var orig = doc.getLine(line)\n      if (ch > -1) orig = orig.slice(0, ch)\n      var string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.lastIndexOf(lines[0])\n        if (found == -1) continue search\n        return {from: Pos(line, adjustPos(orig, string, found, fold)),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}\n      } else {\n        var lastLine = lines[lines.length - 1]\n        if (string.slice(0, lastLine.length) != lastLine) continue search\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search\n        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search\n        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function SearchCursor(doc, query, pos, options) {\n    this.atOccurrence = false\n    this.afterEmptyMatch = false\n    this.doc = doc\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0)\n    this.pos = {from: pos, to: pos}\n\n    var caseFold\n    if (typeof options == \"object\") {\n      caseFold = options.caseFold\n    } else { // Backwards compat for when caseFold was the 4th argument\n      caseFold = options\n      options = null\n    }\n\n    if (typeof query == \"string\") {\n      if (caseFold == null) caseFold = false\n      this.matches = function(reverse, pos) {\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)\n      }\n    } else {\n      query = ensureFlags(query, \"gm\")\n      if (!options || options.multiline !== false)\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)\n        }\n      else\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)\n        }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false)},\n    findPrevious: function() {return this.find(true)},\n\n    find: function(reverse) {\n      var head = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n      if (this.afterEmptyMatch && this.atOccurrence) {\n        // do not return the same 0 width match twice\n        head = Pos(head.line, head.ch)\n        if (reverse) {\n          head.ch--;\n          if (head.ch < 0) {\n            head.line--;\n            head.ch = (this.doc.getLine(head.line) || \"\").length;\n          }\n        } else {\n          head.ch++;\n          if (head.ch > (this.doc.getLine(head.line) || \"\").length) {\n            head.ch = 0;\n            head.line++;\n          }\n        }\n        if (CodeMirror.cmpPos(head, this.doc.clipPos(head)) != 0) {\n           return this.atOccurrence = false\n        }\n      }\n      var result = this.matches(reverse, head)\n      this.afterEmptyMatch = result && CodeMirror.cmpPos(result.from, result.to) == 0\n\n      if (result) {\n        this.pos = result\n        this.atOccurrence = true\n        return this.pos.match || true\n      } else {\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)\n        this.pos = {from: end, to: end}\n        return this.atOccurrence = false\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from},\n    to: function() {if (this.atOccurrence) return this.pos.to},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return\n      var lines = CodeMirror.splitLines(newText)\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold)\n  })\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold)\n  })\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = []\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold)\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break\n      ranges.push({anchor: cur.from(), head: cur.to()})\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0)\n  })\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n  function posEq(a, b) { return a.line == b.line && a.ch == b.ch; }\n\n  // Kill 'ring'\n\n  var killRing = [];\n  function addToRing(str) {\n    killRing.push(str);\n    if (killRing.length > 50) killRing.shift();\n  }\n  function growRingTop(str) {\n    if (!killRing.length) return addToRing(str);\n    killRing[killRing.length - 1] += str;\n  }\n  function getFromRing(n) { return killRing[killRing.length - (n ? Math.min(n, 1) : 1)] || \"\"; }\n  function popFromRing() { if (killRing.length > 1) killRing.pop(); return getFromRing(); }\n\n  var lastKill = null;\n\n  // Internal generic kill function, used by several mapped kill \"family\" functions.\n  function _kill(cm, from, to, ring, text) {\n    if (text == null) text = cm.getRange(from, to);\n\n    if (ring == \"grow\" && lastKill && lastKill.cm == cm && posEq(from, lastKill.pos) && cm.isClean(lastKill.gen))\n      growRingTop(text);\n    else if (ring !== false)\n      addToRing(text);\n    cm.replaceRange(\"\", from, to, \"+delete\");\n\n    if (ring == \"grow\") lastKill = {cm: cm, pos: from, gen: cm.changeGeneration()};\n    else lastKill = null;\n  }\n\n  // Boundaries of various units\n\n  function byChar(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"char\", true);\n  }\n\n  function byWord(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"word\", true);\n  }\n\n  function byLine(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"line\", cm.doc.sel.goalColumn);\n  }\n\n  function byPage(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"page\", cm.doc.sel.goalColumn);\n  }\n\n  function byParagraph(cm, pos, dir) {\n    var no = pos.line, line = cm.getLine(no);\n    var sawText = /\\S/.test(dir < 0 ? line.slice(0, pos.ch) : line.slice(pos.ch));\n    var fst = cm.firstLine(), lst = cm.lastLine();\n    for (;;) {\n      no += dir;\n      if (no < fst || no > lst)\n        return cm.clipPos(Pos(no - dir, dir < 0 ? 0 : null));\n      line = cm.getLine(no);\n      var hasText = /\\S/.test(line);\n      if (hasText) sawText = true;\n      else if (sawText) return Pos(no, 0);\n    }\n  }\n\n  function bySentence(cm, pos, dir) {\n    var line = pos.line, ch = pos.ch;\n    var text = cm.getLine(pos.line), sawWord = false;\n    for (;;) {\n      var next = text.charAt(ch + (dir < 0 ? -1 : 0));\n      if (!next) { // End/beginning of line reached\n        if (line == (dir < 0 ? cm.firstLine() : cm.lastLine())) return Pos(line, ch);\n        text = cm.getLine(line + dir);\n        if (!/\\S/.test(text)) return Pos(line, ch);\n        line += dir;\n        ch = dir < 0 ? text.length : 0;\n        continue;\n      }\n      if (sawWord && /[!?.]/.test(next)) return Pos(line, ch + (dir > 0 ? 1 : 0));\n      if (!sawWord) sawWord = /\\w/.test(next);\n      ch += dir;\n    }\n  }\n\n  function byExpr(cm, pos, dir) {\n    var wrap;\n    if (cm.findMatchingBracket && (wrap = cm.findMatchingBracket(pos, {strict: true}))\n        && wrap.match && (wrap.forward ? 1 : -1) == dir)\n      return dir > 0 ? Pos(wrap.to.line, wrap.to.ch + 1) : wrap.to;\n\n    for (var first = true;; first = false) {\n      var token = cm.getTokenAt(pos);\n      var after = Pos(pos.line, dir < 0 ? token.start : token.end);\n      if (first && dir > 0 && token.end == pos.ch || !/\\w/.test(token.string)) {\n        var newPos = cm.findPosH(after, dir, \"char\");\n        if (posEq(after, newPos)) return pos;\n        else pos = newPos;\n      } else {\n        return after;\n      }\n    }\n  }\n\n  // Prefixes (only crudely supported)\n\n  function getPrefix(cm, precise) {\n    var digits = cm.state.emacsPrefix;\n    if (!digits) return precise ? null : 1;\n    clearPrefix(cm);\n    return digits == \"-\" ? -1 : Number(digits);\n  }\n\n  function repeated(cmd) {\n    var f = typeof cmd == \"string\" ? function(cm) { cm.execCommand(cmd); } : cmd;\n    return function(cm) {\n      var prefix = getPrefix(cm);\n      f(cm);\n      for (var i = 1; i < prefix; ++i) f(cm);\n    };\n  }\n\n  function findEnd(cm, pos, by, dir) {\n    var prefix = getPrefix(cm);\n    if (prefix < 0) { dir = -dir; prefix = -prefix; }\n    for (var i = 0; i < prefix; ++i) {\n      var newPos = by(cm, pos, dir);\n      if (posEq(newPos, pos)) break;\n      pos = newPos;\n    }\n    return pos;\n  }\n\n  function move(by, dir) {\n    var f = function(cm) {\n      cm.extendSelection(findEnd(cm, cm.getCursor(), by, dir));\n    };\n    f.motion = true;\n    return f;\n  }\n\n  function killTo(cm, by, dir, ring) {\n    var selections = cm.listSelections(), cursor;\n    var i = selections.length;\n    while (i--) {\n      cursor = selections[i].head;\n      _kill(cm, cursor, findEnd(cm, cursor, by, dir), ring);\n    }\n  }\n\n  function _killRegion(cm, ring) {\n    if (cm.somethingSelected()) {\n      var selections = cm.listSelections(), selection;\n      var i = selections.length;\n      while (i--) {\n        selection = selections[i];\n        _kill(cm, selection.anchor, selection.head, ring);\n      }\n      return true;\n    }\n  }\n\n  function addPrefix(cm, digit) {\n    if (cm.state.emacsPrefix) {\n      if (digit != \"-\") cm.state.emacsPrefix += digit;\n      return;\n    }\n    // Not active yet\n    cm.state.emacsPrefix = digit;\n    cm.on(\"keyHandled\", maybeClearPrefix);\n    cm.on(\"inputRead\", maybeDuplicateInput);\n  }\n\n  var prefixPreservingKeys = {\"Alt-G\": true, \"Ctrl-X\": true, \"Ctrl-Q\": true, \"Ctrl-U\": true};\n\n  function maybeClearPrefix(cm, arg) {\n    if (!cm.state.emacsPrefixMap && !prefixPreservingKeys.hasOwnProperty(arg))\n      clearPrefix(cm);\n  }\n\n  function clearPrefix(cm) {\n    cm.state.emacsPrefix = null;\n    cm.off(\"keyHandled\", maybeClearPrefix);\n    cm.off(\"inputRead\", maybeDuplicateInput);\n  }\n\n  function maybeDuplicateInput(cm, event) {\n    var dup = getPrefix(cm);\n    if (dup > 1 && event.origin == \"+input\") {\n      var one = event.text.join(\"\\n\"), txt = \"\";\n      for (var i = 1; i < dup; ++i) txt += one;\n      cm.replaceSelection(txt);\n    }\n  }\n\n  function maybeRemovePrefixMap(cm, arg) {\n    if (typeof arg == \"string\" && (/^\\d$/.test(arg) || arg == \"Ctrl-U\")) return;\n    cm.removeKeyMap(prefixMap);\n    cm.state.emacsPrefixMap = false;\n    cm.off(\"keyHandled\", maybeRemovePrefixMap);\n    cm.off(\"inputRead\", maybeRemovePrefixMap);\n  }\n\n  // Utilities\n\n  cmds.setMark = function (cm) {\n    cm.setCursor(cm.getCursor());\n    cm.setExtending(!cm.getExtending());\n    cm.on(\"change\", function() { cm.setExtending(false); });\n  }\n\n  function clearMark(cm) {\n    cm.setExtending(false);\n    cm.setCursor(cm.getCursor());\n  }\n\n  function makePrompt(msg) {\n    var fragment = document.createDocumentFragment();\n    var input = document.createElement(\"input\");\n    input.setAttribute(\"type\", \"text\");\n    input.style.width = \"10em\";\n    fragment.appendChild(document.createTextNode(msg + \": \"));\n    fragment.appendChild(input);\n    return fragment;\n  }\n\n  function getInput(cm, msg, f) {\n    if (cm.openDialog)\n      cm.openDialog(makePrompt(msg), f, {bottom: true});\n    else\n      f(prompt(msg, \"\"));\n  }\n\n  function operateOnWord(cm, op) {\n    var start = cm.getCursor(), end = cm.findPosH(start, 1, \"word\");\n    cm.replaceRange(op(cm.getRange(start, end)), start, end);\n    cm.setCursor(end);\n  }\n\n  function toEnclosingExpr(cm) {\n    var pos = cm.getCursor(), line = pos.line, ch = pos.ch;\n    var stack = [];\n    while (line >= cm.firstLine()) {\n      var text = cm.getLine(line);\n      for (var i = ch == null ? text.length : ch; i > 0;) {\n        var ch = text.charAt(--i);\n        if (ch == \")\")\n          stack.push(\"(\");\n        else if (ch == \"]\")\n          stack.push(\"[\");\n        else if (ch == \"}\")\n          stack.push(\"{\");\n        else if (/[\\(\\{\\[]/.test(ch) && (!stack.length || stack.pop() != ch))\n          return cm.extendSelection(Pos(line, i));\n      }\n      --line; ch = null;\n    }\n  }\n\n  // Commands. Names should match emacs function names (albeit in camelCase)\n  // except where emacs function names collide with code mirror core commands.\n\n  cmds.killRegion = function(cm) {\n    _kill(cm, cm.getCursor(\"start\"), cm.getCursor(\"end\"), true);\n  };\n\n  // Maps to emacs kill-line\n  cmds.killLineEmacs = repeated(function(cm) {\n    var start = cm.getCursor(), end = cm.clipPos(Pos(start.line));\n    var text = cm.getRange(start, end);\n    if (!/\\S/.test(text)) {\n      text += \"\\n\";\n      end = Pos(start.line + 1, 0);\n    }\n    _kill(cm, start, end, \"grow\", text);\n  });\n\n  cmds.killRingSave = function(cm) {\n    addToRing(cm.getSelection());\n    clearMark(cm);\n  };\n\n  cmds.yank = function(cm) {\n    var start = cm.getCursor();\n    cm.replaceRange(getFromRing(getPrefix(cm)), start, start, \"paste\");\n    cm.setSelection(start, cm.getCursor());\n  };\n\n  cmds.yankPop = function(cm) {\n    cm.replaceSelection(popFromRing(), \"around\", \"paste\");\n  };\n\n  cmds.forwardChar = move(byChar, 1);\n\n  cmds.backwardChar = move(byChar, -1)\n\n  cmds.deleteChar = function(cm) { killTo(cm, byChar, 1, false); };\n\n  cmds.deleteForwardChar = function(cm) {\n    _killRegion(cm, false) || killTo(cm, byChar, 1, false);\n  };\n\n  cmds.deleteBackwardChar = function(cm) {\n    _killRegion(cm, false) || killTo(cm, byChar, -1, false);\n  };\n\n  cmds.forwardWord = move(byWord, 1);\n\n  cmds.backwardWord = move(byWord, -1);\n\n  cmds.killWord = function(cm) { killTo(cm, byWord, 1, \"grow\"); };\n\n  cmds.backwardKillWord = function(cm) { killTo(cm, byWord, -1, \"grow\"); };\n\n  cmds.nextLine = move(byLine, 1);\n\n  cmds.previousLine = move(byLine, -1);\n\n  cmds.scrollDownCommand = move(byPage, -1);\n\n  cmds.scrollUpCommand = move(byPage, 1);\n\n  cmds.backwardParagraph = move(byParagraph, -1);\n\n  cmds.forwardParagraph = move(byParagraph, 1);\n\n  cmds.backwardSentence = move(bySentence, -1);\n\n  cmds.forwardSentence = move(bySentence, 1);\n\n  cmds.killSentence = function(cm) { killTo(cm, bySentence, 1, \"grow\"); };\n\n  cmds.backwardKillSentence = function(cm) {\n    _kill(cm, cm.getCursor(), bySentence(cm, cm.getCursor(), 1), \"grow\");\n  };\n\n  cmds.killSexp = function(cm) { killTo(cm, byExpr, 1, \"grow\"); };\n\n  cmds.backwardKillSexp = function(cm) { killTo(cm, byExpr, -1, \"grow\"); };\n\n  cmds.forwardSexp = move(byExpr, 1);\n\n  cmds.backwardSexp = move(byExpr, -1);\n\n  cmds.markSexp = function(cm) {\n    var cursor = cm.getCursor();\n    cm.setSelection(findEnd(cm, cursor, byExpr, 1), cursor);\n  };\n\n  cmds.transposeSexps = function(cm) {\n    var leftStart = byExpr(cm, cm.getCursor(), -1);\n    var leftEnd = byExpr(cm, leftStart, 1);\n    var rightEnd = byExpr(cm, leftEnd, 1);\n    var rightStart = byExpr(cm, rightEnd, -1);\n    cm.replaceRange(cm.getRange(rightStart, rightEnd) +\n                    cm.getRange(leftEnd, rightStart) +\n                    cm.getRange(leftStart, leftEnd), leftStart, rightEnd);\n  };\n\n  cmds.backwardUpList = repeated(toEnclosingExpr);\n\n  cmds.justOneSpace = function(cm) {\n    var pos = cm.getCursor(), from = pos.ch;\n    var to = pos.ch, text = cm.getLine(pos.line);\n    while (from && /\\s/.test(text.charAt(from - 1))) --from;\n    while (to < text.length && /\\s/.test(text.charAt(to))) ++to;\n    cm.replaceRange(\" \", Pos(pos.line, from), Pos(pos.line, to));\n  };\n\n  cmds.openLine = repeated(function(cm) {\n    cm.replaceSelection(\"\\n\", \"start\");\n  });\n\n  // maps to emacs 'transpose-chars'\n  cmds.transposeCharsRepeatable = repeated(function(cm) {\n    cm.execCommand(\"transposeChars\");\n  });\n\n  cmds.capitalizeWord = repeated(function(cm) {\n    operateOnWord(cm, function(w) {\n      var letter = w.search(/\\w/);\n      if (letter == -1) return w;\n      return w.slice(0, letter) + w.charAt(letter).toUpperCase() +\n          w.slice(letter + 1).toLowerCase();\n    });\n  });\n\n  cmds.upcaseWord = repeated(function(cm) {\n    operateOnWord(cm, function(w) { return w.toUpperCase(); });\n  });\n\n  cmds.downcaseWord = repeated(function(cm) {\n    operateOnWord(cm, function(w) { return w.toLowerCase(); });\n  });\n\n  // maps to emacs 'undo'\n  cmds.undoRepeatable = repeated(\"undo\");\n\n  cmds.keyboardQuit = function(cm) {\n    cm.execCommand(\"clearSearch\");\n    clearMark(cm);\n  }\n\n  cmds.newline = repeated(function(cm) { cm.replaceSelection(\"\\n\", \"end\"); });\n\n  cmds.gotoLine = function(cm) {\n    var prefix = getPrefix(cm, true);\n    if (prefix != null && prefix > 0) return cm.setCursor(prefix - 1);\n\n    getInput(cm, \"Goto line\", function(str) {\n      var num;\n      if (str && !isNaN(num = Number(str)) && num == (num|0) && num > 0)\n      cm.setCursor(num - 1);\n    });\n  };\n\n  cmds.indentRigidly = function(cm) {\n    cm.indentSelection(getPrefix(cm, true) || cm.getOption(\"indentUnit\"));\n  };\n\n  cmds.exchangePointAndMark = function(cm) {\n    cm.setSelection(cm.getCursor(\"head\"), cm.getCursor(\"anchor\"));\n  };\n\n  cmds.quotedInsertTab = repeated(\"insertTab\");\n\n  cmds.universalArgument = function addPrefixMap(cm) {\n    cm.state.emacsPrefixMap = true;\n    cm.addKeyMap(prefixMap);\n    cm.on(\"keyHandled\", maybeRemovePrefixMap);\n    cm.on(\"inputRead\", maybeRemovePrefixMap);\n  };\n\n  CodeMirror.emacs = {kill: _kill, killRegion: _killRegion, repeated: repeated};\n\n  // Actual keymap\n  var keyMap = CodeMirror.keyMap.emacs = CodeMirror.normalizeKeyMap({\n    \"Ctrl-W\": \"killRegion\",\n    \"Ctrl-K\": \"killLineEmacs\",\n    \"Alt-W\": \"killRingSave\",\n    \"Ctrl-Y\": \"yank\",\n    \"Alt-Y\": \"yankPop\",\n    \"Ctrl-Space\": \"setMark\",\n    \"Ctrl-Shift-2\": \"setMark\",\n    \"Ctrl-F\": \"forwardChar\",\n    \"Ctrl-B\": \"backwardChar\",\n    \"Right\": \"forwardChar\",\n    \"Left\": \"backwardChar\",\n    \"Ctrl-D\": \"deleteChar\",\n    \"Delete\": \"deleteForwardChar\",\n    \"Ctrl-H\": \"deleteBackwardChar\",\n    \"Backspace\": \"deleteBackwardChar\",\n    \"Alt-F\": \"forwardWord\",\n    \"Alt-B\": \"backwardWord\",\n    \"Alt-Right\": \"forwardWord\",\n    \"Alt-Left\": \"backwardWord\",\n    \"Alt-D\": \"killWord\",\n    \"Alt-Backspace\": \"backwardKillWord\",\n    \"Ctrl-N\": \"nextLine\",\n    \"Ctrl-P\": \"previousLine\",\n    \"Down\": \"nextLine\",\n    \"Up\": \"previousLine\",\n    \"Ctrl-A\": \"goLineStart\",\n    \"Ctrl-E\": \"goLineEnd\",\n    \"End\": \"goLineEnd\",\n    \"Home\": \"goLineStart\",\n    \"Alt-V\": \"scrollDownCommand\",\n    \"Ctrl-V\": \"scrollUpCommand\",\n    \"PageUp\": \"scrollDownCommand\",\n    \"PageDown\": \"scrollUpCommand\",\n    \"Ctrl-Up\": \"backwardParagraph\",\n    \"Ctrl-Down\": \"forwardParagraph\",\n    \"Alt-{\": \"backwardParagraph\",\n    \"Alt-}\": \"forwardParagraph\",\n    \"Alt-A\": \"backwardSentence\",\n    \"Alt-E\": \"forwardSentence\",\n    \"Alt-K\": \"killSentence\",\n    \"Ctrl-X Delete\": \"backwardKillSentence\",\n    \"Ctrl-Alt-K\": \"killSexp\",\n    \"Ctrl-Alt-Backspace\": \"backwardKillSexp\",\n    \"Ctrl-Alt-F\": \"forwardSexp\",\n    \"Ctrl-Alt-B\": \"backwardSexp\",\n    \"Shift-Ctrl-Alt-2\": \"markSexp\",\n    \"Ctrl-Alt-T\": \"transposeSexps\",\n    \"Ctrl-Alt-U\": \"backwardUpList\",\n    \"Alt-Space\": \"justOneSpace\",\n    \"Ctrl-O\": \"openLine\",\n    \"Ctrl-T\": \"transposeCharsRepeatable\",\n    \"Alt-C\": \"capitalizeWord\",\n    \"Alt-U\": \"upcaseWord\",\n    \"Alt-L\": \"downcaseWord\",\n    \"Alt-;\": \"toggleComment\",\n    \"Ctrl-/\": \"undoRepeatable\",\n    \"Shift-Ctrl--\": \"undoRepeatable\",\n    \"Ctrl-Z\": \"undoRepeatable\",\n    \"Cmd-Z\": \"undoRepeatable\",\n    \"Ctrl-X U\": \"undoRepeatable\",\n    \"Shift-Ctrl-Z\": \"redo\",\n    \"Shift-Alt-,\": \"goDocStart\",\n    \"Shift-Alt-.\": \"goDocEnd\",\n    \"Ctrl-S\": \"findPersistentNext\",\n    \"Ctrl-R\": \"findPersistentPrev\",\n    \"Ctrl-G\": \"keyboardQuit\",\n    \"Shift-Alt-5\": \"replace\",\n    \"Alt-/\": \"autocomplete\",\n    \"Enter\": \"newlineAndIndent\",\n    \"Ctrl-J\": \"newline\",\n    \"Tab\": \"indentAuto\",\n    \"Alt-G G\": \"gotoLine\",\n    \"Ctrl-X Tab\": \"indentRigidly\",\n    \"Ctrl-X Ctrl-X\": \"exchangePointAndMark\",\n    \"Ctrl-X Ctrl-S\": \"save\",\n    \"Ctrl-X Ctrl-W\": \"save\",\n    \"Ctrl-X S\": \"saveAll\",\n    \"Ctrl-X F\": \"open\",\n    \"Ctrl-X K\": \"close\",\n    \"Ctrl-X H\": \"selectAll\",\n    \"Ctrl-Q Tab\": \"quotedInsertTab\",\n    \"Ctrl-U\": \"universalArgument\",\n    \"fallthrough\": \"default\"\n  });\n\n  var prefixMap = {\"Ctrl-G\": clearPrefix};\n  function regPrefix(d) {\n    prefixMap[d] = function(cm) { addPrefix(cm, d); };\n    keyMap[\"Ctrl-\" + d] = function(cm) { addPrefix(cm, d); };\n    prefixPreservingKeys[\"Ctrl-\" + d] = true;\n  }\n  for (var i = 0; i < 10; ++i) regPrefix(String(i));\n  regPrefix(\"-\");\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// A rough approximation of Sublime Text's keybindings\n// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/edit/matchbrackets\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n\n  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.\n  function findPosSubword(doc, start, dir) {\n    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));\n    var line = doc.getLine(start.line);\n    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));\n    var state = \"start\", type, startPos = start.ch;\n    for (var pos = startPos, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n      var next = line.charAt(dir < 0 ? pos - 1 : pos);\n      var cat = next != \"_\" && CodeMirror.isWordChar(next) ? \"w\" : \"o\";\n      if (cat == \"w\" && next.toUpperCase() == next) cat = \"W\";\n      if (state == \"start\") {\n        if (cat != \"o\") { state = \"in\"; type = cat; }\n        else startPos = pos + dir\n      } else if (state == \"in\") {\n        if (type != cat) {\n          if (type == \"w\" && cat == \"W\" && dir < 0) pos--;\n          if (type == \"W\" && cat == \"w\" && dir > 0) { // From uppercase to lowercase\n            if (pos == startPos + 1) { type = \"w\"; continue; }\n            else pos--;\n          }\n          break;\n        }\n      }\n    }\n    return Pos(start.line, pos);\n  }\n\n  function moveSubword(cm, dir) {\n    cm.extendSelectionsBy(function(range) {\n      if (cm.display.shift || cm.doc.extend || range.empty())\n        return findPosSubword(cm.doc, range.head, dir);\n      else\n        return dir < 0 ? range.from() : range.to();\n    });\n  }\n\n  cmds.goSubwordLeft = function(cm) { moveSubword(cm, -1); };\n  cmds.goSubwordRight = function(cm) { moveSubword(cm, 1); };\n\n  cmds.scrollLineUp = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, \"local\");\n      if (cm.getCursor().line >= visibleBottomLine)\n        cm.execCommand(\"goLineUp\");\n    }\n    cm.scrollTo(null, info.top - cm.defaultTextHeight());\n  };\n  cmds.scrollLineDown = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleTopLine = cm.lineAtHeight(info.top, \"local\")+1;\n      if (cm.getCursor().line <= visibleTopLine)\n        cm.execCommand(\"goLineDown\");\n    }\n    cm.scrollTo(null, info.top + cm.defaultTextHeight());\n  };\n\n  cmds.splitSelectionByLine = function(cm) {\n    var ranges = cm.listSelections(), lineRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      for (var line = from.line; line <= to.line; ++line)\n        if (!(to.line > from.line && line == to.line && to.ch == 0))\n          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),\n                           head: line == to.line ? to : Pos(line)});\n    }\n    cm.setSelections(lineRanges, 0);\n  };\n\n  cmds.singleSelectionTop = function(cm) {\n    var range = cm.listSelections()[0];\n    cm.setSelection(range.anchor, range.head, {scroll: false});\n  };\n\n  cmds.selectLine = function(cm) {\n    var ranges = cm.listSelections(), extended = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      extended.push({anchor: Pos(range.from().line, 0),\n                     head: Pos(range.to().line + 1, 0)});\n    }\n    cm.setSelections(extended);\n  };\n\n  function insertLine(cm, above) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    cm.operation(function() {\n      var len = cm.listSelections().length, newSelection = [], last = -1;\n      for (var i = 0; i < len; i++) {\n        var head = cm.listSelections()[i].head;\n        if (head.line <= last) continue;\n        var at = Pos(head.line + (above ? 0 : 1), 0);\n        cm.replaceRange(\"\\n\", at, null, \"+insertLine\");\n        cm.indentLine(at.line, null, true);\n        newSelection.push({head: at, anchor: at});\n        last = head.line + 1;\n      }\n      cm.setSelections(newSelection);\n    });\n    cm.execCommand(\"indentAuto\");\n  }\n\n  cmds.insertLineAfter = function(cm) { return insertLine(cm, false); };\n\n  cmds.insertLineBefore = function(cm) { return insertLine(cm, true); };\n\n  function wordAt(cm, pos) {\n    var start = pos.ch, end = start, line = cm.getLine(pos.line);\n    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;\n    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};\n  }\n\n  cmds.selectNextOccurrence = function(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      cm.setSelection(word.from, word.to);\n      fullWord = true;\n    } else {\n      var text = cm.getRange(from, to);\n      var query = fullWord ? new RegExp(\"\\\\b\" + text + \"\\\\b\") : text;\n      var cur = cm.getSearchCursor(query, to);\n      var found = cur.findNext();\n      if (!found) {\n        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n        found = cur.findNext();\n      }\n      if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to())) return\n      cm.addSelection(cur.from(), cur.to());\n    }\n    if (fullWord)\n      cm.state.sublimeFindFullWord = cm.doc.sel;\n  };\n\n  cmds.skipAndSelectNextOccurrence = function(cm) {\n    var prevAnchor = cm.getCursor(\"anchor\"), prevHead = cm.getCursor(\"head\");\n    cmds.selectNextOccurrence(cm);\n    if (CodeMirror.cmpPos(prevAnchor, prevHead) != 0) {\n      cm.doc.setSelections(cm.doc.listSelections()\n          .filter(function (sel) {\n            return sel.anchor != prevAnchor || sel.head != prevHead;\n          }));\n    }\n  }\n\n  function addCursorToSelection(cm, dir) {\n    var ranges = cm.listSelections(), newRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      var newAnchor = cm.findPosV(\n          range.anchor, dir, \"line\", range.anchor.goalColumn);\n      var newHead = cm.findPosV(\n          range.head, dir, \"line\", range.head.goalColumn);\n      newAnchor.goalColumn = range.anchor.goalColumn != null ?\n          range.anchor.goalColumn : cm.cursorCoords(range.anchor, \"div\").left;\n      newHead.goalColumn = range.head.goalColumn != null ?\n          range.head.goalColumn : cm.cursorCoords(range.head, \"div\").left;\n      var newRange = {anchor: newAnchor, head: newHead};\n      newRanges.push(range);\n      newRanges.push(newRange);\n    }\n    cm.setSelections(newRanges);\n  }\n  cmds.addCursorToPrevLine = function(cm) { addCursorToSelection(cm, -1); };\n  cmds.addCursorToNextLine = function(cm) { addCursorToSelection(cm, 1); };\n\n  function isSelectedRange(ranges, from, to) {\n    for (var i = 0; i < ranges.length; i++)\n      if (CodeMirror.cmpPos(ranges[i].from(), from) == 0 &&\n          CodeMirror.cmpPos(ranges[i].to(), to) == 0) return true\n    return false\n  }\n\n  var mirror = \"(){}[]\";\n  function selectBetweenBrackets(cm) {\n    var ranges = cm.listSelections(), newRanges = []\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], pos = range.head, opening = cm.scanForBracket(pos, -1);\n      if (!opening) return false;\n      for (;;) {\n        var closing = cm.scanForBracket(pos, 1);\n        if (!closing) return false;\n        if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n          var startPos = Pos(opening.pos.line, opening.pos.ch + 1);\n          if (CodeMirror.cmpPos(startPos, range.from()) == 0 &&\n              CodeMirror.cmpPos(closing.pos, range.to()) == 0) {\n            opening = cm.scanForBracket(opening.pos, -1);\n            if (!opening) return false;\n          } else {\n            newRanges.push({anchor: startPos, head: closing.pos});\n            break;\n          }\n        }\n        pos = Pos(closing.pos.line, closing.pos.ch + 1);\n      }\n    }\n    cm.setSelections(newRanges);\n    return true;\n  }\n\n  cmds.selectScope = function(cm) {\n    selectBetweenBrackets(cm) || cm.execCommand(\"selectAll\");\n  };\n  cmds.selectBetweenBrackets = function(cm) {\n    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;\n  };\n\n  function puncType(type) {\n    return !type ? null : /\\bpunctuation\\b/.test(type) ? type : undefined\n  }\n\n  cmds.goToBracket = function(cm) {\n    cm.extendSelectionsBy(function(range) {\n      var next = cm.scanForBracket(range.head, 1, puncType(cm.getTokenTypeAt(range.head)));\n      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;\n      var prev = cm.scanForBracket(range.head, -1, puncType(cm.getTokenTypeAt(Pos(range.head.line, range.head.ch + 1))));\n      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\n    });\n  };\n\n  cmds.swapLineUp = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from().line - 1, to = range.to().line;\n      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),\n                    head: Pos(range.head.line - 1, range.head.ch)});\n      if (range.to().ch == 0 && !range.empty()) --to;\n      if (from > at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = 0; i < linesToMove.length; i += 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        if (to > cm.lastLine())\n          cm.replaceRange(\"\\n\" + line, Pos(cm.lastLine()), null, \"+swapLine\");\n        else\n          cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.setSelections(newSels);\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.swapLineDown = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var range = ranges[i], from = range.to().line + 1, to = range.from().line;\n      if (range.to().ch == 0 && !range.empty()) from--;\n      if (from < at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        if (from == cm.lastLine())\n          cm.replaceRange(\"\", Pos(from - 1), Pos(from), \"+swapLine\");\n        else\n          cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.toggleCommentIndented = function(cm) {\n    cm.toggleComment({ indent: true });\n  }\n\n  cmds.joinLines = function(cm) {\n    var ranges = cm.listSelections(), joined = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from();\n      var start = from.line, end = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)\n        end = ranges[++i].to().line;\n      joined.push({start: start, end: end, anchor: !range.empty() && from});\n    }\n    cm.operation(function() {\n      var offset = 0, ranges = [];\n      for (var i = 0; i < joined.length; i++) {\n        var obj = joined[i];\n        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\n        for (var line = obj.start; line <= obj.end; line++) {\n          var actual = line - offset;\n          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);\n          if (actual < cm.lastLine()) {\n            cm.replaceRange(\" \", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n            ++offset;\n          }\n        }\n        ranges.push({anchor: anchor || head, head: head});\n      }\n      cm.setSelections(ranges, 0);\n    });\n  };\n\n  cmds.duplicateLine = function(cm) {\n    cm.operation(function() {\n      var rangeCount = cm.listSelections().length;\n      for (var i = 0; i < rangeCount; i++) {\n        var range = cm.listSelections()[i];\n        if (range.empty())\n          cm.replaceRange(cm.getLine(range.head.line) + \"\\n\", Pos(range.head.line, 0));\n        else\n          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n\n  function sortLines(cm, caseSensitive, direction) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), toSort = [], selected;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      if (range.empty()) continue;\n      var from = range.from().line, to = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\n        to = ranges[++i].to().line;\n      if (!ranges[i].to().ch) to--;\n      toSort.push(from, to);\n    }\n    if (toSort.length) selected = true;\n    else toSort.push(cm.firstLine(), cm.lastLine());\n\n    cm.operation(function() {\n      var ranges = [];\n      for (var i = 0; i < toSort.length; i += 2) {\n        var from = toSort[i], to = toSort[i + 1];\n        var start = Pos(from, 0), end = Pos(to);\n        var lines = cm.getRange(start, end, false);\n        if (caseSensitive)\n          lines.sort(function(a, b) { return a < b ? -direction : a == b ? 0 : direction; });\n        else\n          lines.sort(function(a, b) {\n            var au = a.toUpperCase(), bu = b.toUpperCase();\n            if (au != bu) { a = au; b = bu; }\n            return a < b ? -direction : a == b ? 0 : direction;\n          });\n        cm.replaceRange(lines, start, end);\n        if (selected) ranges.push({anchor: start, head: Pos(to + 1, 0)});\n      }\n      if (selected) cm.setSelections(ranges, 0);\n    });\n  }\n\n  cmds.sortLines = function(cm) { sortLines(cm, true, 1); };\n  cmds.reverseSortLines = function(cm) { sortLines(cm, true, -1); };\n  cmds.sortLinesInsensitive = function(cm) { sortLines(cm, false, 1); };\n  cmds.reverseSortLinesInsensitive = function(cm) { sortLines(cm, false, -1); };\n\n  cmds.nextBookmark = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      var current = marks.shift();\n      var found = current.find();\n      if (found) {\n        marks.push(current);\n        return cm.setSelection(found.from, found.to);\n      }\n    }\n  };\n\n  cmds.prevBookmark = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      marks.unshift(marks.pop());\n      var found = marks[marks.length - 1].find();\n      if (!found)\n        marks.pop();\n      else\n        return cm.setSelection(found.from, found.to);\n    }\n  };\n\n  cmds.toggleBookmark = function(cm) {\n    var ranges = cm.listSelections();\n    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      var found = ranges[i].empty() ? cm.findMarksAt(from) : cm.findMarks(from, to);\n      for (var j = 0; j < found.length; j++) {\n        if (found[j].sublimeBookmark) {\n          found[j].clear();\n          for (var k = 0; k < marks.length; k++)\n            if (marks[k] == found[j])\n              marks.splice(k--, 1);\n          break;\n        }\n      }\n      if (j == found.length)\n        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));\n    }\n  };\n\n  cmds.clearBookmarks = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n    marks.length = 0;\n  };\n\n  cmds.selectBookmarks = function(cm) {\n    var marks = cm.state.sublimeBookmarks, ranges = [];\n    if (marks) for (var i = 0; i < marks.length; i++) {\n      var found = marks[i].find();\n      if (!found)\n        marks.splice(i--, 0);\n      else\n        ranges.push({anchor: found.from, head: found.to});\n    }\n    if (ranges.length)\n      cm.setSelections(ranges, 0);\n  };\n\n  function modifyWordOrSelection(cm, mod) {\n    cm.operation(function() {\n      var ranges = cm.listSelections(), indices = [], replacements = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.empty()) { indices.push(i); replacements.push(\"\"); }\n        else replacements.push(mod(cm.getRange(range.from(), range.to())));\n      }\n      cm.replaceSelections(replacements, \"around\", \"case\");\n      for (var i = indices.length - 1, at; i >= 0; i--) {\n        var range = ranges[indices[i]];\n        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;\n        var word = wordAt(cm, range.head);\n        at = word.from;\n        cm.replaceRange(mod(word.word), word.from, word.to);\n      }\n    });\n  }\n\n  cmds.smartBackspace = function(cm) {\n    if (cm.somethingSelected()) return CodeMirror.Pass;\n\n    cm.operation(function() {\n      var cursors = cm.listSelections();\n      var indentUnit = cm.getOption(\"indentUnit\");\n\n      for (var i = cursors.length - 1; i >= 0; i--) {\n        var cursor = cursors[i].head;\n        var toStartOfLine = cm.getRange({line: cursor.line, ch: 0}, cursor);\n        var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption(\"tabSize\"));\n\n        // Delete by one character by default\n        var deletePos = cm.findPosH(cursor, -1, \"char\", false);\n\n        if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n          var prevIndent = new Pos(cursor.line,\n            CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));\n\n          // Smart delete only if we found a valid prevIndent location\n          if (prevIndent.ch != cursor.ch) deletePos = prevIndent;\n        }\n\n        cm.replaceRange(\"\", deletePos, cursor, \"+delete\");\n      }\n    });\n  };\n\n  cmds.delLineRight = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = ranges.length - 1; i >= 0; i--)\n        cm.replaceRange(\"\", ranges[i].anchor, Pos(ranges[i].to().line), \"+delete\");\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.upcaseAtCursor = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });\n  };\n  cmds.downcaseAtCursor = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });\n  };\n\n  cmds.setSublimeMark = function(cm) {\n    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();\n    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n  };\n  cmds.selectToSublimeMark = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) cm.setSelection(cm.getCursor(), found);\n  };\n  cmds.deleteToSublimeMark = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      var from = cm.getCursor(), to = found;\n      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }\n      cm.state.sublimeKilled = cm.getRange(from, to);\n      cm.replaceRange(\"\", from, to);\n    }\n  };\n  cmds.swapWithSublimeMark = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      cm.state.sublimeMark.clear();\n      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n      cm.setCursor(found);\n    }\n  };\n  cmds.sublimeYank = function(cm) {\n    if (cm.state.sublimeKilled != null)\n      cm.replaceSelection(cm.state.sublimeKilled, null, \"paste\");\n  };\n\n  cmds.showInCenter = function(cm) {\n    var pos = cm.cursorCoords(null, \"local\");\n    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n  };\n\n  function getTarget(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      from = word.from;\n      to = word.to;\n    }\n    return {from: from, to: to, query: cm.getRange(from, to), word: word};\n  }\n\n  function findAndGoTo(cm, forward) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var query = target.query;\n    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\n\n    if (forward ? cur.findNext() : cur.findPrevious()) {\n      cm.setSelection(cur.from(), cur.to());\n    } else {\n      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)\n                                              : cm.clipPos(Pos(cm.lastLine())));\n      if (forward ? cur.findNext() : cur.findPrevious())\n        cm.setSelection(cur.from(), cur.to());\n      else if (target.word)\n        cm.setSelection(target.from, target.to);\n    }\n  };\n  cmds.findUnder = function(cm) { findAndGoTo(cm, true); };\n  cmds.findUnderPrevious = function(cm) { findAndGoTo(cm,false); };\n  cmds.findAllUnder = function(cm) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var cur = cm.getSearchCursor(target.query);\n    var matches = [];\n    var primaryIndex = -1;\n    while (cur.findNext()) {\n      matches.push({anchor: cur.from(), head: cur.to()});\n      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)\n        primaryIndex++;\n    }\n    cm.setSelections(matches, primaryIndex);\n  };\n\n\n  var keyMap = CodeMirror.keyMap;\n  keyMap.macSublime = {\n    \"Cmd-Left\": \"goLineStartSmart\",\n    \"Shift-Tab\": \"indentLess\",\n    \"Shift-Ctrl-K\": \"deleteLine\",\n    \"Alt-Q\": \"wrapLines\",\n    \"Ctrl-Left\": \"goSubwordLeft\",\n    \"Ctrl-Right\": \"goSubwordRight\",\n    \"Ctrl-Alt-Up\": \"scrollLineUp\",\n    \"Ctrl-Alt-Down\": \"scrollLineDown\",\n    \"Cmd-L\": \"selectLine\",\n    \"Shift-Cmd-L\": \"splitSelectionByLine\",\n    \"Esc\": \"singleSelectionTop\",\n    \"Cmd-Enter\": \"insertLineAfter\",\n    \"Shift-Cmd-Enter\": \"insertLineBefore\",\n    \"Cmd-D\": \"selectNextOccurrence\",\n    \"Shift-Cmd-Space\": \"selectScope\",\n    \"Shift-Cmd-M\": \"selectBetweenBrackets\",\n    \"Cmd-M\": \"goToBracket\",\n    \"Cmd-Ctrl-Up\": \"swapLineUp\",\n    \"Cmd-Ctrl-Down\": \"swapLineDown\",\n    \"Cmd-/\": \"toggleCommentIndented\",\n    \"Cmd-J\": \"joinLines\",\n    \"Shift-Cmd-D\": \"duplicateLine\",\n    \"F5\": \"sortLines\",\n    \"Shift-F5\": \"reverseSortLines\",\n    \"Cmd-F5\": \"sortLinesInsensitive\",\n    \"Shift-Cmd-F5\": \"reverseSortLinesInsensitive\",\n    \"F2\": \"nextBookmark\",\n    \"Shift-F2\": \"prevBookmark\",\n    \"Cmd-F2\": \"toggleBookmark\",\n    \"Shift-Cmd-F2\": \"clearBookmarks\",\n    \"Alt-F2\": \"selectBookmarks\",\n    \"Backspace\": \"smartBackspace\",\n    \"Cmd-K Cmd-D\": \"skipAndSelectNextOccurrence\",\n    \"Cmd-K Cmd-K\": \"delLineRight\",\n    \"Cmd-K Cmd-U\": \"upcaseAtCursor\",\n    \"Cmd-K Cmd-L\": \"downcaseAtCursor\",\n    \"Cmd-K Cmd-Space\": \"setSublimeMark\",\n    \"Cmd-K Cmd-A\": \"selectToSublimeMark\",\n    \"Cmd-K Cmd-W\": \"deleteToSublimeMark\",\n    \"Cmd-K Cmd-X\": \"swapWithSublimeMark\",\n    \"Cmd-K Cmd-Y\": \"sublimeYank\",\n    \"Cmd-K Cmd-C\": \"showInCenter\",\n    \"Cmd-K Cmd-G\": \"clearBookmarks\",\n    \"Cmd-K Cmd-Backspace\": \"delLineLeft\",\n    \"Cmd-K Cmd-1\": \"foldAll\",\n    \"Cmd-K Cmd-0\": \"unfoldAll\",\n    \"Cmd-K Cmd-J\": \"unfoldAll\",\n    \"Ctrl-Shift-Up\": \"addCursorToPrevLine\",\n    \"Ctrl-Shift-Down\": \"addCursorToNextLine\",\n    \"Cmd-F3\": \"findUnder\",\n    \"Shift-Cmd-F3\": \"findUnderPrevious\",\n    \"Alt-F3\": \"findAllUnder\",\n    \"Shift-Cmd-[\": \"fold\",\n    \"Shift-Cmd-]\": \"unfold\",\n    \"Cmd-I\": \"findIncremental\",\n    \"Shift-Cmd-I\": \"findIncrementalReverse\",\n    \"Cmd-H\": \"replace\",\n    \"F3\": \"findNext\",\n    \"Shift-F3\": \"findPrev\",\n    \"fallthrough\": \"macDefault\"\n  };\n  CodeMirror.normalizeKeyMap(keyMap.macSublime);\n\n  keyMap.pcSublime = {\n    \"Shift-Tab\": \"indentLess\",\n    \"Shift-Ctrl-K\": \"deleteLine\",\n    \"Alt-Q\": \"wrapLines\",\n    \"Ctrl-T\": \"transposeChars\",\n    \"Alt-Left\": \"goSubwordLeft\",\n    \"Alt-Right\": \"goSubwordRight\",\n    \"Ctrl-Up\": \"scrollLineUp\",\n    \"Ctrl-Down\": \"scrollLineDown\",\n    \"Ctrl-L\": \"selectLine\",\n    \"Shift-Ctrl-L\": \"splitSelectionByLine\",\n    \"Esc\": \"singleSelectionTop\",\n    \"Ctrl-Enter\": \"insertLineAfter\",\n    \"Shift-Ctrl-Enter\": \"insertLineBefore\",\n    \"Ctrl-D\": \"selectNextOccurrence\",\n    \"Shift-Ctrl-Space\": \"selectScope\",\n    \"Shift-Ctrl-M\": \"selectBetweenBrackets\",\n    \"Ctrl-M\": \"goToBracket\",\n    \"Shift-Ctrl-Up\": \"swapLineUp\",\n    \"Shift-Ctrl-Down\": \"swapLineDown\",\n    \"Ctrl-/\": \"toggleCommentIndented\",\n    \"Ctrl-J\": \"joinLines\",\n    \"Shift-Ctrl-D\": \"duplicateLine\",\n    \"F9\": \"sortLines\",\n    \"Shift-F9\": \"reverseSortLines\",\n    \"Ctrl-F9\": \"sortLinesInsensitive\",\n    \"Shift-Ctrl-F9\": \"reverseSortLinesInsensitive\",\n    \"F2\": \"nextBookmark\",\n    \"Shift-F2\": \"prevBookmark\",\n    \"Ctrl-F2\": \"toggleBookmark\",\n    \"Shift-Ctrl-F2\": \"clearBookmarks\",\n    \"Alt-F2\": \"selectBookmarks\",\n    \"Backspace\": \"smartBackspace\",\n    \"Ctrl-K Ctrl-D\": \"skipAndSelectNextOccurrence\",\n    \"Ctrl-K Ctrl-K\": \"delLineRight\",\n    \"Ctrl-K Ctrl-U\": \"upcaseAtCursor\",\n    \"Ctrl-K Ctrl-L\": \"downcaseAtCursor\",\n    \"Ctrl-K Ctrl-Space\": \"setSublimeMark\",\n    \"Ctrl-K Ctrl-A\": \"selectToSublimeMark\",\n    \"Ctrl-K Ctrl-W\": \"deleteToSublimeMark\",\n    \"Ctrl-K Ctrl-X\": \"swapWithSublimeMark\",\n    \"Ctrl-K Ctrl-Y\": \"sublimeYank\",\n    \"Ctrl-K Ctrl-C\": \"showInCenter\",\n    \"Ctrl-K Ctrl-G\": \"clearBookmarks\",\n    \"Ctrl-K Ctrl-Backspace\": \"delLineLeft\",\n    \"Ctrl-K Ctrl-1\": \"foldAll\",\n    \"Ctrl-K Ctrl-0\": \"unfoldAll\",\n    \"Ctrl-K Ctrl-J\": \"unfoldAll\",\n    \"Ctrl-Alt-Up\": \"addCursorToPrevLine\",\n    \"Ctrl-Alt-Down\": \"addCursorToNextLine\",\n    \"Ctrl-F3\": \"findUnder\",\n    \"Shift-Ctrl-F3\": \"findUnderPrevious\",\n    \"Alt-F3\": \"findAllUnder\",\n    \"Shift-Ctrl-[\": \"fold\",\n    \"Shift-Ctrl-]\": \"unfold\",\n    \"Ctrl-I\": \"findIncremental\",\n    \"Shift-Ctrl-I\": \"findIncrementalReverse\",\n    \"Ctrl-H\": \"replace\",\n    \"F3\": \"findNext\",\n    \"Shift-F3\": \"findPrev\",\n    \"fallthrough\": \"pcDefault\"\n  };\n  CodeMirror.normalizeKeyMap(keyMap.pcSublime);\n\n  var mac = keyMap.default == keyMap.macDefault;\n  keyMap.sublime = mac ? keyMap.macSublime : keyMap.pcSublime;\n});\n","(function(mod) {\n    if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n      mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/dialog/dialog\"), require(\"../addon/edit/matchbrackets.js\"));\n    else if (typeof define == \"function\" && define.amd) // AMD\n      define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);\n    else // Plain browser env\n      mod(CodeMirror);\n  })(function(CodeMirror) {\n    'use strict';\n  // CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\nfunction initVim$1(CodeMirror) {\n\n  var Pos = CodeMirror.Pos;\n\n  function transformCursor(cm, range) {\n    var vim = cm.state.vim;\n    if (!vim || vim.insertMode) return range.head;\n    var head = vim.sel.head;\n    if (!head)  return range.head;\n\n    if (vim.visualBlock) {\n      if (range.head.line != head.line) {\n        return;\n      }\n    }\n    if (range.from() == range.anchor && !range.empty()) {\n      if (range.head.line == head.line && range.head.ch != head.ch)\n        return new Pos(range.head.line, range.head.ch - 1);\n    }\n\n    return range.head;\n  }\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: 'g<Up>', type: 'keyToKey', toKeys: 'gk' },\n    { keys: 'g<Down>', type: 'keyToKey', toKeys: 'gj' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>' }, // ipad keyboard sends C-Esc instead of C-[\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'keyToKey', toKeys: 'i', context: 'normal'},\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    {keys: \"g$\", type: \"motion\", motion: \"moveToEndOfDisplayLine\"},\n    {keys: \"g^\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    {keys: \"g0\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true }},\n    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-u>', type: 'operatorMotion', operator: 'delete', motion: 'moveToStartOfLine', context: 'insert' },\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    //ignore C-w in normal mode\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal'},\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n  var defaultKeymapLength = defaultKeymap.length;\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'vglobal', shortName: 'v' },\n    { name: 'global', shortName: 'g' }\n  ];\n\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n      if (highlightTimeout) clearTimeout(highlightTimeout);\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim) {\n        cm.options.$customCursor = null;\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim) {\n        if (cm.curOp) cm.curOp.selectionChanged = true;\n        cm.options.$customCursor = transformCursor;\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = vimApi.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {Shift:'S',Ctrl:'C',Alt:'A',Cmd:'D',Mod:'A',CapsLock:''};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '_', '/']);\n    var upperCaseChars;\n    try { upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\"); }\n    catch (_) { upperCaseChars = /^[A-Z]$/; }\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return upperCaseChars.test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        find: find,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            var template = dom('span', {class: 'cm-vim-message'}, 'recording @' + registerName);\n            this.onRecordingDone = cm.openDialog(template, null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi = {\n      enterVimMode: enterVimMode,\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyway.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        return exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // Non-recursive map function.\n      // NOTE: This will not create mappings to key maps that aren't present\n      // in the default key map. See TODO at bottom of function.\n      noremap: function(lhs, rhs, ctx) {\n        function toCtxArray(ctx) {\n          return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n        }\n        var ctxsToMap = toCtxArray(ctx);\n        // Look through all actual defaults to find a map candidate.\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        for (var i = actualLength - origLength;\n             i < actualLength && ctxsToMap.length;\n             i++) {\n          var mapping = defaultKeymap[i];\n          // Omit mappings that operate in the wrong context(s) and those of invalid type.\n          if (mapping.keys == rhs &&\n              (!ctx || !mapping.context || mapping.context === ctx) &&\n              mapping.type.substr(0, 2) !== 'ex' &&\n              mapping.type.substr(0, 3) !== 'key') {\n            // Make a shallow copy of the original keymap entry.\n            var newMapping = {};\n            for (var key in mapping) {\n              newMapping[key] = mapping[key];\n            }\n            // Modify it point to the new mapping with the proper context.\n            newMapping.keys = lhs;\n            if (ctx && !newMapping.context) {\n              newMapping.context = ctx;\n            }\n            // Add it to the keymap with a higher priority than the original.\n            this._mapCommand(newMapping);\n            // Record the mapped contexts as complete.\n            var mappedCtxs = toCtxArray(mapping.context);\n            ctxsToMap = ctxsToMap.filter(function(el) { return mappedCtxs.indexOf(el) === -1; });\n          }\n        }\n        // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.\n      },\n      // Remove all user-defined mappings for the provided context.\n      mapclear: function(ctx) {\n        // Partition the existing keymap into user-defined and true defaults.\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n          // If a specific context is being cleared, we need to keep mappings\n          // from all other contexts.\n          for (var i = userKeymap.length - 1; i >= 0; i--) {\n            var mapping = userKeymap[i];\n            if (ctx !== mapping.context) {\n              if (mapping.context) {\n                this._mapCommand(mapping);\n              } else {\n                // `mapping` applies to all contexts so create keymap copies\n                // for each context except the one being cleared.\n                var contexts = ['normal', 'insert', 'visual'];\n                for (var j in contexts) {\n                  if (contexts[j] !== ctx) {\n                    var newMapping = {};\n                    for (var key in mapping) {\n                      newMapping[key] = mapping[key];\n                    }\n                    newMapping.context = contexts[j];\n                    this._mapCommand(newMapping);\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      multiSelectHandleKey: multiSelectHandleKey,\n\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            if (vim.visualMode) {\n              // Get back to normal mode.\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              // Get back to normal mode.\n              exitInsertMode(cm);\n            } else {\n              // We're already in normal mode. Let '<Esc>' be handled normally.\n              return;\n            }\n            clearInputState(cm);\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            vimApi.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var mainKey = keysMatcher[2] || keysMatcher[1];\n          if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n            // multikey operators act linewise by repeating only the last character\n            mainKey = vim.inputState.operatorShortcut;\n          }\n          var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n          else if (match.type == 'clear') { clearInputState(cm); return true; }\n\n          vim.inputState.keyBuffer = '';\n          keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!vimApi.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        // The black hole register, \"_, means delete/yank to nowhere.\n        if (registerName === '_') return;\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character || character.length > 1) return {type: 'clear'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (command.keys.length > 1) {\n          inputState.operatorShortcut = command.keys;\n        }\n        if (command.exitVisualBlock) {\n            vim.visualBlock = false;\n            updateCmSelection(cm);\n        }\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: '(JavaScript regexp)',\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n          clearInputState(cm);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      /**\n       * Find and select the next occurrence of the search query. If the cursor is currently\n       * within a match, then find and select the current match. Otherwise, find the next occurrence in the\n       * appropriate direction.\n       *\n       * This differs from `findNext` in the following ways:\n       *\n       * 1. Instead of only returning the \"from\", this returns a \"from\", \"to\" range.\n       * 2. If the cursor is currently inside a search match, this selects the current match\n       *    instead of the next match.\n       * 3. If there is no associated operator, this will turn on visual mode.\n       */\n      findAndSelectNextInclusive: function(cm, _head, motionArgs, vim, prevInputState) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n\n        if (!query) {\n          return;\n        }\n\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n\n        // next: [from, to] | null\n        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n\n        // No matches.\n        if (!next) {\n          return;\n        }\n\n        // If there's an operator that will be executed, return the selection.\n        if (prevInputState.operator) {\n          return next;\n        }\n\n        // At this point, we know that there is no accompanying operator -- let's\n        // deal with visual mode in order to select an appropriate match.\n\n        var from = next[0];\n        // For whatever reason, when we use the \"to\" as returned by searchcursor.js directly,\n        // the resulting selection is extended by 1 char. Let's shrink it so that only the\n        // match is selected.\n        var to = new Pos(next[1].line, next[1].ch - 1);\n\n        if (vim.visualMode) {\n          // If we were in visualLine or visualBlock mode, get out of it.\n          if (vim.visualLine || vim.visualBlock) {\n            vim.visualLine = false;\n            vim.visualBlock = false;\n            CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n          }\n\n          // If we're currently in visual mode, we should extend the selection to include\n          // the search result.\n          var anchor = vim.sel.anchor;\n          if (anchor) {\n            if (state.isReversed()) {\n              if (motionArgs.forward) {\n                return [anchor, from];\n              }\n\n              return [anchor, to];\n            } else {\n              if (motionArgs.forward) {\n                return [anchor, to];\n              }\n\n              return [anchor, from];\n            }\n          }\n        } else {\n          // Let's turn visual mode on.\n          vim.visualMode = true;\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n        }\n\n        return prev ? [to, from] : [from, to];\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return new Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        var posV = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);\n        var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;\n        if (hasMarkedText) {\n          line = posV.line;\n          endCh = posV.ch;\n        }\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        } else if (line > last && cur.line == last){\n            return moveToEol(cm, head, motionArgs, vim, true);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(new Pos(line, endCh),'div').left;\n        return new Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim) {\n        return moveToEol(cm, head, motionArgs, vim, false);\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return new Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          // Only include angle brackets in analysis if they are being matched.\n          var re = (ch === '<' || ch === '>') ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n          var matched = cm.findMatchingBracket(new Pos(line, ch), {bracketRegex: re});\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return new Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return new Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      moveToStartOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineLeft\");\n        return cm.getCursor();\n      },\n      moveToEndOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineRight\");\n        var head = cm.getCursor();\n        if (head.sticky == \"before\") head.ch--;\n        return head;\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '[',\n                             '<': '>', '>': '<'};\n        var selfPaired = {'\\'': true, '\"': true, '`': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else if (character === 't') {\n          tmp = expandTagUnderCursor(cm, head, inclusive);\n        } else if (character === 's') {\n          // account for cursor on end of sentence symbol\n          var content = cm.getLine(head.line);\n          if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n            head.ch -= 1;\n          }\n          var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n          var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n          // closer vim behaviour, 'a' only takes the space after the sentence if there is one before and after\n          if (isWhiteSpaceString(cm.getLine(start.line)[start.ch])\n              && isWhiteSpaceString(cm.getLine(end.line)[end.ch -1])) {\n            start = {line: start.line, ch: start.ch + 1};\n          }\n          tmp = {start: start, end: end};\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n        if (!vim.visualMode) {\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else if (args.fullLine) {\n            head.ch = Number.MAX_VALUE;\n            head.line--;\n            cm.setSelection(anchor, head);\n            text = cm.getSelection();\n            cm.replaceSelection(\"\");\n            finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        if (cm.indentMore) {\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          for (var j = 0; j < repeat; j++) {\n            if (args.indentRight) cm.indentMore();\n            else cm.indentLess();\n          }\n        } else {\n          var startLine = ranges[0].anchor.line;\n          var endLine = vim.visualBlock ?\n            ranges[ranges.length - 1].anchor.line :\n            ranges[0].head.line;\n          // In visual mode, n> shifts the selection right n times, instead of\n          // shifting n lines right once.\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          if (args.linewise) {\n            // The only way to delete a newline is to delete until the start of\n            // the next line, so in linewise mode evalInput will include the next\n            // line. We don't want this in indent, so we go back a line.\n            endLine--;\n          }\n          for (var i = startLine; i <= endLine; i++) {\n            for (var j = 0; j < repeat; j++) {\n              cm.indentLine(i, args.indentRight);\n            }\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      indentAuto: function(cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        switch (actionArgs.position) {\n          case 'center': y = charCoords.bottom - height / 2;\n            break;\n          case 'bottom':\n            var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n            var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n            var lineHeight = lineLastCharCoords.bottom - y;\n            y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        } else {\n          macroModeState.latestRegister = registerName;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = new Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'bol') {\n          head = new Pos(head.line, 0);\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch, sel.anchor.ch) + 1);\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        } else if (insertAt == 'lastEdit') {\n          head = getLastEditPos(cm) || head;\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = new Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = actionArgs.keepSpaces\n            ? text.replace(/\\n\\r?/g, '')\n            : text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = new Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n          text = text.split('\\n');\n          if (linewise) {\n              text.pop();\n          }\n          for (var i = 0; i < text.length; i++) {\n            text[i] = (text[i] == '') ? ' ' : text[i];\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        } else if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = new Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  new Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, new Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = new Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = new Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = new Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (match) {\n          var baseStr = match[2] || match[4];\n          var digits = match[3] || match[5];\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n          var from = new Pos(cur.line, start);\n          var to = new Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur) {\n      var vim = cm.state.vim;\n      var includeLineBreak = vim.insertMode || vim.visualMode;\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return new Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return new Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(new Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = new Pos(i, selectionStart.ch);\n            var head = new Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = new Pos(selectionStart.line, 0);\n            selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            fromCh = anchor.ch,\n            bottom = Math.max(anchor.line, head.line),\n            toCh = head.ch;\n        if (fromCh < toCh) { toCh += 1; }\n        else { fromCh += 1; }        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: new Pos(top + i, fromCh),\n            head: new Pos(top + i, toCh)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: new Pos(cur.line, start), end: new Pos(cur.line, end) };\n    }\n\n    /**\n     * Depends on the following:\n     *\n     * - editor mode should be htmlmixedmode / xml\n     * - mode/xml/xml.js should be loaded\n     * - addon/fold/xml-fold.js should be loaded\n     *\n     * If any of the above requirements are not true, this function noops.\n     *\n     * This is _NOT_ a 100% accurate implementation of vim tag text objects.\n     * The following caveats apply (based off cursory testing, I'm sure there\n     * are other discrepancies):\n     *\n     * - Does not work inside comments:\n     *   ```\n     *   <!-- <div>broken</div> -->\n     *   ```\n     * - Does not work when tags have different cases:\n     *   ```\n     *   <div>broken</DIV>\n     *   ```\n     * - Does not work when cursor is inside a broken tag:\n     *   ```\n     *   <div><brok><en></div>\n     *   ```\n     */\n    function expandTagUnderCursor(cm, head, inclusive) {\n      var cur = head;\n      if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n        return { start: cur, end: cur };\n      }\n\n      var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n      if (!tags || !tags.open || !tags.close) {\n        return { start: cur, end: cur };\n      }\n\n      if (inclusive) {\n        return { start: tags.open.from, end: tags.close.to };\n      }\n      return { start: tags.open.to, end: tags.close.from };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/^#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return new Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = new Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return new Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return new Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n      var cur = head;\n      var retval= new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      var end=cm.clipPos(retval);\n      end.ch--;\n      if (!keepHPos) {\n        vim.lastHPos = Infinity;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n      }\n      return retval;\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return new Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, new Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n  function getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n    /*\n    Takes an index object\n    {\n    line: the line string,\n    ln: line number,\n    pos: index in line,\n    dir: direction of traversal (-1 or 1)\n    }\n    and modifies the pos member to represent the\n    next valid position or sets the line to null if there are\n    no more valid positions.\n   */\n    function nextChar(curr) {\n      if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n          curr.line = null;\n        }\n      else {\n        curr.pos += curr.dir;\n      }\n    }\n    /*\n    Performs one iteration of traversal in forward direction\n    Returns an index object of the new location\n   */\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      if (curr.line === \"\") {\n        return { ln: curr.ln, pos: curr.pos };\n      }\n\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        lastSentencePos = curr.pos;\n        if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return { ln: curr.ln, pos: curr.pos + 1 };\n          } else {\n            nextChar(curr);\n            while (curr.line !== null ) {\n              if (isWhiteSpaceString(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n                nextChar(curr);\n              } else {\n                break;\n              }\n            }\n            return { ln: curr.ln, pos: lastSentencePos + 1, };\n          }\n        }\n        nextChar(curr);\n      }\n      return { ln: curr.ln, pos: lastSentencePos + 1 };\n    }\n\n    /*\n    Performs one iteration of traversal in reverse direction\n    Returns an index object of the new location\n   */\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      if (curr.line === \"\") {\n        return { ln: curr.ln, pos: curr.pos };\n      }\n\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          lastSentencePos = curr.pos;\n        }\n\n        else if (isEndOfSentenceSymbol(curr.line[curr.pos]) ) {\n          if (!inclusive) {\n            return { ln: curr.ln, pos: lastSentencePos };\n          } else {\n              if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n                return { ln: curr.ln, pos: curr.pos + 1, };\n              } else {\n                return {ln: curr.ln, pos: lastSentencePos};\n              }\n          }\n        }\n\n        nextChar(curr);\n      }\n      curr.line = line;\n      if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n        return { ln: curr.ln, pos: curr.pos };\n      } else {\n        return { ln: curr.ln, pos: lastSentencePos };\n      }\n\n    }\n\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch,\n    };\n\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n\n  function findSentence(cm, cur, repeat, dir) {\n\n    /*\n    Takes an index object\n    {\n    line: the line string,\n    ln: line number,\n    pos: index in line,\n    dir: direction of traversal (-1 or 1)\n    }\n    and modifies the line, ln, and pos members to represent the\n    next valid position or sets them to null if there are\n    no more valid positions.\n   */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n          idx.pos += idx.dir;\n        }\n      }\n\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n            && !stop\n            && (curr.pos === curr.line.length - 1\n              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: null,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            }\n            else {\n              return { ln: curr.ln, pos: curr.pos };\n            }\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n              && last_valid.pos !== null\n              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          }\n          else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = { ln: curr.ln, pos: curr.pos };\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return new Pos(curr_index.ln, curr_index.pos);\n    }\n\n    // TODO: perhaps this finagling of start and end positions belongs\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: new Pos(cur.line, start),\n        end: new Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator)\n        separator = '/';\n\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&':'&'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'im' : 'm');\n      return regexp;\n    }\n\n    /**\n     * dom - Document Object Manipulator\n     * Usage:\n     *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])\n     * Examples:\n     *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))\n     *   dom(document.head, dom('script', 'alert(\"hello!\")'))\n     * Not supported:\n     *   dom('p', ['arrays are objects'], Error('objects specify attributes'))\n     */\n    function dom(n) {\n      if (typeof n === 'string') n = document.createElement(n);\n      for (var a, i = 1; i < arguments.length; i++) {\n        if (!(a = arguments[i])) continue;\n        if (typeof a !== 'object') a = document.createTextNode(a);\n        if (a.nodeType) n.appendChild(a);\n        else for (var key in a) {\n          if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n          if (key[0] === '$') n.style[key.slice(1)] = a[key];\n          else n.setAttribute(key, a[key]);\n        }\n      }\n      return n;\n    }\n\n    function showConfirm(cm, template) {\n      var pre = dom('div', {$color: 'red', $whiteSpace: 'pre', class: 'cm-vim-message'}, template);\n      if (cm.openNotification) {\n        cm.openNotification(pre, {bottom: true, duration: 5000});\n      } else {\n        alert(pre.innerText);\n      }\n    }\n\n    function makePrompt(prefix, desc) {\n      return dom(document.createDocumentFragment(),\n               dom('span', {$fontFamily: 'monospace', $whiteSpace: 'pre'},\n                 prefix,\n                 dom('input', {type: 'text', autocorrect: 'off',\n                               autocapitalize: 'off', spellcheck: 'false'})),\n               desc && dom('span', {$color: '#888'}, desc));\n    }\n\n    function showPrompt(cm, options) {\n      var template = makePrompt(options.prefix, options.desc);\n      if (cm.openDialog) {\n        cm.openDialog(template, options.onClose, {\n          onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n          bottom: true, selectValueOnOpen: false, value: options.value\n        });\n      }\n      else {\n        var shortText = '';\n        if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n        if (options.desc) shortText += \" \" + options.desc;\n        options.onClose(prompt(shortText, ''));\n      }\n    }\n\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    var highlightTimeout = 0;\n    function highlightSearchMatches(cm, query) {\n      clearTimeout(highlightTimeout);\n      highlightTimeout = setTimeout(function() {\n        if (!cm.state.vim) return;\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (!overlay || query != overlay.query) {\n          if (overlay) {\n            cm.removeOverlay(overlay);\n          }\n          overlay = searchOverlay(query);\n          cm.addOverlay(overlay);\n          if (cm.showMatchesOnScrollbar) {\n            if (searchState.getScrollbarAnnotate()) {\n              searchState.getScrollbarAnnotate().clear();\n            }\n            searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n          }\n          searchState.setOverlay(overlay);\n        }\n      }, 50);\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n            var lastEndPos = prev ? cursor.from() : cursor.to();\n            found = cursor.find(prev);\n            if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n              if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)\n                found = cursor.find(prev);\n            }\n          }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    /**\n     * Pretty much the same as `findNext`, except for the following differences:\n     *\n     * 1. Before starting the search, move to the previous search. This way if our cursor is\n     * already inside a match, we should return the current match.\n     * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.\n     */\n    function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n\n        // Go back one result to ensure that if the cursor is currently a match, we keep it.\n        var found = cursor.find(!prev);\n\n        // If we haven't moved, go back one more (similar to if i==0 logic in findNext).\n        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n          cursor.find(!prev);\n        }\n\n        for (var i = 0; i < repeat; i++) {\n          found = cursor.find(prev);\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return [cursor.from(), cursor.to()];\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (typeof end == 'number') {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n      } else if (markName == '.') {\n        return getLastEditPos(cm);\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    function getLastEditPos(cm) {\n      var done = cm.doc.history.done;\n      for (var i = done.length; i--;) {\n        if (done[i].changes) {\n          return copyCursor(done[i].changes[0].to);\n        }\n      }\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                vimApi.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return true;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return true;\n            }\n          }\n        }\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n        }\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------\\n\\n';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '\\n';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = new Pos(lineStart, 0);\n        var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      vglobal: function(cm, params) {\n        // global inspects params.commandName\n        this.global(cm, params);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        var inverted = params.commandName[0] === 'v';\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [];\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var line = cm.getLineHandle(i);\n          var matched = query.test(line.text);\n          if (matched !== inverted) {\n            matchedLines.push(cmd ? line : line.text);\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, matchedLines.join('\\n'));\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var line = matchedLines[index++];\n            var lineNum = cm.getLineNumber(line);\n            if (lineNum == null) {\n              nextCommand();\n              return;\n            }\n            var command = (lineNum + 1) + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          if (getOption('pcre') && regexPart !== '') {\n              regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n          }\n          replacePart = tokens[1];\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g,\"$1$$&\"));\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n            }\n            if (getOption('pcre')) {\n               regexPart = regexPart + '/' + flagsPart;\n            } else {\n               regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n            }\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using JavaScript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos, modifiedLineNumber, joined;\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        var unmodifiedLineNumber = searchCursor.to().line;\n        searchCursor.replace(newText);\n        modifiedLineNumber = searchCursor.to().line;\n        lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n        joined = modifiedLineNumber < unmodifiedLineNumber;\n      }\n      function findNextValidMatch() {\n        var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n        var match = searchCursor.findNext();\n        if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n          match = searchCursor.findNext();\n        }\n        return match;\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(findNextValidMatch() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); }\n        return;\n      }\n      showPrompt(cm, {\n        prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!isPlaying) {\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          vimApi.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (lastChange.ignoreCount > 1) {\n            lastChange.ignoreCount--;\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var selectionCount = cm.listSelections().length;\n            if (selectionCount > 1)\n              lastChange.ignoreCount = selectionCount;\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (text) {\n              if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n              } else {\n                lastChange.changes.push(text);\n              }\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n      if (visualBlock) {\n        // Set up block selection again for repeating the changes.\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            cm.replaceSelection(change);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n            cm.setCursor(end);\n          }\n        }\n      }\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    // multiselect support\n    function cloneVimState(state) {\n      var n = new state.constructor();\n      Object.keys(state).forEach(function(key) {\n        var o = state[key];\n        if (Array.isArray(o))\n          o = o.slice();\n        else if (o && typeof o == \"object\" && o.constructor != Object)\n          o = cloneVimState(o);\n        n[key] = o;\n      });\n      if (state.sel) {\n        n.sel = {\n          head: state.sel.head && copyCursor(state.sel.head),\n          anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n        };\n      }\n      return n;\n    }\n    function multiSelectHandleKey(cm, key, origin) {\n      var isHandled = false;\n      var vim = vimApi.maybeInitVimState_(cm);\n      var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n\n      var wasMultiselect = cm.isInMultiSelectMode();\n      if (vim.wasInVisualBlock && !wasMultiselect) {\n        vim.wasInVisualBlock = false;\n      } else if (wasMultiselect && vim.visualBlock) {\n         vim.wasInVisualBlock = true;\n      }\n\n      if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect && vim.status == \"<Esc>\") {\n        // allow editor to exit multiselect\n        clearInputState(cm);\n      } else if (visualBlock || !wasMultiselect || cm.inVirtualSelectionMode) {\n        isHandled = vimApi.handleKey(cm, key, origin);\n      } else {\n        var old = cloneVimState(vim);\n\n        cm.operation(function() {\n          cm.curOp.isVimOp = true;\n          cm.forEachSelection(function() {\n            var head = cm.getCursor(\"head\");\n            var anchor = cm.getCursor(\"anchor\");\n            var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n            var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n            head = offsetCursor(head, 0, headOffset);\n            anchor = offsetCursor(anchor, 0, anchorOffset);\n            cm.state.vim.sel.head = head;\n            cm.state.vim.sel.anchor = anchor;\n\n            isHandled = vimApi.handleKey(cm, key, origin);\n            if (cm.virtualSelection) {\n              cm.state.vim = cloneVimState(old);\n            }\n          });\n          if (cm.curOp.cursorActivity && !isHandled)\n            cm.curOp.cursorActivity = false;\n          cm.state.vim = vim;\n        }, true);\n      }\n      // some commands may bring visualMode and selection out of sync\n      if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n        handleExternalSelection(cm, vim);\n      }\n      return isHandled;\n    }\n    resetVimGlobalState();\n\n  return vimApi;\n}\n\nfunction initVim(CodeMirror5) {\r\n  CodeMirror5.Vim = initVim$1(CodeMirror5);\r\n  return CodeMirror5.Vim;\r\n}\n\n\n\n    CodeMirror.Vim = initVim(CodeMirror);\n  });\n  ","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var trackScope = parserConfig.trackScope !== false\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    return {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C\n    };\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\" && stream.peek() == \"!\") {\n      stream.skipToEnd();\n      return ret(\"meta\", \"meta\");\n    } else if (ch == \"#\" && stream.eatWhile(wordRE)) {\n      return ret(\"variable\", \"property\")\n    } else if (ch == \"<\" && stream.match(\"!--\") ||\n               (ch == \"-\" && stream.match(\"->\") && !/\\S/.test(stream.string.slice(0, stream.start)))) {\n      stream.skipToEnd()\n      return ret(\"comment\", \"comment\")\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n        } else if (/[<>*+\\-|&?]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == \">\") stream.eat(ch)\n        }\n      }\n      if (ch == \"?\" && stream.eat(\".\")) return ret(\".\")\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == \"async\" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n          return ret(\"async\", \"keyword\", word)\n      }\n      return ret(\"variable\", \"variable\", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/`]/.test(ch)) {\n        for (;; --pos) {\n          if (pos == 0) return\n          var next = stream.string.charAt(pos - 1)\n          if (next == ch && stream.string.charAt(pos - 2) != \"\\\\\") { pos--; break }\n        }\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true,\n                     \"regexp\": true, \"this\": true, \"import\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    if (!trackScope) return false\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next) if (v.name == name) return true\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (!trackScope) return\n    if (state.context) {\n      if (state.lexical.info == \"var\" && state.context && state.context.block) {\n        // FIXME function decls are also not block scoped\n        var newContext = registerVarScoped(varname, state.context)\n        if (newContext != null) {\n          state.context = newContext\n          return\n        }\n      } else if (!inList(varname, state.localVars)) {\n        state.localVars = new Var(varname, state.localVars)\n        return\n      }\n    }\n    // Fall through means this is global\n    if (parserConfig.globalVars && !inList(varname, state.globalVars))\n      state.globalVars = new Var(varname, state.globalVars)\n  }\n  function registerVarScoped(varname, context) {\n    if (!context) {\n      return null\n    } else if (context.block) {\n      var inner = registerVarScoped(varname, context.prev)\n      if (!inner) return null\n      if (inner == context.prev) return context\n      return new Context(inner, context.vars, true)\n    } else if (inList(varname, context.vars)) {\n      return context\n    } else {\n      return new Context(context.prev, new Var(varname, context.vars), false)\n    }\n  }\n\n  function isModifier(name) {\n    return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\"\n  }\n\n  // Combinators\n\n  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\n  function Var(name, next) { this.name = name; this.next = next }\n\n  var defaultVars = new Var(\"this\", new Var(\"arguments\", null))\n  function pushcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\n    cx.state.localVars = defaultVars\n  }\n  function pushblockcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\n    cx.state.localVars = null\n  }\n  pushcontext.lex = pushblockcontext.lex = true\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars\n    cx.state.context = cx.state.context.prev\n  }\n  popcontext.lex = true\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\" || type == \"}\" || type == \")\" || type == \"]\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), pushblockcontext, forspec, statement, popcontext, poplex);\n    if (type == \"class\" || (isTS && value == \"interface\")) {\n      cx.marked = \"keyword\"\n      return cont(pushlex(\"form\", type == \"class\" ? type : value), className, poplex)\n    }\n    if (type == \"variable\") {\n      if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n        cx.marked = \"keyword\"\n        if (value == \"enum\") return cont(enumdef);\n        else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\n        else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n      } else if (isTS && value == \"namespace\") {\n        cx.marked = \"keyword\"\n        return cont(pushlex(\"form\"), expression, statement, poplex)\n      } else if (isTS && value == \"abstract\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext,\n                                      block, poplex, poplex, popcontext);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function maybeCatchBinding(type) {\n    if (type == \"(\") return cont(funarg, expect(\")\"))\n  }\n  function expression(type, value) {\n    return expressionInner(type, value, false);\n  }\n  function expressionNoComma(type, value) {\n    return expressionInner(type, value, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, value, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), classExpression, poplex); }\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(maybeexpression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (isTS && value == \"<\" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n        return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(maybeexpression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (isTS && isModifier(value)) {\n      cx.marked = \"keyword\"\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      if (sep && sep.indexOf(\";\") > -1) return pass(what)\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function maybetypeOrIn(type, value) {\n    if (isTS && (type == \":\" || value == \"in\")) return cont(typeexpr)\n  }\n  function mayberettype(type) {\n    if (isTS && type == \":\") {\n      if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\n      else return cont(typeexpr)\n    }\n  }\n  function isKW(_, value) {\n    if (value == \"is\") {\n      cx.marked = \"keyword\"\n      return cont()\n    }\n  }\n  function typeexpr(type, value) {\n    if (value == \"keyof\" || value == \"typeof\" || value == \"infer\" || value == \"readonly\") {\n      cx.marked = \"keyword\"\n      return cont(value == \"typeof\" ? expressionNoComma : typeexpr)\n    }\n    if (type == \"variable\" || value == \"void\") {\n      cx.marked = \"type\"\n      return cont(afterType)\n    }\n    if (value == \"|\" || value == \"&\") return cont(typeexpr)\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n    if (type == \"{\") return cont(pushlex(\"}\"), typeprops, poplex, afterType)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType)\n    if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr)\n    if (type == \"quasi\") { return pass(quasiType, afterType); }\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprops(type) {\n    if (type.match(/[\\}\\)\\]]/)) return cont()\n    if (type == \",\" || type == \";\") return cont(typeprops)\n    return pass(typeprop, typeprops)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\" || type == \"number\" || type == \"string\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    } else if (type == \"[\") {\n      return cont(expect(\"variable\"), maybetypeOrIn, expect(\"]\"), typeprop)\n    } else if (type == \"(\") {\n      return pass(functiondecl, typeprop)\n    } else if (!type.match(/[;\\}\\)\\],]/)) {\n      return cont()\n    }\n  }\n  function quasiType(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasiType);\n    return cont(typeexpr, continueQuasiType);\n  }\n  function continueQuasiType(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasiType);\n    }\n  }\n  function typearg(type, value) {\n    if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg)\n    if (type == \":\") return cont(typeexpr)\n    if (type == \"spread\") return cont(typearg)\n    return pass(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr)\n    if (type == \"[\") return cont(typeexpr, expect(\"]\"), afterType)\n    if (value == \"extends\" || value == \"implements\") { cx.marked = \"keyword\"; return cont(typeexpr) }\n    if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr)\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n  }\n  function typeparam() {\n    return pass(typeexpr, maybeTypeDefault)\n  }\n  function maybeTypeDefault(_, value) {\n    if (value == \"=\") return cont(typeexpr)\n  }\n  function vardef(_, value) {\n    if (value == \"enum\") {cx.marked = \"keyword\"; return cont(enumdef)}\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(pattern) }\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(eltpattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    if (type == \"[\") return cont(expression, expect(']'), expect(':'), proppattern);\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function eltpattern() {\n    return pass(pattern, maybeAssign)\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type, value) {\n    if (value == \"await\") return cont(forspec);\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, forspec2);\n    if (type == \"variable\") return cont(forspec2);\n    return pass(forspec2)\n  }\n  function forspec2(type, value) {\n    if (type == \")\") return cont()\n    if (type == \";\") return cont(forspec2)\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression, forspec2) }\n    return pass(expression, forspec2)\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef)\n  }\n  function functiondecl(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondecl);}\n    if (type == \"variable\") {register(value); return cont(functiondecl);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl)\n  }\n  function typename(type, value) {\n    if (type == \"keyword\" || type == \"variable\") {\n      cx.marked = \"type\"\n      return cont(typename)\n    } else if (value == \"<\") {\n      return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex)\n    }\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg)\n    if (type == \"spread\") return cont(funarg);\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(funarg); }\n    if (isTS && type == \"this\") return cont(maybetype, maybeAssign)\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\")) {\n      if (value == \"implements\") cx.marked = \"keyword\";\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    }\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"async\" ||\n        (type == \"variable\" &&\n         (value == \"static\" || value == \"get\" || value == \"set\" || (isTS && isModifier(value))) &&\n         cx.stream.match(/^\\s+#?[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(classfield, classBody);\n    }\n    if (type == \"number\" || type == \"string\") return cont(classfield, classBody);\n    if (type == \"[\")\n      return cont(expression, maybetype, expect(\"]\"), classfield, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (isTS && type == \"(\") return pass(functiondecl, classBody)\n    if (type == \";\" || type == \",\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"!\") return cont(classfield)\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\"\n    return pass(isInterface ? functiondecl : functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    if (type == \"(\") return pass(expression);\n    if (type == \".\") return pass(maybeoperatorComma);\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function enumdef() {\n    return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex)\n  }\n  function enummember() {\n    return pass(pattern, maybeAssign);\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && new Context(null, null, false),\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse && c != popcontext) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    blockCommentContinue: jsonMode ? null : \" * \",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      parseJS(state, \"atom\", \"atom\", \"true\", new CodeMirror.StringStream(\"\", 2, null))\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/x-json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/manifest+json\", { name: \"javascript\", json: true })\nCodeMirror.defineMIME(\"application/ld+json\", { name: \"javascript\", jsonld: true });\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"yaml\", function() {\n\n  var cons = ['true', 'false', 'on', 'off', 'yes', 'no'];\n  var keywordRegex = new RegExp(\"\\\\b((\"+cons.join(\")|(\")+\"))$\", 'i');\n\n  return {\n    token: function(stream, state) {\n      var ch = stream.peek();\n      var esc = state.escaped;\n      state.escaped = false;\n      /* comments */\n      if (ch == \"#\" && (stream.pos == 0 || /\\s/.test(stream.string.charAt(stream.pos - 1)))) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      if (stream.match(/^('([^']|\\\\.)*'?|\"([^\"]|\\\\.)*\"?)/))\n        return \"string\";\n\n      if (state.literal && stream.indentation() > state.keyCol) {\n        stream.skipToEnd(); return \"string\";\n      } else if (state.literal) { state.literal = false; }\n      if (stream.sol()) {\n        state.keyCol = 0;\n        state.pair = false;\n        state.pairStart = false;\n        /* document start */\n        if(stream.match('---')) { return \"def\"; }\n        /* document end */\n        if (stream.match('...')) { return \"def\"; }\n        /* array list item */\n        if (stream.match(/\\s*-\\s+/)) { return 'meta'; }\n      }\n      /* inline pairs/lists */\n      if (stream.match(/^(\\{|\\}|\\[|\\])/)) {\n        if (ch == '{')\n          state.inlinePairs++;\n        else if (ch == '}')\n          state.inlinePairs--;\n        else if (ch == '[')\n          state.inlineList++;\n        else\n          state.inlineList--;\n        return 'meta';\n      }\n\n      /* list separator */\n      if (state.inlineList > 0 && !esc && ch == ',') {\n        stream.next();\n        return 'meta';\n      }\n      /* pairs separator */\n      if (state.inlinePairs > 0 && !esc && ch == ',') {\n        state.keyCol = 0;\n        state.pair = false;\n        state.pairStart = false;\n        stream.next();\n        return 'meta';\n      }\n\n      /* start of value of a pair */\n      if (state.pairStart) {\n        /* block literals */\n        if (stream.match(/^\\s*(\\||\\>)\\s*/)) { state.literal = true; return 'meta'; };\n        /* references */\n        if (stream.match(/^\\s*(\\&|\\*)[a-z0-9\\._-]+\\b/i)) { return 'variable-2'; }\n        /* numbers */\n        if (state.inlinePairs == 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?$/)) { return 'number'; }\n        if (state.inlinePairs > 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?(?=(,|}))/)) { return 'number'; }\n        /* keywords */\n        if (stream.match(keywordRegex)) { return 'keyword'; }\n      }\n\n      /* pairs (associative arrays) -> key */\n      if (!state.pair && stream.match(/^\\s*(?:[,\\[\\]{}&*!|>'\"%@`][^\\s'\":]|[^\\s,\\[\\]{}#&*!|>'\"%@`])[^#:]*(?=:($|\\s))/)) {\n        state.pair = true;\n        state.keyCol = stream.indentation();\n        return \"atom\";\n      }\n      if (state.pair && stream.match(/^:\\s*/)) { state.pairStart = true; return 'meta'; }\n\n      /* nothing found, continue */\n      state.pairStart = false;\n      state.escaped = (ch == '\\\\');\n      stream.next();\n      return null;\n    },\n    startState: function() {\n      return {\n        pair: false,\n        pairStart: false,\n        keyCol: 0,\n        inlinePairs: 0,\n        inlineList: 0,\n        literal: false,\n        escaped: false\n      };\n    },\n    lineComment: \"#\",\n    fold: \"indent\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-yaml\", \"yaml\");\nCodeMirror.defineMIME(\"text/yaml\", \"yaml\");\n\n});\n","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../@vue/cli-service/node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!../../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!../../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./show-hint.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"0d86fe46\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../@vue/cli-service/node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!../../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!../../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./lint.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"5bf84cf7\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../@vue/cli-service/node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./base16-dark.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"319711f1\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../@vue/cli-service/node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./base16-light.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"09719336\", content, true, {\"sourceMap\":false,\"shadowMode\":false});"],"names":["___CSS_LOADER_EXPORT___","push","module","id","___CSS_LOADER_URL_IMPORT_0___","URL","___CSS_LOADER_URL_IMPORT_1___","___CSS_LOADER_URL_IMPORT_2___","___CSS_LOADER_URL_IMPORT_3___","___CSS_LOADER_URL_IMPORT_4___","___CSS_LOADER_URL_REPLACEMENT_0___","___CSS_LOADER_URL_REPLACEMENT_1___","___CSS_LOADER_URL_REPLACEMENT_2___","___CSS_LOADER_URL_REPLACEMENT_3___","___CSS_LOADER_URL_REPLACEMENT_4___","isLineComment","cm","lineNo","test","getTokenTypeAt","commentIndent","text","getLine","substr","spaceTo","search","out","getOption","lineIndent","match","length","countSpaces","line","i","onCursorActivity","state","markedSelection","operation","update","onChange","clear","start","myIndent","lastLineInFold","end","lastLine","indent","from","to","regex","this","firstLine","e","foldCode","path","elements","index","trimmed","trim","endsWith","name","split","filter","currentPath","map","join","codeMirror","addOverlay","token","stream","string","pos","next","val","old","prev","markedSelectionStyle","reset","on","off","CHUNK_SIZE","Pos","cmp","coverRange","addAt","array","cls","endLine","atEnd","mark","markText","className","undefined","splice","ranges","listSelections","somethingSelected","getCursor","coverStart","find","coverEnd","shift","pop","mod","CodeMirror","dialogDiv","template","bottom","dialog","wrap","getWrapperElement","appendChild","document","createElement","innerHTML","addClass","closeNotification","newVal","currentNotificationClose","defineExtension","callback","options","closed","me","close","inp","value","rmClass","parentNode","removeChild","focus","onClose","button","getElementsByTagName","selectValueOnOpen","select","onInput","onKeyUp","onKeyDown","keyCode","closeOnEnter","blur","e_stop","closeOnBlur","evt","relatedTarget","callbacks","buttons","blurring","b","e_preventDefault","setTimeout","doneTimer","duration","clearTimeout","ie_lt8","navigator","userAgent","documentMode","matching","bracketRegex","config","findMatchingBracket","where","getLineHandle","ch","afterCursor","re","charAt","dir","strict","style","found","scanForBracket","forward","maxScanLen","maxScanLineLength","maxScanLines","stack","lineEnd","Math","min","max","matchBrackets","autoclear","maxHighlightLen","maxHighlightLineLength","highlightNonMatching","marks","empty","head","focused","doMatchBrackets","currentlyHighlighted","clearHighlighted","defineOption","Init","oldConfig","WORD","RANGE","registerHelper","editor","word","range","cur","curLine","curWord","slice","list","seen","RegExp","source","m","exec","lastIndexOf","Object","prototype","hasOwnProperty","call","HINT_ELEMENT_CLASS","ACTIVE_HINT_ELEMENT_CLASS","Completion","widget","debounce","tick","startPos","startLen","getSelection","updateOnCursorActivity","self","activityFunc","cursorActivity","showHint","getHints","async","newOpts","hint","prop","parseOptions","selections","supportsSelection","anchor","completionActive","completion","signal","requestAnimationFrame","window","fn","cancelAnimationFrame","hintOptions","defaultOptions","resolve","getText","buildKeyMap","handle","baseMap","Up","moveFocus","Down","PageUp","menuSize","PageDown","Home","setFocus","End","Enter","pick","Tab","Esc","mac","platform","custom","customKeys","ourMap","addBinding","key","bound","extra","extraKeys","getHintElement","hintsElement","el","nodeName","toUpperCase","Widget","data","floor","random","picked","ownerDocument","getInputField","parentWindow","defaultView","hints","setAttribute","theme","selectedHint","completions","elt","render","createTextNode","displayText","hintId","container","body","cursorCoords","alignWithWord","left","top","below","offsetLeft","offsetTop","isContainerPositioned","indexOf","getComputedStyle","position","offsetParent","offsetParentPosition","getBoundingClientRect","bodyPosition","scrollLeft","scrollTop","winW","innerWidth","offsetWidth","documentElement","winH","innerHeight","offsetHeight","startScroll","box","moveOnOverlap","DOMRect","scrolls","paddingForScrollbar","scrollHeight","clientHeight","getScrollInfo","overlapY","height","spaceAbove","closingOnBlur","overlapX","right","display","nativeBarWidth","width","node","firstChild","nextSibling","paddingRight","addKeyMap","keyMap","n","avoidWrap","changeActive","screenAmount","closeOnUnfocus","onBlur","onFocus","onScroll","curScroll","newTop","point","pageYOffset","t","target","srcElement","completeOnSingleClick","selectedHintRange","getSelectedHintRange","scrollToActive","childNodes","applicableHelpers","helpers","result","fetchHints","then","resolveAutoHints","words","getHelpers","resolved","app","run","getHelper","fromList","anyword","active","replaceRange","scrollIntoView","closeOnPick","identStart","closeCharacters","disable","first","myTick","finishUpdate","completeSingle","removeKeyMap","input","removeAttribute","replace","node1","node2","firstNode","margin","scrollMargin","term","getTokenAt","commands","autocomplete","auto","GUTTER_ID","LINT_LINE_ID","showTooltip","content","tt","clientY","clientX","cloneNode","lint","selfContain","opacity","rm","hideTooltip","showTooltipFor","tooltip","hide","poll","setInterval","nodeType","host","clearInterval","LintState","conf","hasGutter","marked","Function","getAnnotations","linterOptions","defaults","timeout","onMouseOver","waitingFor","highlightLines","tooltips","delay","lintOnChange","formatAnnotation","onUpdateLinting","clearMarks","clearGutter","clearErrorLines","eachLine","has","wrapClass","removeLineClass","makeMarker","labels","severity","multiple","marker","inner","getMaxSeverity","a","groupByLine","annotations","lines","ann","annotationTooltip","tip","messageHTML","message","lintAsync","abort","getValue","arg2","updateLinting","startLinting","issues","annotationsNotSorted","anns","maxSeverity","tipLabel","createDocumentFragment","__annotation","setGutterMarker","addLineClass","popupTooltips","x","y","spans","findMarksAt","coordsChar","gutters","hasLintGutter","jsyaml","console","error","loadAll","loc","column","doFold","noFold","regexpFlags","regexp","flags","ignoreCase","global","multiline","ensureFlags","current","maybeMultiline","searchRegexpForward","doc","last","lastIndex","searchRegexpForwardMultiline","chunk","before","inside","startLine","startCh","lastMatchIn","endMargin","newMatch","searchRegexpBackward","searchRegexpBackwardMultiline","chunkSize","adjustPos","orig","folded","foldFunc","mid","len","searchStringForward","query","caseFold","fold","cutFrom","endString","searchStringBackward","topString","SearchCursor","atOccurrence","afterEmptyMatch","clipPos","matches","reverse","String","normalize","str","toLowerCase","findNext","findPrevious","cmpPos","newText","origin","splitLines","defineDocExtension","getSearchCursor","setSelections","cmds","posEq","killRing","addToRing","growRingTop","getFromRing","popFromRing","lastKill","_kill","ring","getRange","isClean","gen","changeGeneration","byChar","findPosH","byWord","byLine","findPosV","sel","goalColumn","byPage","byParagraph","no","sawText","fst","lst","hasText","bySentence","sawWord","byExpr","after","newPos","getPrefix","precise","digits","emacsPrefix","clearPrefix","Number","repeated","cmd","f","execCommand","prefix","findEnd","by","move","extendSelection","motion","killTo","cursor","_killRegion","selection","addPrefix","digit","maybeClearPrefix","maybeDuplicateInput","prefixPreservingKeys","arg","emacsPrefixMap","event","dup","one","txt","replaceSelection","maybeRemovePrefixMap","prefixMap","clearMark","setExtending","setCursor","makePrompt","msg","fragment","getInput","openDialog","prompt","operateOnWord","op","toEnclosingExpr","setMark","getExtending","killRegion","killLineEmacs","killRingSave","yank","setSelection","yankPop","forwardChar","backwardChar","deleteChar","deleteForwardChar","deleteBackwardChar","forwardWord","backwardWord","killWord","backwardKillWord","nextLine","previousLine","scrollDownCommand","scrollUpCommand","backwardParagraph","forwardParagraph","backwardSentence","forwardSentence","killSentence","backwardKillSentence","killSexp","backwardKillSexp","forwardSexp","backwardSexp","markSexp","transposeSexps","leftStart","leftEnd","rightEnd","rightStart","backwardUpList","justOneSpace","openLine","transposeCharsRepeatable","capitalizeWord","w","letter","upcaseWord","downcaseWord","undoRepeatable","keyboardQuit","newline","gotoLine","num","isNaN","indentRigidly","indentSelection","exchangePointAndMark","quotedInsertTab","universalArgument","emacs","kill","normalizeKeyMap","regPrefix","d","findPosSubword","type","cat","isWordChar","moveSubword","extendSelectionsBy","extend","insertLine","above","isReadOnly","Pass","newSelection","at","indentLine","wordAt","addCursorToSelection","newRanges","newAnchor","newHead","newRange","isSelectedRange","goSubwordLeft","goSubwordRight","scrollLineUp","info","visibleBottomLine","lineAtHeight","scrollTo","defaultTextHeight","scrollLineDown","visibleTopLine","splitSelectionByLine","lineRanges","singleSelectionTop","scroll","selectLine","extended","insertLineAfter","insertLineBefore","selectNextOccurrence","fullWord","sublimeFindFullWord","addSelection","skipAndSelectNextOccurrence","prevAnchor","prevHead","addCursorToPrevLine","addCursorToNextLine","mirror","selectBetweenBrackets","opening","closing","puncType","sortLines","caseSensitive","direction","selected","toSort","sort","au","bu","modifyWordOrSelection","indices","replacements","replaceSelections","getTarget","findAndGoTo","selectScope","goToBracket","swapLineUp","linesToMove","newSels","swapLineDown","toggleCommentIndented","toggleComment","joinLines","joined","offset","obj","actual","duplicateLine","rangeCount","reverseSortLines","sortLinesInsensitive","reverseSortLinesInsensitive","nextBookmark","sublimeBookmarks","prevBookmark","unshift","toggleBookmark","findMarks","j","sublimeBookmark","k","clearWhenEmpty","clearBookmarks","selectBookmarks","smartBackspace","cursors","indentUnit","toStartOfLine","countColumn","deletePos","prevIndent","findColumn","delLineRight","upcaseAtCursor","downcaseAtCursor","setSublimeMark","sublimeMark","setBookmark","selectToSublimeMark","deleteToSublimeMark","tmp","sublimeKilled","swapWithSublimeMark","sublimeYank","showInCenter","findUnder","findUnderPrevious","findAllUnder","primaryIndex","macSublime","pcSublime","default","macDefault","sublime","initVim$1","transformCursor","vim","insertMode","visualBlock","defaultKeymap","keys","toKeys","context","action","motionArgs","linewise","toJumplist","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","keepSpaces","fullLine","exitVisualBlock","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultKeymapLength","defaultExCommandMap","shortName","possiblyAsync","excludeFromCommandHistory","enterVimMode","setOption","mode","maybeInitVimState","getOnPasteFn","leaveVimMode","highlightTimeout","detachVimMap","$customCursor","attach","attachVimMap","curOp","selectionChanged","cmKey","vimKey","cmKeyToVimKey","vimApi","findKey","modifiers","Shift","Ctrl","Alt","Cmd","Mod","CapsLock","specialKeys","Backspace","Delete","Insert","pieces","lastPiece","hasCharacter","piece","isUpperCase","onPasteFn","offsetCursor","actions","enterInsertMode","numberRegex","wordCharTest","bigWordCharTest","makeKeyRange","size","fromCharCode","upperCaseChars","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","_","isLine","isLowerCase","isMatchableSymbol","isNumber","isWhiteSpaceString","isEndOfSentenceSymbol","inArray","arr","defaultValue","aliases","Error","cfg","option","scope","local","vimGlobalState","lastInsertModeKeyTimer","createCircularJumpList","pointer","tail","buffer","Array","add","oldCur","newCur","curMark","useNextSlot","trashMark","markPos","cursorEqual","inc","oldPointer","cachedCursor","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","insertModeRepeat","visualMode","lastSelection","lastPastedText","resetVimGlobalState","optionName","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","macroModeState","lastCharacterSearch","increment","selectedCharacter","registerController","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","exitMacroRecordMode","enterMacroRecordMode","registerName","register","getRegister","dom","class","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","lhs","rhs","ctx","exCommandDispatcher","unmap","noremap","toCtxArray","ctxsToMap","actualLength","origLength","mapping","newMapping","_mapCommand","mappedCtxs","mapclear","userKeymap","contexts","defineEx","func","exCommands","commandMap_","handleKey","command","multiSelectHandleKey","handleMacroRecording","clearInputState","logKey","handleEsc","exitVisualMode","exitInsertMode","doKeyToKey","substring","handleKeyInsertMode","keyBuffer","keysAreChars","commandDispatcher","matchCommand","thisMatch","here","handleKeyNonInsertMode","keysMatcher","mainKey","operatorShortcut","pushRepeatDigit","isVimOp","processCommand","handleEx","defineMotion","defineAction","defineOperator","mapCommand","defineRegister","prefixRepeat","motionRepeat","reason","Register","insertModeChanges","searchQueries","registers","unnamedRegister","historyBuffer","iterator","initialPrefix","getRepeat","repeat","parseInt","setText","pushText","pushInsertModeChanges","pushSearchQuery","toString","isValidRegister","append","shiftNumericRegisters_","nextMatch","up","element","pushInput","bestMatch","commandMatches","full","partial","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","updateCmSelection","repeatIsExplicit","recordLastEdit","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","handleQuery","showPrompt","onPromptClose","desc","onPromptKeyUp","onPromptKeyDown","expandWordUnderCursor","isKeyword","escapeRegex","smartCase","updateSearchQuery","showConfirm","logSearchQuery","parsedQuery","keyName","selectionEnd","selectionStart","clearSearchHighlight","exArgs","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","noRepeat","motionResult","motions","recordJumpPosition","Infinity","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","curStart","curEnd","cmSel","cursorMin","cursorMax","makeCmSelection","lineLength","expandSelectionToLine","clipToLine","exclusive","primary","operatorMoveTo","operators","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","moveToBottomLine","expandToLine","_cm","isReversed","highlightSearchMatches","findAndSelectNextInclusive","prevInputState","findNextFromAndToInclusive","subMode","goToMark","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","cursorIsBetween","moveByCharacters","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","posV","hasMarkedText","moveToStartOfLine","charCoords","res","hitSide","lastCharCoords","goalCoords","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","findSentence","scrollbox","dest","moveByWords","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","findSymbol","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","symbol","lineText","matched","moveToLineOrEdgeOfDocument","lineNum","moveToStartOfDisplayLine","moveToEndOfDisplayLine","sticky","textObjectManipulation","mirroredPairs","selfPaired","selectCompanionObject","findBeginningAndEnd","expandTagUnderCursor","getSentence","expandSelection","repeatLastCharacterSearch","lastSearch","moveH","fillArray","times","change","args","finalHead","MAX_VALUE","replacement","lastState","prevLineEnd","wasLastLine","newlineAndIndent","indentMore","indentLess","indentAuto","_args","changeCase","getSelections","swapped","toSwap","endPos","jumpListWalk","lineHeight","delta","ceil","newBottom","scrollToCursor","lineLastCharPos","lineLastCharCoords","replayMacro","executeMacroRegister","toggleOverwrite","overwrite","getLastEditPos","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineFn","newlineAndIndentContinueComment","paste","tabSize","whitespaceLength","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","idx","lastSelectionCurEnd","selectedArea","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","posFromIndex","indexFromPos","lastCh","extendLineToColumn","undo","repeatFn","redo","setRegister","markName","replaceTo","replaceWith","replaceWithStr","incrementNumberToken","numberStr","lineStr","baseStr","base","number","zeroPadding","repeatLastEdit","includeLineBreak","maxCh","ret","offsetLine","offsetCh","commandMatch","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","arguments","apply","cur3","cur1before2","cur2before3","s","isClipped","curHead","primIndex","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","atAnchor","atHead","getCurrentSelectedAreaRange","getLastSelectedAreaRange","block","headOffset","anchorOffset","fromCh","toCh","getHead","moveHead","firstNonWS","_forward","noSymbol","wordStart","findMatchingTag","findEnclosingTag","tags","open","symbolToMode","findSymbolModes","bracket","isComplete","nextCh","symb","depth","reverseSymb","section","init","curMoveThrough","comment","method","preprocess","lineCount","curCh","lineLen","findWord","emptyLineIsWord","charTests","stop","foundWord","eodCh","shortCircuit","firstWord","lastWord","keepHPos","retval","charIdxInLine","includeChar","isEmpty","isBoundary","any","startState","nextChar","curr","ln","lastSentencePos","curr_index","last_valid","skip_empty_lines","bracketRegexp","openSym","curChar","chars","firstIndex","SearchState","searchState_","splitBySlash","argString","splitBySeparator","findUnescapedSlashes","findUnescapedSeparators","separator","slashes","tokens","escapeNextChar","translateRegex","specials","unescape","specialComesNext","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","charUnescapes","translateRegexReplace","unescapes","unescapeRegexReplace","StringStream","output","eol","peek","matcher","parseQuery","lastSearchRegister","regexPart","forceIgnoreCase","flagsPart","pre","$color","$whiteSpace","openNotification","alert","innerText","$fontFamily","autocorrect","autocapitalize","spellcheck","shortText","textContent","regexEqual","r1","r2","props","rawQuery","matchSol","sol","backUp","skipToEnd","searchState","removeOverlay","showMatchesOnScrollbar","lastEndPos","isInRange","scrollInfo","occludeToleranceTop","occludeToleranceBottom","bottomY","done","history","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","commandName","params","parseInput_","matchCommand_","parseCommandArgs_","toInput","eatWhile","eat","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","setOptionReturn","setlocal","setglobal","regArgs","regInfo","unique","pattern","parseArgs","eatSpace","opts","decimal","hex","octal","err","lineStart","radix","numPart","textPart","matchPart","comparePatternFn","compareFn","textOld","anum","bnum","vglobal","inverted","matchedLines","nextCommand","getLineNumber","substitute","trailing","count","replacePart","confirm","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","searchCursor","exMode","lastPos","modifiedLineNumber","replaceAll","unmodifiedLineNumber","findNextValidMatch","lastMatchTo","_value","savedCallback","insertModeChangeRegister","lastChange","logInsertModeChange","imc","repeatInsertModeChanges","changeObj","ignoreCount","selectionCount","maybeReset","handleExternalSelection","onKeyFound","lookupKey","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding","cloneVimState","constructor","forEach","o","isArray","isHandled","wasInVisualBlock","wasMultiselect","isInMultiSelectMode","status","inVirtualSelectionMode","forEachSelection","virtualSelection","insert","detach","fallthrough","initVim","CodeMirror5","Vim","defineMode","parserConfig","statementIndent","jsonldMode","jsonld","jsonMode","json","trackScope","isTS","typescript","wordRE","wordCharacters","keywords","kw","A","B","C","D","atom","isOperatorChar","isJsonldKeyword","readRegexp","escaped","inSet","tp","cont","tokenBase","tokenize","tokenString","tokenComment","expressionAllowed","tokenQuasi","lexical","lastType","propertyIsEnumerable","quote","maybeEnd","brackets","findFatArrow","fatArrowAt","arrow","sawSomething","atomicTypes","JSLexical","indented","align","inScope","varname","v","localVars","cx","vars","parseJS","cc","combinator","expression","statement","lex","pass","inList","newContext","registerVarScoped","Var","globalVars","Context","isModifier","defaultVars","pushcontext","pushblockcontext","popcontext","pushlex","outer","poplex","expect","wanted","exp","vardef","parenExpr","maybeexpression","maybeelse","functiondef","forspec","enumdef","typename","typeexpr","maybelabel","maybeCatchBinding","afterExport","afterImport","funarg","expressionInner","expressionNoComma","noComma","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","classExpression","arrayLiteral","contCommasep","objprop","quasi","maybeTarget","property","continueQuasi","targetNoComma","maybeTypeArgs","getterSetter","afterprop","maybetype","what","sep","proceed","maybetypeOrIn","mayberettype","isKW","afterType","typeprops","typearg","maybeReturnType","quasiType","typeprop","functiondecl","continueQuasiType","typeparam","maybeTypeDefault","maybeAssign","vardefCont","eltpattern","proppattern","_type","forspec1","forspec2","classNameAfter","classBody","classfield","isInterface","maybeFrom","exportField","importSpec","maybeMoreImports","maybeAs","enummember","isContinuedStatement","textAfter","basecolumn","indentation","firstChar","doubleIndentSwitch","electricInput","blockCommentStart","blockCommentEnd","blockCommentContinue","lineComment","closeBrackets","helperType","skipExpression","defineMIME","cons","keywordRegex","esc","literal","keyCol","pair","pairStart","inlinePairs","inlineList","__esModule","locals","exports"],"sourceRoot":""}