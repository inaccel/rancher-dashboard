{"version":3,"sources":["webpack:///./node_modules/codemirror/theme/base16-dark.css","webpack:///./node_modules/codemirror/addon/lint/lint.css?ed68","webpack:///./node_modules/codemirror/theme/base16-light.css","webpack:///./node_modules/codemirror/addon/dialog/dialog.js","webpack:///./node_modules/codemirror/addon/lint/lint.css","webpack:///./node_modules/codemirror/keymap/emacs.js","webpack:///./node_modules/codemirror/addon/fold/foldcode.js","webpack:///./node_modules/codemirror/addon/fold/foldgutter.css?e73e","webpack:///./node_modules/codemirror/keymap/vim.js","webpack:///./node_modules/codemirror/addon/hint/anyword-hint.js","webpack:///./node_modules/codemirror/addon/lint/lint.js","webpack:///./node_modules/codemirror/theme/base16-dark.css?5581","webpack:///./node_modules/codemirror/addon/edit/matchbrackets.js","webpack:///./node_modules/codemirror/addon/hint/show-hint.css","webpack:///./node_modules/codemirror/keymap/sublime.js","webpack:///./node_modules/codemirror/addon/hint/show-hint.js","webpack:///./node_modules/codemirror/lib/codemirror.css?2ee2","webpack:///./node_modules/codemirror/addon/lint/yaml-lint.js","webpack:///./node_modules/codemirror/addon/search/searchcursor.js","webpack:///./node_modules/codemirror/addon/fold/foldgutter.js","webpack:///./node_modules/codemirror/theme/base16-light.css?c284","webpack:///./node_modules/codemirror/mode/yaml/yaml.js","webpack:///./node_modules/codemirror/lib/codemirror.css","webpack:///./shell/plugins/codemirror.js","webpack:///./node_modules/codemirror/addon/hint/show-hint.css?6cef","webpack:///./node_modules/codemirror/addon/fold/foldgutter.css","webpack:///./node_modules/codemirror/mode/javascript/javascript.js"],"names":["___CSS_LOADER_API_IMPORT___","exports","push","module","i","content","__esModule","default","locals","add","mod","CodeMirror","dialogDiv","cm","template","bottom","dialog","wrap","getWrapperElement","appendChild","document","createElement","className","innerHTML","addClass","closeNotification","newVal","state","currentNotificationClose","defineExtension","callback","options","this","closed","me","close","inp","value","rmClass","parentNode","removeChild","focus","onClose","button","getElementsByTagName","selectValueOnOpen","select","onInput","on","e","onKeyUp","onKeyDown","keyCode","closeOnEnter","blur","e_stop","closeOnBlur","evt","relatedTarget","callbacks","buttons","blurring","length","b","e_preventDefault","setTimeout","doneTimer","duration","clearTimeout","cmds","commands","Pos","posEq","a","line","ch","killRing","addToRing","str","shift","growRingTop","getFromRing","n","Math","min","popFromRing","pop","lastKill","_kill","from","to","ring","text","getRange","pos","isClean","gen","replaceRange","changeGeneration","byChar","dir","findPosH","byWord","byLine","findPosV","doc","sel","goalColumn","byPage","byParagraph","no","getLine","sawText","test","slice","fst","firstLine","lst","lastLine","clipPos","hasText","bySentence","sawWord","next","charAt","byExpr","findMatchingBracket","strict","match","forward","first","token","getTokenAt","after","start","end","string","newPos","getPrefix","precise","digits","emacsPrefix","clearPrefix","Number","repeated","cmd","f","execCommand","prefix","findEnd","by","move","extendSelection","getCursor","motion","killTo","cursor","selections","listSelections","head","_killRegion","somethingSelected","selection","anchor","addPrefix","digit","maybeClearPrefix","maybeDuplicateInput","prefixPreservingKeys","arg","emacsPrefixMap","hasOwnProperty","off","event","dup","origin","one","join","txt","replaceSelection","maybeRemovePrefixMap","removeKeyMap","prefixMap","clearMark","setExtending","setCursor","makePrompt","msg","fragment","createDocumentFragment","input","setAttribute","style","width","createTextNode","getInput","openDialog","prompt","operateOnWord","op","toEnclosingExpr","stack","setMark","getExtending","killRegion","killLineEmacs","killRingSave","getSelection","yank","setSelection","yankPop","forwardChar","backwardChar","deleteChar","deleteForwardChar","deleteBackwardChar","forwardWord","backwardWord","killWord","backwardKillWord","nextLine","previousLine","scrollDownCommand","scrollUpCommand","backwardParagraph","forwardParagraph","backwardSentence","forwardSentence","killSentence","backwardKillSentence","killSexp","backwardKillSexp","forwardSexp","backwardSexp","markSexp","transposeSexps","leftStart","leftEnd","rightEnd","rightStart","backwardUpList","justOneSpace","openLine","transposeCharsRepeatable","capitalizeWord","w","letter","search","toUpperCase","toLowerCase","upcaseWord","downcaseWord","undoRepeatable","keyboardQuit","newline","gotoLine","num","isNaN","indentRigidly","indentSelection","getOption","exchangePointAndMark","quotedInsertTab","universalArgument","addKeyMap","emacs","kill","keyMap","normalizeKeyMap","regPrefix","d","String","doFold","force","call","finder","minSize","allowFolded","range","marks","findMarksAt","__isFold","cleared","clear","myWidget","makeWidget","myRange","markText","replacedWith","clearOnEnter","signal","widget","cloneNode","newFoldFunction","rangeFinder","toggleFold","foldCode","fold","unfold","scanUp","foldAll","operation","unfoldAll","registerHelper","funcs","Array","prototype","arguments","found","helpers","getHelpers","cur","defaultOptions","auto","minFoldSize","name","undefined","editorOptions","foldOptions","defineOption","initVim$1","transformCursor","vim","insertMode","visualBlock","empty","defaultKeymap","keys","type","toKeys","context","action","motionArgs","linewise","toJumplist","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","keepSpaces","replace","fullLine","exitVisualBlock","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultKeymapLength","defaultExCommandMap","shortName","possiblyAsync","excludeFromCommandHistory","enterVimMode","setOption","mode","onCursorActivity","maybeInitVimState","getInputField","getOnPasteFn","leaveVimMode","highlightTimeout","detachVimMap","$customCursor","attach","attachVimMap","prev","curOp","selectionChanged","cmKey","key","vimKey","cmKeyToVimKey","vimApi","findKey","val","Init","modifiers","Shift","Ctrl","Alt","Cmd","Mod","CapsLock","specialKeys","Enter","Backspace","Delete","Insert","pieces","split","lastPiece","hasCharacter","piece","isUpperCase","onPasteFn","offsetCursor","actions","enterInsertMode","numberRegex","wordCharTest","isWordChar","bigWordCharTest","makeKeyRange","size","fromCharCode","upperCaseChars","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","RegExp","_","isLine","isLowerCase","k","isMatchableSymbol","indexOf","isNumber","isWhiteSpaceString","isEndOfSentenceSymbol","inArray","arr","defaultValue","aliases","Error","cfg","option","scope","local","vimGlobalState","lastInsertModeKeyTimer","createCircularJumpList","pointer","tail","buffer","oldCur","newCur","current","curMark","useNextSlot","trashMark","setBookmark","markPos","find","cursorEqual","offset","mark","inc","oldPointer","cachedCursor","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","insertModeRepeat","visualMode","lastSelection","lastPastedText","resetVimGlobalState","optionName","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","macroModeState","lastCharacterSearch","increment","selectedCharacter","registerController","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","exitMacroRecordMode","enterMacroRecordMode","registerName","register","getRegister","dom","class","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","map","lhs","rhs","ctx","exCommandDispatcher","unmap","noremap","toCtxArray","ctxsToMap","actualLength","origLength","mapping","substr","newMapping","_mapCommand","mappedCtxs","filter","el","mapclear","userKeymap","contexts","j","defineEx","func","exCommands","commandMap_","handleKey","command","multiSelectHandleKey","handleMacroRecording","clearInputState","logKey","handleEsc","exitVisualMode","exitInsertMode","doKeyToKey","exec","substring","index","handleKeyInsertMode","keyBuffer","keysAreChars","commandDispatcher","matchCommand","thisMatch","window","here","handleKeyNonInsertMode","keysMatcher","mainKey","operatorShortcut","pushRepeatDigit","isVimOp","processCommand","console","handleEx","defineMotion","defineAction","defineOperator","mapCommand","defineRegister","prefixRepeat","motionRepeat","reason","Register","insertModeChanges","searchQueries","registers","unnamedRegister","historyBuffer","iterator","initialPrefix","getRepeat","repeat","parseInt","setText","pushText","pushInsertModeChanges","pushSearchQuery","query","toString","isValidRegister","append","shiftNumericRegisters_","nextMatch","up","element","pushInput","splice","reset","bestMatch","matches","commandMatches","full","partial","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","updateCmSelection","repeatIsExplicit","recordLastEdit","getSearchCursor","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","getScrollInfo","handleQuery","showPrompt","onPromptClose","desc","onPromptKeyUp","onPromptKeyDown","word","expandWordUnderCursor","isKeyword","escapeRegex","ignoreCase","smartCase","updateSearchQuery","showConfirm","scrollTo","left","top","logSearchQuery","parsedQuery","keyName","target","selectionEnd","selectionStart","scrollIntoView","findNext","clearSearchHighlight","exArgs","newHead","newAnchor","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","noRepeat","motionResult","motions","recordJumpPosition","Infinity","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","curStart","curEnd","cmSel","cursorMin","cursorMax","makeCmSelection","ranges","lineLength","tmp","expandSelectionToLine","clipToLine","exclusive","setSelections","primary","operatorMoveTo","operators","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","floor","moveToBottomLine","expandToLine","_cm","isReversed","highlightSearchMatches","findAndSelectNextInclusive","prevInputState","findNextFromAndToInclusive","subMode","goToMark","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","cursorIsBetween","moveByCharacters","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","last","posV","hasMarkedText","moveToStartOfLine","charCoords","res","hitSide","lastCharCoords","goalCoords","coordsChar","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","findSentence","scrollbox","clientHeight","defaultTextHeight","orig","dest","moveByWords","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","findSymbol","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","symbol","lineText","getTokenTypeAt","re","matched","bracketRegex","moveToLineOrEdgeOfDocument","lineNum","moveToStartOfDisplayLine","moveToEndOfDisplayLine","sticky","textObjectManipulation","mirroredPairs","selfPaired","'","selectCompanionObject","findBeginningAndEnd","expandTagUnderCursor","getSentence","expandSelection","repeatLastCharacterSearch","lastSearch","moveH","fn","fillArray","times","change","args","finalHead","MAX_VALUE","replacement","replaceSelections","lastState","prevLineEnd","wasLastLine","newlineAndIndent","indent","indentMore","indentLess","startLine","endLine","indentLine","indentAuto","_args","changeCase","getSelections","swapped","toSwap","endPos","jumpListWalk","scroll","lineHeight","delta","cursorCoords","ceil","newBottom","scrollToCursor","height","y","lineLastCharPos","lineLastCharCoords","replayMacro","executeMacroRegister","toggleOverwrite","overwrite","max","getLastEditPos","onChange","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineFn","newlineAndIndentContinueComment","paste","tabSize","whitespaceLength","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","idx","lastSelectionCurEnd","selectedArea","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","posFromIndex","indexFromPos","lastCh","extendLineToColumn","undo","repeatFn","redo","setRegister","markName","replaceTo","replaceWith","replaceWithStr","incrementNumberToken","numberStr","lineStr","baseStr","base","number","zeroPadding","repeatLastEdit","includeLineBreak","maxCh","ret","prop","offsetLine","offsetCh","commandMatch","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","apply","cur3","cur1before2","cur2before3","trim","s","column","isClipped","curHead","primIndex","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","atAnchor","atHead","getCurrentSelectedAreaRange","getLastSelectedAreaRange","block","headOffset","anchorOffset","fromCh","toCh","getHead","moveHead","lines","firstNonWS","_forward","noSymbol","wordStart","findMatchingTag","findEnclosingTag","tags","open","symbolToMode","findSymbolModes","bracket","isComplete","nextCh","symb","depth","reverseSymb","section","init","curMoveThrough","comment","method","preprocess","lineCount","curCh","lineLen","findWord","emptyLineIsWord","charTests","stop","foundWord","words","eodCh","shortCircuit","firstWord","lastWord","keepHPos","retval","charIdxInLine","includeChar","lastIndexOf","isEmpty","isBoundary","any","startState","nextChar","curr","ln","lastSentencePos","reverse","curr_index","last_valid","skip_empty_lines","bracketRegexp","openSym","curChar","scanForBracket","len","chars","firstIndex","SearchState","searchState_","splitBySlash","argString","splitBySeparator","findUnescapedSlashes","findUnescapedSeparators","separator","slashes","tokens","escapeNextChar","translateRegex","specials","unescape","out","specialComesNext","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","charUnescapes","translateRegexReplace","unescapes","unescapeRegexReplace","stream","StringStream","output","eol","peek","matcher","parseQuery","lastSearchRegister","regexPart","forceIgnoreCase","flagsPart","regexp","nodeType","Object","pre","$color","$whiteSpace","openNotification","alert","innerText","$fontFamily","autocorrect","autocapitalize","spellcheck","shortText","textContent","regexEqual","r1","r2","props","rawQuery","source","matchSol","sol","backUp","skipToEnd","searchState","removeOverlay","addOverlay","showMatchesOnScrollbar","lastEndPos","isInRange","scrollInfo","occludeToleranceTop","occludeToleranceBottom","bottomY","done","history","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","commandName","params","parseInput_","matchCommand_","parseCommandArgs_","toInput","result","eatWhile","eat","lineEnd","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","unshift","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","sort","unique","pattern","parseArgs","eatSpace","opts","decimal","hex","octal","err","lineStart","radix","numPart","textPart","matchPart","comparePatternFn","compareFn","textOld","anum","bnum","vglobal","global","inverted","matchedLines","getLineHandle","nextCommand","getLineNumber","substitute","trailing","count","replacePart","confirm","startPos","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","searchCursor","exMode","lastPos","modifiedLineNumber","joined","replaceAll","newText","unmodifiedLineNumber","findNextValidMatch","lastMatchTo","_value","savedCallback","insertModeChangeRegister","lastChange","logInsertModeChange","extra","imc","repeatInsertModeChanges","changeObj","ignoreCount","selectionCount","maybeReset","handleExternalSelection","onKeyFound","lookupKey","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding","cloneVimState","constructor","forEach","o","isArray","isHandled","wasInVisualBlock","wasMultiselect","isInMultiSelectMode","status","inVirtualSelectionMode","old","forEachSelection","virtualSelection","cursorActivity","insert","detach","fallthrough","initVim","CodeMirror5","Vim","WORD","RANGE","editor","curLine","curWord","list","seen","m","GUTTER_ID","LINT_LINE_ID","showTooltip","tt","clientY","offsetHeight","clientX","theme","lint","selfContain","body","opacity","rm","elt","hideTooltip","showTooltipFor","node","tooltip","hide","poll","setInterval","host","clearInterval","LintState","conf","hasGutter","marked","Function","getAnnotations","linterOptions","defaults","timeout","onMouseOver","waitingFor","highlightLines","tooltips","delay","lintOnChange","async","formatAnnotation","onUpdateLinting","clearMarks","clearGutter","clearErrorLines","eachLine","has","wrapClass","removeLineClass","makeMarker","labels","severity","multiple","marker","inner","getMaxSeverity","groupByLine","annotations","ann","annotationTooltip","tip","messageHTML","lintAsync","id","abort","getValue","arg2","updateLinting","startLinting","getHelper","then","issues","annotationsNotSorted","anns","item","maxSeverity","tipLabel","__annotation","setGutterMarker","addLineClass","popupTooltips","srcElement","box","getBoundingClientRect","x","right","spans","gutters","hasLintGutter","ie_lt8","navigator","userAgent","documentMode","matching","config","where","afterCursor","maxScanLen","maxScanLineLength","maxScanLines","lineNo","matchBrackets","autoclear","maxHighlightLen","maxHighlightLineLength","highlightNonMatching","focused","doMatchBrackets","currentlyHighlighted","clearHighlighted","oldConfig","findPosSubword","cat","moveSubword","extendSelectionsBy","display","extend","insertLine","above","isReadOnly","Pass","newSelection","at","wordAt","addCursorToSelection","newRanges","newRange","isSelectedRange","cmpPos","goSubwordLeft","goSubwordRight","scrollLineUp","info","visibleBottomLine","lineAtHeight","scrollLineDown","visibleTopLine","splitSelectionByLine","lineRanges","singleSelectionTop","selectLine","extended","insertLineAfter","insertLineBefore","selectNextOccurrence","fullWord","sublimeFindFullWord","addSelection","skipAndSelectNextOccurrence","prevAnchor","prevHead","addCursorToPrevLine","addCursorToNextLine","mirror","selectBetweenBrackets","opening","closing","puncType","sortLines","caseSensitive","direction","selected","toSort","au","bu","modifyWordOrSelection","indices","replacements","getTarget","findAndGoTo","findPrevious","selectScope","goToBracket","swapLineUp","linesToMove","newSels","swapLineDown","toggleCommentIndented","toggleComment","obj","actual","duplicateLine","rangeCount","reverseSortLines","sortLinesInsensitive","reverseSortLinesInsensitive","nextBookmark","sublimeBookmarks","prevBookmark","toggleBookmark","findMarks","sublimeBookmark","clearWhenEmpty","clearBookmarks","selectBookmarks","smartBackspace","cursors","indentUnit","toStartOfLine","countColumn","deletePos","prevIndent","findColumn","delLineRight","upcaseAtCursor","downcaseAtCursor","setSublimeMark","sublimeMark","selectToSublimeMark","deleteToSublimeMark","sublimeKilled","swapWithSublimeMark","sublimeYank","showInCenter","findUnder","findUnderPrevious","findAllUnder","primaryIndex","macSublime","pcSublime","mac","macDefault","sublime","HINT_ELEMENT_CLASS","ACTIVE_HINT_ELEMENT_CLASS","Completion","debounce","tick","startLen","updateOnCursorActivity","self","activityFunc","showHint","getHints","newOpts","hint","parseOptions","supportsSelection","completionActive","completion","update","requestAnimationFrame","cancelAnimationFrame","hintOptions","resolve","getText","handle","baseMap","Up","moveFocus","Down","PageUp","menuSize","PageDown","Home","setFocus","End","pick","Tab","Esc","platform","custom","customKeys","ourMap","addBinding","bound","extraKeys","getHintElement","hintsElement","nodeName","Widget","data","random","picked","ownerDocument","parentWindow","defaultView","hints","selectedHint","completions","render","displayText","hintId","container","alignWithWord","below","offsetLeft","offsetTop","isContainerPositioned","getComputedStyle","offsetParent","offsetParentPosition","bodyPosition","scrollLeft","scrollTop","winW","innerWidth","offsetWidth","documentElement","winH","innerHeight","startScroll","moveOnOverlap","DOMRect","scrolls","paddingForScrollbar","scrollHeight","overlapY","spaceAbove","closingOnBlur","overlapX","nativeBarWidth","firstChild","nextSibling","paddingRight","avoidWrap","changeActive","screenAmount","closeOnUnfocus","onBlur","onFocus","onScroll","curScroll","newTop","point","pageYOffset","t","completeOnSingleClick","selectedHintRange","getSelectedHintRange","scrollToActive","childNodes","applicableHelpers","fetchHints","resolveAutoHints","resolved","app","run","fromList","anyword","active","closeOnPick","identStart","closeCharacters","disable","myTick","finishUpdate","completeSingle","removeAttribute","node1","node2","firstNode","margin","scrollMargin","term","autocomplete","jsyaml","error","loadAll","loc","noFold","regexpFlags","flags","multiline","ensureFlags","maybeMultiline","searchRegexpForward","lastIndex","searchRegexpForwardMultiline","chunk","before","inside","startCh","lastMatchIn","endMargin","newMatch","searchRegexpBackward","searchRegexpBackwardMultiline","chunkSize","adjustPos","folded","foldFunc","mid","searchStringForward","caseFold","cutFrom","endString","searchStringBackward","topString","SearchCursor","atOccurrence","afterEmptyMatch","normalize","splitLines","defineDocExtension","foldGutter","gutter","onGutterClick","onViewportChange","onFold","optionChange","State","updateInViewport","indicatorOpen","indicatorFolded","isFolded","fromPos","spec","updateFoldInfo","foldOption","clsFolded","classTest","clsOpen","gutterMarkers","cls","vp","getViewport","changeUpdate","foldOnChangeTimeSpan","updateViewportTimeSpan","defineMode","cons","keywordRegex","esc","escaped","literal","indentation","keyCol","pair","pairStart","inlinePairs","inlineList","lineComment","defineMIME","isLineComment","commentIndent","spaceTo","lineIndent","strPad","countSpaces","markedSelection","myIndent","lastLineInFold","regex","_this","path","_this2","elements","_loop","trimmed","endsWith","currentPath","codeMirror","markedSelectionStyle","CHUNK_SIZE","cmp","coverRange","addAt","array","atEnd","coverStart","coverEnd","parserConfig","statementIndent","jsonldMode","jsonld","jsonMode","json","trackScope","isTS","typescript","wordRE","wordCharacters","keywords","kw","A","B","C","D","atom","isOperatorChar","isJsonldKeyword","readRegexp","inSet","tp","cont","tokenBase","tokenize","tokenString","tokenComment","expressionAllowed","tokenQuasi","lexical","lastType","propertyIsEnumerable","quote","maybeEnd","brackets","findFatArrow","fatArrowAt","arrow","sawSomething","atomicTypes","JSLexical","indented","align","inScope","varname","v","localVars","cx","vars","parseJS","cc","combinator","expression","statement","lex","pass","inList","newContext","registerVarScoped","Var","globalVars","Context","isModifier","defaultVars","pushcontext","pushblockcontext","popcontext","pushlex","outer","poplex","expect","wanted","exp","vardef","parenExpr","maybeexpression","maybeelse","functiondef","forspec","enumdef","typename","typeexpr","maybelabel","maybeCatchBinding","afterExport","afterImport","funarg","expressionInner","expressionNoComma","noComma","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","classExpression","arrayLiteral","contCommasep","objprop","quasi","maybeTarget","property","continueQuasi","targetNoComma","maybeTypeArgs","getterSetter","afterprop","maybetype","what","sep","proceed","maybetypeOrIn","mayberettype","isKW","afterType","typeprops","typearg","maybeReturnType","quasiType","typeprop","functiondecl","continueQuasiType","typeparam","maybeTypeDefault","maybeAssign","vardefCont","eltpattern","proppattern","_type","forspec1","forspec2","classNameAfter","classBody","classfield","isInterface","maybeFrom","exportField","importSpec","maybeMoreImports","maybeAs","enummember","isContinuedStatement","textAfter","basecolumn","firstChar","doubleIndentSwitch","electricInput","blockCommentStart","blockCommentEnd","blockCommentContinue","closeBrackets","helperType","skipExpression"],"mappings":"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","file":"js/codemirror.ba3ad6d1.js","sourcesContent":["// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../../@vue/cli-service/node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \".cm-s-base16-dark.CodeMirror{background:#151515;color:#e0e0e0}.cm-s-base16-dark div.CodeMirror-selected{background:#303030}.cm-s-base16-dark .CodeMirror-line::selection,.cm-s-base16-dark .CodeMirror-line>span::selection,.cm-s-base16-dark .CodeMirror-line>span>span::selection{background:rgba(48,48,48,.99)}.cm-s-base16-dark .CodeMirror-line::-moz-selection,.cm-s-base16-dark .CodeMirror-line>span::-moz-selection,.cm-s-base16-dark .CodeMirror-line>span>span::-moz-selection{background:rgba(48,48,48,.99)}.cm-s-base16-dark .CodeMirror-gutters{background:#151515;border-right:0}.cm-s-base16-dark .CodeMirror-guttermarker{color:#ac4142}.cm-s-base16-dark .CodeMirror-guttermarker-subtle,.cm-s-base16-dark .CodeMirror-linenumber{color:#505050}.cm-s-base16-dark .CodeMirror-cursor{border-left:1px solid #b0b0b0}.cm-s-base16-dark .cm-animate-fat-cursor,.cm-s-base16-dark.cm-fat-cursor .CodeMirror-cursor{background-color:rgba(142,141,136,.4588235294117647)!important}.cm-s-base16-dark span.cm-comment{color:#8f5536}.cm-s-base16-dark span.cm-atom,.cm-s-base16-dark span.cm-number{color:#aa759f}.cm-s-base16-dark span.cm-attribute,.cm-s-base16-dark span.cm-property{color:#90a959}.cm-s-base16-dark span.cm-keyword{color:#ac4142}.cm-s-base16-dark span.cm-string{color:#f4bf75}.cm-s-base16-dark span.cm-variable{color:#90a959}.cm-s-base16-dark span.cm-variable-2{color:#6a9fb5}.cm-s-base16-dark span.cm-def{color:#d28445}.cm-s-base16-dark span.cm-bracket{color:#e0e0e0}.cm-s-base16-dark span.cm-tag{color:#ac4142}.cm-s-base16-dark span.cm-link{color:#aa759f}.cm-s-base16-dark span.cm-error{background:#ac4142;color:#b0b0b0}.cm-s-base16-dark .CodeMirror-activeline-background{background:#202020}.cm-s-base16-dark .CodeMirror-matchingbracket{text-decoration:underline;color:#fff!important}\", \"\"]);\n// Exports\nmodule.exports = exports;\n","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../@vue/cli-service/node_modules/css-loader/dist/cjs.js??ref--7-oneOf-3-1!../../../postcss-loader/src/index.js??ref--7-oneOf-3-2!../../../postcss-loader/src/index.js??ref--7-oneOf-3-3!./lint.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"23b29e40\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../../@vue/cli-service/node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \".cm-s-base16-light.CodeMirror{background:#f5f5f5;color:#202020}.cm-s-base16-light div.CodeMirror-selected{background:#e0e0e0}.cm-s-base16-light .CodeMirror-line::selection,.cm-s-base16-light .CodeMirror-line>span::selection,.cm-s-base16-light .CodeMirror-line>span>span::selection{background:#e0e0e0}.cm-s-base16-light .CodeMirror-line::-moz-selection,.cm-s-base16-light .CodeMirror-line>span::-moz-selection,.cm-s-base16-light .CodeMirror-line>span>span::-moz-selection{background:#e0e0e0}.cm-s-base16-light .CodeMirror-gutters{background:#f5f5f5;border-right:0}.cm-s-base16-light .CodeMirror-guttermarker{color:#ac4142}.cm-s-base16-light .CodeMirror-guttermarker-subtle,.cm-s-base16-light .CodeMirror-linenumber{color:#b0b0b0}.cm-s-base16-light .CodeMirror-cursor{border-left:1px solid #505050}.cm-s-base16-light span.cm-comment{color:#8f5536}.cm-s-base16-light span.cm-atom,.cm-s-base16-light span.cm-number{color:#aa759f}.cm-s-base16-light span.cm-attribute,.cm-s-base16-light span.cm-property{color:#90a959}.cm-s-base16-light span.cm-keyword{color:#ac4142}.cm-s-base16-light span.cm-string{color:#f4bf75}.cm-s-base16-light span.cm-variable{color:#90a959}.cm-s-base16-light span.cm-variable-2{color:#6a9fb5}.cm-s-base16-light span.cm-def{color:#d28445}.cm-s-base16-light span.cm-bracket{color:#202020}.cm-s-base16-light span.cm-tag{color:#ac4142}.cm-s-base16-light span.cm-link{color:#aa759f}.cm-s-base16-light span.cm-error{background:#ac4142;color:#505050}.cm-s-base16-light .CodeMirror-activeline-background{background:#dddcdc}.cm-s-base16-light .CodeMirror-matchingbracket{color:#f5f5f5!important;background-color:#6a9fb5!important}\", \"\"]);\n// Exports\nmodule.exports = exports;\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// Open simple dialogs on top of an editor. Relies on dialog.css.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  function dialogDiv(cm, template, bottom) {\n    var wrap = cm.getWrapperElement();\n    var dialog;\n    dialog = wrap.appendChild(document.createElement(\"div\"));\n    if (bottom)\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-bottom\";\n    else\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-top\";\n\n    if (typeof template == \"string\") {\n      dialog.innerHTML = template;\n    } else { // Assuming it's a detached DOM element.\n      dialog.appendChild(template);\n    }\n    CodeMirror.addClass(wrap, 'dialog-opened');\n    return dialog;\n  }\n\n  function closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n      cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n  }\n\n  CodeMirror.defineExtension(\"openDialog\", function(template, callback, options) {\n    if (!options) options = {};\n\n    closeNotification(this, null);\n\n    var dialog = dialogDiv(this, template, options.bottom);\n    var closed = false, me = this;\n    function close(newVal) {\n      if (typeof newVal == 'string') {\n        inp.value = newVal;\n      } else {\n        if (closed) return;\n        closed = true;\n        CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n        dialog.parentNode.removeChild(dialog);\n        me.focus();\n\n        if (options.onClose) options.onClose(dialog);\n      }\n    }\n\n    var inp = dialog.getElementsByTagName(\"input\")[0], button;\n    if (inp) {\n      inp.focus();\n\n      if (options.value) {\n        inp.value = options.value;\n        if (options.selectValueOnOpen !== false) {\n          inp.select();\n        }\n      }\n\n      if (options.onInput)\n        CodeMirror.on(inp, \"input\", function(e) { options.onInput(e, inp.value, close);});\n      if (options.onKeyUp)\n        CodeMirror.on(inp, \"keyup\", function(e) {options.onKeyUp(e, inp.value, close);});\n\n      CodeMirror.on(inp, \"keydown\", function(e) {\n        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }\n        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n          inp.blur();\n          CodeMirror.e_stop(e);\n          close();\n        }\n        if (e.keyCode == 13) callback(inp.value, e);\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(dialog, \"focusout\", function (evt) {\n        if (evt.relatedTarget !== null) close();\n      });\n    } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n      CodeMirror.on(button, \"click\", function() {\n        close();\n        me.focus();\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n\n      button.focus();\n    }\n    return close;\n  });\n\n  CodeMirror.defineExtension(\"openConfirm\", function(template, callbacks, options) {\n    closeNotification(this, null);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var buttons = dialog.getElementsByTagName(\"button\");\n    var closed = false, me = this, blurring = 1;\n    function close() {\n      if (closed) return;\n      closed = true;\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n      dialog.parentNode.removeChild(dialog);\n      me.focus();\n    }\n    buttons[0].focus();\n    for (var i = 0; i < buttons.length; ++i) {\n      var b = buttons[i];\n      (function(callback) {\n        CodeMirror.on(b, \"click\", function(e) {\n          CodeMirror.e_preventDefault(e);\n          close();\n          if (callback) callback(me);\n        });\n      })(callbacks[i]);\n      CodeMirror.on(b, \"blur\", function() {\n        --blurring;\n        setTimeout(function() { if (blurring <= 0) close(); }, 200);\n      });\n      CodeMirror.on(b, \"focus\", function() { ++blurring; });\n    }\n  });\n\n  /*\n   * openNotification\n   * Opens a notification, that can be closed with an optional timer\n   * (default 5000ms timer) and always closes on click.\n   *\n   * If a notification is opened while another is opened, it will close the\n   * currently opened one and open the new one immediately.\n   */\n  CodeMirror.defineExtension(\"openNotification\", function(template, options) {\n    closeNotification(this, close);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var closed = false, doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n\n    function close() {\n      if (closed) return;\n      closed = true;\n      clearTimeout(doneTimer);\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n      dialog.parentNode.removeChild(dialog);\n    }\n\n    CodeMirror.on(dialog, 'click', function(e) {\n      CodeMirror.e_preventDefault(e);\n      close();\n    });\n\n    if (duration)\n      doneTimer = setTimeout(close, duration);\n\n    return close;\n  });\n});\n","// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../../../@vue/cli-service/node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \".CodeMirror-lint-markers{width:16px}.CodeMirror-lint-tooltip{background-color:#ffd;border:1px solid #000;border-radius:4px 4px 4px 4px;color:#000;font-family:monospace;font-size:10pt;overflow:hidden;padding:2px 5px;position:fixed;white-space:pre;white-space:pre-wrap;z-index:100;max-width:600px;opacity:0;transition:opacity .4s;-moz-transition:opacity .4s;-webkit-transition:opacity .4s;-o-transition:opacity .4s;-ms-transition:opacity .4s}.CodeMirror-lint-mark{background-position:0 100%;background-repeat:repeat-x}.CodeMirror-lint-mark-warning{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=\\\")}.CodeMirror-lint-mark-error{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==\\\")}.CodeMirror-lint-marker{background-position:50%;background-repeat:no-repeat;cursor:pointer;display:inline-block;height:16px;width:16px;vertical-align:middle;position:relative}.CodeMirror-lint-message{padding-left:18px;background-position:0 0;background-repeat:no-repeat}.CodeMirror-lint-marker-warning,.CodeMirror-lint-message-warning{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=\\\")}.CodeMirror-lint-marker-error,.CodeMirror-lint-message-error{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=\\\")}.CodeMirror-lint-marker-multiple{background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC\\\");background-repeat:no-repeat;background-position:100% 100%;width:100%;height:100%}.CodeMirror-lint-line-error{background-color:rgba(183,76,81,.08)}.CodeMirror-lint-line-warning{background-color:rgba(255,211,0,.1)}\", \"\"]);\n// Exports\nmodule.exports = exports;\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n  function posEq(a, b) { return a.line == b.line && a.ch == b.ch; }\n\n  // Kill 'ring'\n\n  var killRing = [];\n  function addToRing(str) {\n    killRing.push(str);\n    if (killRing.length > 50) killRing.shift();\n  }\n  function growRingTop(str) {\n    if (!killRing.length) return addToRing(str);\n    killRing[killRing.length - 1] += str;\n  }\n  function getFromRing(n) { return killRing[killRing.length - (n ? Math.min(n, 1) : 1)] || \"\"; }\n  function popFromRing() { if (killRing.length > 1) killRing.pop(); return getFromRing(); }\n\n  var lastKill = null;\n\n  // Internal generic kill function, used by several mapped kill \"family\" functions.\n  function _kill(cm, from, to, ring, text) {\n    if (text == null) text = cm.getRange(from, to);\n\n    if (ring == \"grow\" && lastKill && lastKill.cm == cm && posEq(from, lastKill.pos) && cm.isClean(lastKill.gen))\n      growRingTop(text);\n    else if (ring !== false)\n      addToRing(text);\n    cm.replaceRange(\"\", from, to, \"+delete\");\n\n    if (ring == \"grow\") lastKill = {cm: cm, pos: from, gen: cm.changeGeneration()};\n    else lastKill = null;\n  }\n\n  // Boundaries of various units\n\n  function byChar(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"char\", true);\n  }\n\n  function byWord(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"word\", true);\n  }\n\n  function byLine(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"line\", cm.doc.sel.goalColumn);\n  }\n\n  function byPage(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"page\", cm.doc.sel.goalColumn);\n  }\n\n  function byParagraph(cm, pos, dir) {\n    var no = pos.line, line = cm.getLine(no);\n    var sawText = /\\S/.test(dir < 0 ? line.slice(0, pos.ch) : line.slice(pos.ch));\n    var fst = cm.firstLine(), lst = cm.lastLine();\n    for (;;) {\n      no += dir;\n      if (no < fst || no > lst)\n        return cm.clipPos(Pos(no - dir, dir < 0 ? 0 : null));\n      line = cm.getLine(no);\n      var hasText = /\\S/.test(line);\n      if (hasText) sawText = true;\n      else if (sawText) return Pos(no, 0);\n    }\n  }\n\n  function bySentence(cm, pos, dir) {\n    var line = pos.line, ch = pos.ch;\n    var text = cm.getLine(pos.line), sawWord = false;\n    for (;;) {\n      var next = text.charAt(ch + (dir < 0 ? -1 : 0));\n      if (!next) { // End/beginning of line reached\n        if (line == (dir < 0 ? cm.firstLine() : cm.lastLine())) return Pos(line, ch);\n        text = cm.getLine(line + dir);\n        if (!/\\S/.test(text)) return Pos(line, ch);\n        line += dir;\n        ch = dir < 0 ? text.length : 0;\n        continue;\n      }\n      if (sawWord && /[!?.]/.test(next)) return Pos(line, ch + (dir > 0 ? 1 : 0));\n      if (!sawWord) sawWord = /\\w/.test(next);\n      ch += dir;\n    }\n  }\n\n  function byExpr(cm, pos, dir) {\n    var wrap;\n    if (cm.findMatchingBracket && (wrap = cm.findMatchingBracket(pos, {strict: true}))\n        && wrap.match && (wrap.forward ? 1 : -1) == dir)\n      return dir > 0 ? Pos(wrap.to.line, wrap.to.ch + 1) : wrap.to;\n\n    for (var first = true;; first = false) {\n      var token = cm.getTokenAt(pos);\n      var after = Pos(pos.line, dir < 0 ? token.start : token.end);\n      if (first && dir > 0 && token.end == pos.ch || !/\\w/.test(token.string)) {\n        var newPos = cm.findPosH(after, dir, \"char\");\n        if (posEq(after, newPos)) return pos;\n        else pos = newPos;\n      } else {\n        return after;\n      }\n    }\n  }\n\n  // Prefixes (only crudely supported)\n\n  function getPrefix(cm, precise) {\n    var digits = cm.state.emacsPrefix;\n    if (!digits) return precise ? null : 1;\n    clearPrefix(cm);\n    return digits == \"-\" ? -1 : Number(digits);\n  }\n\n  function repeated(cmd) {\n    var f = typeof cmd == \"string\" ? function(cm) { cm.execCommand(cmd); } : cmd;\n    return function(cm) {\n      var prefix = getPrefix(cm);\n      f(cm);\n      for (var i = 1; i < prefix; ++i) f(cm);\n    };\n  }\n\n  function findEnd(cm, pos, by, dir) {\n    var prefix = getPrefix(cm);\n    if (prefix < 0) { dir = -dir; prefix = -prefix; }\n    for (var i = 0; i < prefix; ++i) {\n      var newPos = by(cm, pos, dir);\n      if (posEq(newPos, pos)) break;\n      pos = newPos;\n    }\n    return pos;\n  }\n\n  function move(by, dir) {\n    var f = function(cm) {\n      cm.extendSelection(findEnd(cm, cm.getCursor(), by, dir));\n    };\n    f.motion = true;\n    return f;\n  }\n\n  function killTo(cm, by, dir, ring) {\n    var selections = cm.listSelections(), cursor;\n    var i = selections.length;\n    while (i--) {\n      cursor = selections[i].head;\n      _kill(cm, cursor, findEnd(cm, cursor, by, dir), ring);\n    }\n  }\n\n  function _killRegion(cm, ring) {\n    if (cm.somethingSelected()) {\n      var selections = cm.listSelections(), selection;\n      var i = selections.length;\n      while (i--) {\n        selection = selections[i];\n        _kill(cm, selection.anchor, selection.head, ring);\n      }\n      return true;\n    }\n  }\n\n  function addPrefix(cm, digit) {\n    if (cm.state.emacsPrefix) {\n      if (digit != \"-\") cm.state.emacsPrefix += digit;\n      return;\n    }\n    // Not active yet\n    cm.state.emacsPrefix = digit;\n    cm.on(\"keyHandled\", maybeClearPrefix);\n    cm.on(\"inputRead\", maybeDuplicateInput);\n  }\n\n  var prefixPreservingKeys = {\"Alt-G\": true, \"Ctrl-X\": true, \"Ctrl-Q\": true, \"Ctrl-U\": true};\n\n  function maybeClearPrefix(cm, arg) {\n    if (!cm.state.emacsPrefixMap && !prefixPreservingKeys.hasOwnProperty(arg))\n      clearPrefix(cm);\n  }\n\n  function clearPrefix(cm) {\n    cm.state.emacsPrefix = null;\n    cm.off(\"keyHandled\", maybeClearPrefix);\n    cm.off(\"inputRead\", maybeDuplicateInput);\n  }\n\n  function maybeDuplicateInput(cm, event) {\n    var dup = getPrefix(cm);\n    if (dup > 1 && event.origin == \"+input\") {\n      var one = event.text.join(\"\\n\"), txt = \"\";\n      for (var i = 1; i < dup; ++i) txt += one;\n      cm.replaceSelection(txt);\n    }\n  }\n\n  function maybeRemovePrefixMap(cm, arg) {\n    if (typeof arg == \"string\" && (/^\\d$/.test(arg) || arg == \"Ctrl-U\")) return;\n    cm.removeKeyMap(prefixMap);\n    cm.state.emacsPrefixMap = false;\n    cm.off(\"keyHandled\", maybeRemovePrefixMap);\n    cm.off(\"inputRead\", maybeRemovePrefixMap);\n  }\n\n  // Utilities\n\n  cmds.setMark = function (cm) {\n    cm.setCursor(cm.getCursor());\n    cm.setExtending(!cm.getExtending());\n    cm.on(\"change\", function() { cm.setExtending(false); });\n  }\n\n  function clearMark(cm) {\n    cm.setExtending(false);\n    cm.setCursor(cm.getCursor());\n  }\n\n  function makePrompt(msg) {\n    var fragment = document.createDocumentFragment();\n    var input = document.createElement(\"input\");\n    input.setAttribute(\"type\", \"text\");\n    input.style.width = \"10em\";\n    fragment.appendChild(document.createTextNode(msg + \": \"));\n    fragment.appendChild(input);\n    return fragment;\n  }\n\n  function getInput(cm, msg, f) {\n    if (cm.openDialog)\n      cm.openDialog(makePrompt(msg), f, {bottom: true});\n    else\n      f(prompt(msg, \"\"));\n  }\n\n  function operateOnWord(cm, op) {\n    var start = cm.getCursor(), end = cm.findPosH(start, 1, \"word\");\n    cm.replaceRange(op(cm.getRange(start, end)), start, end);\n    cm.setCursor(end);\n  }\n\n  function toEnclosingExpr(cm) {\n    var pos = cm.getCursor(), line = pos.line, ch = pos.ch;\n    var stack = [];\n    while (line >= cm.firstLine()) {\n      var text = cm.getLine(line);\n      for (var i = ch == null ? text.length : ch; i > 0;) {\n        var ch = text.charAt(--i);\n        if (ch == \")\")\n          stack.push(\"(\");\n        else if (ch == \"]\")\n          stack.push(\"[\");\n        else if (ch == \"}\")\n          stack.push(\"{\");\n        else if (/[\\(\\{\\[]/.test(ch) && (!stack.length || stack.pop() != ch))\n          return cm.extendSelection(Pos(line, i));\n      }\n      --line; ch = null;\n    }\n  }\n\n  // Commands. Names should match emacs function names (albeit in camelCase)\n  // except where emacs function names collide with code mirror core commands.\n\n  cmds.killRegion = function(cm) {\n    _kill(cm, cm.getCursor(\"start\"), cm.getCursor(\"end\"), true);\n  };\n\n  // Maps to emacs kill-line\n  cmds.killLineEmacs = repeated(function(cm) {\n    var start = cm.getCursor(), end = cm.clipPos(Pos(start.line));\n    var text = cm.getRange(start, end);\n    if (!/\\S/.test(text)) {\n      text += \"\\n\";\n      end = Pos(start.line + 1, 0);\n    }\n    _kill(cm, start, end, \"grow\", text);\n  });\n\n  cmds.killRingSave = function(cm) {\n    addToRing(cm.getSelection());\n    clearMark(cm);\n  };\n\n  cmds.yank = function(cm) {\n    var start = cm.getCursor();\n    cm.replaceRange(getFromRing(getPrefix(cm)), start, start, \"paste\");\n    cm.setSelection(start, cm.getCursor());\n  };\n\n  cmds.yankPop = function(cm) {\n    cm.replaceSelection(popFromRing(), \"around\", \"paste\");\n  };\n\n  cmds.forwardChar = move(byChar, 1);\n\n  cmds.backwardChar = move(byChar, -1)\n\n  cmds.deleteChar = function(cm) { killTo(cm, byChar, 1, false); };\n\n  cmds.deleteForwardChar = function(cm) {\n    _killRegion(cm, false) || killTo(cm, byChar, 1, false);\n  };\n\n  cmds.deleteBackwardChar = function(cm) {\n    _killRegion(cm, false) || killTo(cm, byChar, -1, false);\n  };\n\n  cmds.forwardWord = move(byWord, 1);\n\n  cmds.backwardWord = move(byWord, -1);\n\n  cmds.killWord = function(cm) { killTo(cm, byWord, 1, \"grow\"); };\n\n  cmds.backwardKillWord = function(cm) { killTo(cm, byWord, -1, \"grow\"); };\n\n  cmds.nextLine = move(byLine, 1);\n\n  cmds.previousLine = move(byLine, -1);\n\n  cmds.scrollDownCommand = move(byPage, -1);\n\n  cmds.scrollUpCommand = move(byPage, 1);\n\n  cmds.backwardParagraph = move(byParagraph, -1);\n\n  cmds.forwardParagraph = move(byParagraph, 1);\n\n  cmds.backwardSentence = move(bySentence, -1);\n\n  cmds.forwardSentence = move(bySentence, 1);\n\n  cmds.killSentence = function(cm) { killTo(cm, bySentence, 1, \"grow\"); };\n\n  cmds.backwardKillSentence = function(cm) {\n    _kill(cm, cm.getCursor(), bySentence(cm, cm.getCursor(), 1), \"grow\");\n  };\n\n  cmds.killSexp = function(cm) { killTo(cm, byExpr, 1, \"grow\"); };\n\n  cmds.backwardKillSexp = function(cm) { killTo(cm, byExpr, -1, \"grow\"); };\n\n  cmds.forwardSexp = move(byExpr, 1);\n\n  cmds.backwardSexp = move(byExpr, -1);\n\n  cmds.markSexp = function(cm) {\n    var cursor = cm.getCursor();\n    cm.setSelection(findEnd(cm, cursor, byExpr, 1), cursor);\n  };\n\n  cmds.transposeSexps = function(cm) {\n    var leftStart = byExpr(cm, cm.getCursor(), -1);\n    var leftEnd = byExpr(cm, leftStart, 1);\n    var rightEnd = byExpr(cm, leftEnd, 1);\n    var rightStart = byExpr(cm, rightEnd, -1);\n    cm.replaceRange(cm.getRange(rightStart, rightEnd) +\n                    cm.getRange(leftEnd, rightStart) +\n                    cm.getRange(leftStart, leftEnd), leftStart, rightEnd);\n  };\n\n  cmds.backwardUpList = repeated(toEnclosingExpr);\n\n  cmds.justOneSpace = function(cm) {\n    var pos = cm.getCursor(), from = pos.ch;\n    var to = pos.ch, text = cm.getLine(pos.line);\n    while (from && /\\s/.test(text.charAt(from - 1))) --from;\n    while (to < text.length && /\\s/.test(text.charAt(to))) ++to;\n    cm.replaceRange(\" \", Pos(pos.line, from), Pos(pos.line, to));\n  };\n\n  cmds.openLine = repeated(function(cm) {\n    cm.replaceSelection(\"\\n\", \"start\");\n  });\n\n  // maps to emacs 'transpose-chars'\n  cmds.transposeCharsRepeatable = repeated(function(cm) {\n    cm.execCommand(\"transposeChars\");\n  });\n\n  cmds.capitalizeWord = repeated(function(cm) {\n    operateOnWord(cm, function(w) {\n      var letter = w.search(/\\w/);\n      if (letter == -1) return w;\n      return w.slice(0, letter) + w.charAt(letter).toUpperCase() +\n          w.slice(letter + 1).toLowerCase();\n    });\n  });\n\n  cmds.upcaseWord = repeated(function(cm) {\n    operateOnWord(cm, function(w) { return w.toUpperCase(); });\n  });\n\n  cmds.downcaseWord = repeated(function(cm) {\n    operateOnWord(cm, function(w) { return w.toLowerCase(); });\n  });\n\n  // maps to emacs 'undo'\n  cmds.undoRepeatable = repeated(\"undo\");\n\n  cmds.keyboardQuit = function(cm) {\n    cm.execCommand(\"clearSearch\");\n    clearMark(cm);\n  }\n\n  cmds.newline = repeated(function(cm) { cm.replaceSelection(\"\\n\", \"end\"); });\n\n  cmds.gotoLine = function(cm) {\n    var prefix = getPrefix(cm, true);\n    if (prefix != null && prefix > 0) return cm.setCursor(prefix - 1);\n\n    getInput(cm, \"Goto line\", function(str) {\n      var num;\n      if (str && !isNaN(num = Number(str)) && num == (num|0) && num > 0)\n      cm.setCursor(num - 1);\n    });\n  };\n\n  cmds.indentRigidly = function(cm) {\n    cm.indentSelection(getPrefix(cm, true) || cm.getOption(\"indentUnit\"));\n  };\n\n  cmds.exchangePointAndMark = function(cm) {\n    cm.setSelection(cm.getCursor(\"head\"), cm.getCursor(\"anchor\"));\n  };\n\n  cmds.quotedInsertTab = repeated(\"insertTab\");\n\n  cmds.universalArgument = function addPrefixMap(cm) {\n    cm.state.emacsPrefixMap = true;\n    cm.addKeyMap(prefixMap);\n    cm.on(\"keyHandled\", maybeRemovePrefixMap);\n    cm.on(\"inputRead\", maybeRemovePrefixMap);\n  };\n\n  CodeMirror.emacs = {kill: _kill, killRegion: _killRegion, repeated: repeated};\n\n  // Actual keymap\n  var keyMap = CodeMirror.keyMap.emacs = CodeMirror.normalizeKeyMap({\n    \"Ctrl-W\": \"killRegion\",\n    \"Ctrl-K\": \"killLineEmacs\",\n    \"Alt-W\": \"killRingSave\",\n    \"Ctrl-Y\": \"yank\",\n    \"Alt-Y\": \"yankPop\",\n    \"Ctrl-Space\": \"setMark\",\n    \"Ctrl-Shift-2\": \"setMark\",\n    \"Ctrl-F\": \"forwardChar\",\n    \"Ctrl-B\": \"backwardChar\",\n    \"Right\": \"forwardChar\",\n    \"Left\": \"backwardChar\",\n    \"Ctrl-D\": \"deleteChar\",\n    \"Delete\": \"deleteForwardChar\",\n    \"Ctrl-H\": \"deleteBackwardChar\",\n    \"Backspace\": \"deleteBackwardChar\",\n    \"Alt-F\": \"forwardWord\",\n    \"Alt-B\": \"backwardWord\",\n    \"Alt-Right\": \"forwardWord\",\n    \"Alt-Left\": \"backwardWord\",\n    \"Alt-D\": \"killWord\",\n    \"Alt-Backspace\": \"backwardKillWord\",\n    \"Ctrl-N\": \"nextLine\",\n    \"Ctrl-P\": \"previousLine\",\n    \"Down\": \"nextLine\",\n    \"Up\": \"previousLine\",\n    \"Ctrl-A\": \"goLineStart\",\n    \"Ctrl-E\": \"goLineEnd\",\n    \"End\": \"goLineEnd\",\n    \"Home\": \"goLineStart\",\n    \"Alt-V\": \"scrollDownCommand\",\n    \"Ctrl-V\": \"scrollUpCommand\",\n    \"PageUp\": \"scrollDownCommand\",\n    \"PageDown\": \"scrollUpCommand\",\n    \"Ctrl-Up\": \"backwardParagraph\",\n    \"Ctrl-Down\": \"forwardParagraph\",\n    \"Alt-{\": \"backwardParagraph\",\n    \"Alt-}\": \"forwardParagraph\",\n    \"Alt-A\": \"backwardSentence\",\n    \"Alt-E\": \"forwardSentence\",\n    \"Alt-K\": \"killSentence\",\n    \"Ctrl-X Delete\": \"backwardKillSentence\",\n    \"Ctrl-Alt-K\": \"killSexp\",\n    \"Ctrl-Alt-Backspace\": \"backwardKillSexp\",\n    \"Ctrl-Alt-F\": \"forwardSexp\",\n    \"Ctrl-Alt-B\": \"backwardSexp\",\n    \"Shift-Ctrl-Alt-2\": \"markSexp\",\n    \"Ctrl-Alt-T\": \"transposeSexps\",\n    \"Ctrl-Alt-U\": \"backwardUpList\",\n    \"Alt-Space\": \"justOneSpace\",\n    \"Ctrl-O\": \"openLine\",\n    \"Ctrl-T\": \"transposeCharsRepeatable\",\n    \"Alt-C\": \"capitalizeWord\",\n    \"Alt-U\": \"upcaseWord\",\n    \"Alt-L\": \"downcaseWord\",\n    \"Alt-;\": \"toggleComment\",\n    \"Ctrl-/\": \"undoRepeatable\",\n    \"Shift-Ctrl--\": \"undoRepeatable\",\n    \"Ctrl-Z\": \"undoRepeatable\",\n    \"Cmd-Z\": \"undoRepeatable\",\n    \"Ctrl-X U\": \"undoRepeatable\",\n    \"Shift-Ctrl-Z\": \"redo\",\n    \"Shift-Alt-,\": \"goDocStart\",\n    \"Shift-Alt-.\": \"goDocEnd\",\n    \"Ctrl-S\": \"findPersistentNext\",\n    \"Ctrl-R\": \"findPersistentPrev\",\n    \"Ctrl-G\": \"keyboardQuit\",\n    \"Shift-Alt-5\": \"replace\",\n    \"Alt-/\": \"autocomplete\",\n    \"Enter\": \"newlineAndIndent\",\n    \"Ctrl-J\": \"newline\",\n    \"Tab\": \"indentAuto\",\n    \"Alt-G G\": \"gotoLine\",\n    \"Ctrl-X Tab\": \"indentRigidly\",\n    \"Ctrl-X Ctrl-X\": \"exchangePointAndMark\",\n    \"Ctrl-X Ctrl-S\": \"save\",\n    \"Ctrl-X Ctrl-W\": \"save\",\n    \"Ctrl-X S\": \"saveAll\",\n    \"Ctrl-X F\": \"open\",\n    \"Ctrl-X K\": \"close\",\n    \"Ctrl-X H\": \"selectAll\",\n    \"Ctrl-Q Tab\": \"quotedInsertTab\",\n    \"Ctrl-U\": \"universalArgument\",\n    \"fallthrough\": \"default\"\n  });\n\n  var prefixMap = {\"Ctrl-G\": clearPrefix};\n  function regPrefix(d) {\n    prefixMap[d] = function(cm) { addPrefix(cm, d); };\n    keyMap[\"Ctrl-\" + d] = function(cm) { addPrefix(cm, d); };\n    prefixPreservingKeys[\"Ctrl-\" + d] = true;\n  }\n  for (var i = 0; i < 10; ++i) regPrefix(String(i));\n  regPrefix(\"-\");\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function doFold(cm, pos, options, force) {\n    if (options && options.call) {\n      var finder = options;\n      options = null;\n    } else {\n      var finder = getOption(cm, options, \"rangeFinder\");\n    }\n    if (typeof pos == \"number\") pos = CodeMirror.Pos(pos, 0);\n    var minSize = getOption(cm, options, \"minFoldSize\");\n\n    function getRange(allowFolded) {\n      var range = finder(cm, pos);\n      if (!range || range.to.line - range.from.line < minSize) return null;\n      if (force === \"fold\") return range;\n\n      var marks = cm.findMarksAt(range.from);\n      for (var i = 0; i < marks.length; ++i) {\n        if (marks[i].__isFold) {\n          if (!allowFolded) return null;\n          range.cleared = true;\n          marks[i].clear();\n        }\n      }\n      return range;\n    }\n\n    var range = getRange(true);\n    if (getOption(cm, options, \"scanUp\")) while (!range && pos.line > cm.firstLine()) {\n      pos = CodeMirror.Pos(pos.line - 1, 0);\n      range = getRange(false);\n    }\n    if (!range || range.cleared || force === \"unfold\") return;\n\n    var myWidget = makeWidget(cm, options, range);\n    CodeMirror.on(myWidget, \"mousedown\", function(e) {\n      myRange.clear();\n      CodeMirror.e_preventDefault(e);\n    });\n    var myRange = cm.markText(range.from, range.to, {\n      replacedWith: myWidget,\n      clearOnEnter: getOption(cm, options, \"clearOnEnter\"),\n      __isFold: true\n    });\n    myRange.on(\"clear\", function(from, to) {\n      CodeMirror.signal(cm, \"unfold\", cm, from, to);\n    });\n    CodeMirror.signal(cm, \"fold\", cm, range.from, range.to);\n  }\n\n  function makeWidget(cm, options, range) {\n    var widget = getOption(cm, options, \"widget\");\n\n    if (typeof widget == \"function\") {\n      widget = widget(range.from, range.to);\n    }\n\n    if (typeof widget == \"string\") {\n      var text = document.createTextNode(widget);\n      widget = document.createElement(\"span\");\n      widget.appendChild(text);\n      widget.className = \"CodeMirror-foldmarker\";\n    } else if (widget) {\n      widget = widget.cloneNode(true)\n    }\n    return widget;\n  }\n\n  // Clumsy backwards-compatible interface\n  CodeMirror.newFoldFunction = function(rangeFinder, widget) {\n    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };\n  };\n\n  // New-style interface\n  CodeMirror.defineExtension(\"foldCode\", function(pos, options, force) {\n    doFold(this, pos, options, force);\n  });\n\n  CodeMirror.defineExtension(\"isFolded\", function(pos) {\n    var marks = this.findMarksAt(pos);\n    for (var i = 0; i < marks.length; ++i)\n      if (marks[i].__isFold) return true;\n  });\n\n  CodeMirror.commands.toggleFold = function(cm) {\n    cm.foldCode(cm.getCursor());\n  };\n  CodeMirror.commands.fold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, \"fold\");\n  };\n  CodeMirror.commands.unfold = function(cm) {\n    cm.foldCode(cm.getCursor(), { scanUp: false }, \"unfold\");\n  };\n  CodeMirror.commands.foldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), { scanUp: false }, \"fold\");\n    });\n  };\n  CodeMirror.commands.unfoldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), { scanUp: false }, \"unfold\");\n    });\n  };\n\n  CodeMirror.registerHelper(\"fold\", \"combine\", function() {\n    var funcs = Array.prototype.slice.call(arguments, 0);\n    return function(cm, start) {\n      for (var i = 0; i < funcs.length; ++i) {\n        var found = funcs[i](cm, start);\n        if (found) return found;\n      }\n    };\n  });\n\n  CodeMirror.registerHelper(\"fold\", \"auto\", function(cm, start) {\n    var helpers = cm.getHelpers(start, \"fold\");\n    for (var i = 0; i < helpers.length; i++) {\n      var cur = helpers[i](cm, start);\n      if (cur) return cur;\n    }\n  });\n\n  var defaultOptions = {\n    rangeFinder: CodeMirror.fold.auto,\n    widget: \"\\u2194\",\n    minFoldSize: 0,\n    scanUp: false,\n    clearOnEnter: true\n  };\n\n  CodeMirror.defineOption(\"foldOptions\", null);\n\n  function getOption(cm, options, name) {\n    if (options && options[name] !== undefined)\n      return options[name];\n    var editorOptions = cm.options.foldOptions;\n    if (editorOptions && editorOptions[name] !== undefined)\n      return editorOptions[name];\n    return defaultOptions[name];\n  }\n\n  CodeMirror.defineExtension(\"foldOption\", function(options, name) {\n    return getOption(this, options, name);\n  });\n});\n","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../@vue/cli-service/node_modules/css-loader/dist/cjs.js??ref--7-oneOf-3-1!../../../postcss-loader/src/index.js??ref--7-oneOf-3-2!../../../postcss-loader/src/index.js??ref--7-oneOf-3-3!./foldgutter.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"6f3ab9d8\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","(function(mod) {\n    if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n      mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/dialog/dialog\"), require(\"../addon/edit/matchbrackets.js\"));\n    else if (typeof define == \"function\" && define.amd) // AMD\n      define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);\n    else // Plain browser env\n      mod(CodeMirror);\n  })(function(CodeMirror) {\n    'use strict';\n  // CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\nfunction initVim$1(CodeMirror) {\n\n  var Pos = CodeMirror.Pos;\n\n  function transformCursor(cm, range) {\n    var vim = cm.state.vim;\n    if (!vim || vim.insertMode) return range.head;\n    var head = vim.sel.head;\n    if (!head)  return range.head;\n\n    if (vim.visualBlock) {\n      if (range.head.line != head.line) {\n        return;\n      }\n    }\n    if (range.from() == range.anchor && !range.empty()) {\n      if (range.head.line == head.line && range.head.ch != head.ch)\n        return new Pos(range.head.line, range.head.ch - 1);\n    }\n\n    return range.head;\n  }\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: 'g<Up>', type: 'keyToKey', toKeys: 'gk' },\n    { keys: 'g<Down>', type: 'keyToKey', toKeys: 'gj' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>' }, // ipad keyboard sends C-Esc instead of C-[\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'keyToKey', toKeys: 'i', context: 'normal'},\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    {keys: \"g$\", type: \"motion\", motion: \"moveToEndOfDisplayLine\"},\n    {keys: \"g^\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    {keys: \"g0\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true }},\n    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-u>', type: 'operatorMotion', operator: 'delete', motion: 'moveToStartOfLine', context: 'insert' },\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    //ignore C-w in normal mode\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal'},\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n  var defaultKeymapLength = defaultKeymap.length;\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'vglobal', shortName: 'v' },\n    { name: 'global', shortName: 'g' }\n  ];\n\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n      if (highlightTimeout) clearTimeout(highlightTimeout);\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim) {\n        cm.options.$customCursor = null;\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim) {\n        if (cm.curOp) cm.curOp.selectionChanged = true;\n        cm.options.$customCursor = transformCursor;\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = vimApi.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {Shift:'S',Ctrl:'C',Alt:'A',Cmd:'D',Mod:'A',CapsLock:''};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '_', '/']);\n    var upperCaseChars;\n    try { upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\"); }\n    catch (_) { upperCaseChars = /^[A-Z]$/; }\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return upperCaseChars.test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        find: find,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            var template = dom('span', {class: 'cm-vim-message'}, 'recording @' + registerName);\n            this.onRecordingDone = cm.openDialog(template, null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi = {\n      enterVimMode: enterVimMode,\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyway.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        return exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // Non-recursive map function.\n      // NOTE: This will not create mappings to key maps that aren't present\n      // in the default key map. See TODO at bottom of function.\n      noremap: function(lhs, rhs, ctx) {\n        function toCtxArray(ctx) {\n          return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n        }\n        var ctxsToMap = toCtxArray(ctx);\n        // Look through all actual defaults to find a map candidate.\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        for (var i = actualLength - origLength;\n             i < actualLength && ctxsToMap.length;\n             i++) {\n          var mapping = defaultKeymap[i];\n          // Omit mappings that operate in the wrong context(s) and those of invalid type.\n          if (mapping.keys == rhs &&\n              (!ctx || !mapping.context || mapping.context === ctx) &&\n              mapping.type.substr(0, 2) !== 'ex' &&\n              mapping.type.substr(0, 3) !== 'key') {\n            // Make a shallow copy of the original keymap entry.\n            var newMapping = {};\n            for (var key in mapping) {\n              newMapping[key] = mapping[key];\n            }\n            // Modify it point to the new mapping with the proper context.\n            newMapping.keys = lhs;\n            if (ctx && !newMapping.context) {\n              newMapping.context = ctx;\n            }\n            // Add it to the keymap with a higher priority than the original.\n            this._mapCommand(newMapping);\n            // Record the mapped contexts as complete.\n            var mappedCtxs = toCtxArray(mapping.context);\n            ctxsToMap = ctxsToMap.filter(function(el) { return mappedCtxs.indexOf(el) === -1; });\n          }\n        }\n        // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.\n      },\n      // Remove all user-defined mappings for the provided context.\n      mapclear: function(ctx) {\n        // Partition the existing keymap into user-defined and true defaults.\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n          // If a specific context is being cleared, we need to keep mappings\n          // from all other contexts.\n          for (var i = userKeymap.length - 1; i >= 0; i--) {\n            var mapping = userKeymap[i];\n            if (ctx !== mapping.context) {\n              if (mapping.context) {\n                this._mapCommand(mapping);\n              } else {\n                // `mapping` applies to all contexts so create keymap copies\n                // for each context except the one being cleared.\n                var contexts = ['normal', 'insert', 'visual'];\n                for (var j in contexts) {\n                  if (contexts[j] !== ctx) {\n                    var newMapping = {};\n                    for (var key in mapping) {\n                      newMapping[key] = mapping[key];\n                    }\n                    newMapping.context = contexts[j];\n                    this._mapCommand(newMapping);\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      multiSelectHandleKey: multiSelectHandleKey,\n\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            if (vim.visualMode) {\n              // Get back to normal mode.\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              // Get back to normal mode.\n              exitInsertMode(cm);\n            } else {\n              // We're already in normal mode. Let '<Esc>' be handled normally.\n              return;\n            }\n            clearInputState(cm);\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            vimApi.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var mainKey = keysMatcher[2] || keysMatcher[1];\n          if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n            // multikey operators act linewise by repeating only the last character\n            mainKey = vim.inputState.operatorShortcut;\n          }\n          var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n          else if (match.type == 'clear') { clearInputState(cm); return true; }\n\n          vim.inputState.keyBuffer = '';\n          keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!vimApi.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        // The black hole register, \"_, means delete/yank to nowhere.\n        if (registerName === '_') return;\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character || character.length > 1) return {type: 'clear'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (command.keys.length > 1) {\n          inputState.operatorShortcut = command.keys;\n        }\n        if (command.exitVisualBlock) {\n            vim.visualBlock = false;\n            updateCmSelection(cm);\n        }\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: '(JavaScript regexp)',\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n          clearInputState(cm);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      /**\n       * Find and select the next occurrence of the search query. If the cursor is currently\n       * within a match, then find and select the current match. Otherwise, find the next occurrence in the\n       * appropriate direction.\n       *\n       * This differs from `findNext` in the following ways:\n       *\n       * 1. Instead of only returning the \"from\", this returns a \"from\", \"to\" range.\n       * 2. If the cursor is currently inside a search match, this selects the current match\n       *    instead of the next match.\n       * 3. If there is no associated operator, this will turn on visual mode.\n       */\n      findAndSelectNextInclusive: function(cm, _head, motionArgs, vim, prevInputState) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n\n        if (!query) {\n          return;\n        }\n\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n\n        // next: [from, to] | null\n        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n\n        // No matches.\n        if (!next) {\n          return;\n        }\n\n        // If there's an operator that will be executed, return the selection.\n        if (prevInputState.operator) {\n          return next;\n        }\n\n        // At this point, we know that there is no accompanying operator -- let's\n        // deal with visual mode in order to select an appropriate match.\n\n        var from = next[0];\n        // For whatever reason, when we use the \"to\" as returned by searchcursor.js directly,\n        // the resulting selection is extended by 1 char. Let's shrink it so that only the\n        // match is selected.\n        var to = new Pos(next[1].line, next[1].ch - 1);\n\n        if (vim.visualMode) {\n          // If we were in visualLine or visualBlock mode, get out of it.\n          if (vim.visualLine || vim.visualBlock) {\n            vim.visualLine = false;\n            vim.visualBlock = false;\n            CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n          }\n\n          // If we're currently in visual mode, we should extend the selection to include\n          // the search result.\n          var anchor = vim.sel.anchor;\n          if (anchor) {\n            if (state.isReversed()) {\n              if (motionArgs.forward) {\n                return [anchor, from];\n              }\n\n              return [anchor, to];\n            } else {\n              if (motionArgs.forward) {\n                return [anchor, to];\n              }\n\n              return [anchor, from];\n            }\n          }\n        } else {\n          // Let's turn visual mode on.\n          vim.visualMode = true;\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n        }\n\n        return prev ? [to, from] : [from, to];\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return new Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        var posV = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);\n        var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;\n        if (hasMarkedText) {\n          line = posV.line;\n          endCh = posV.ch;\n        }\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        } else if (line > last && cur.line == last){\n            return moveToEol(cm, head, motionArgs, vim, true);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(new Pos(line, endCh),'div').left;\n        return new Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim) {\n        return moveToEol(cm, head, motionArgs, vim, false);\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return new Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          // Only include angle brackets in analysis if they are being matched.\n          var re = (ch === '<' || ch === '>') ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n          var matched = cm.findMatchingBracket(new Pos(line, ch), {bracketRegex: re});\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return new Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return new Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      moveToStartOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineLeft\");\n        return cm.getCursor();\n      },\n      moveToEndOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineRight\");\n        var head = cm.getCursor();\n        if (head.sticky == \"before\") head.ch--;\n        return head;\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '[',\n                             '<': '>', '>': '<'};\n        var selfPaired = {'\\'': true, '\"': true, '`': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else if (character === 't') {\n          tmp = expandTagUnderCursor(cm, head, inclusive);\n        } else if (character === 's') {\n          // account for cursor on end of sentence symbol\n          var content = cm.getLine(head.line);\n          if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n            head.ch -= 1;\n          }\n          var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n          var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n          // closer vim behaviour, 'a' only takes the space after the sentence if there is one before and after\n          if (isWhiteSpaceString(cm.getLine(start.line)[start.ch])\n              && isWhiteSpaceString(cm.getLine(end.line)[end.ch -1])) {\n            start = {line: start.line, ch: start.ch + 1};\n          }\n          tmp = {start: start, end: end};\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n        if (!vim.visualMode) {\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else if (args.fullLine) {\n            head.ch = Number.MAX_VALUE;\n            head.line--;\n            cm.setSelection(anchor, head);\n            text = cm.getSelection();\n            cm.replaceSelection(\"\");\n            finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        if (cm.indentMore) {\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          for (var j = 0; j < repeat; j++) {\n            if (args.indentRight) cm.indentMore();\n            else cm.indentLess();\n          }\n        } else {\n          var startLine = ranges[0].anchor.line;\n          var endLine = vim.visualBlock ?\n            ranges[ranges.length - 1].anchor.line :\n            ranges[0].head.line;\n          // In visual mode, n> shifts the selection right n times, instead of\n          // shifting n lines right once.\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          if (args.linewise) {\n            // The only way to delete a newline is to delete until the start of\n            // the next line, so in linewise mode evalInput will include the next\n            // line. We don't want this in indent, so we go back a line.\n            endLine--;\n          }\n          for (var i = startLine; i <= endLine; i++) {\n            for (var j = 0; j < repeat; j++) {\n              cm.indentLine(i, args.indentRight);\n            }\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      indentAuto: function(cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        switch (actionArgs.position) {\n          case 'center': y = charCoords.bottom - height / 2;\n            break;\n          case 'bottom':\n            var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n            var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n            var lineHeight = lineLastCharCoords.bottom - y;\n            y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        } else {\n          macroModeState.latestRegister = registerName;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = new Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'bol') {\n          head = new Pos(head.line, 0);\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch, sel.anchor.ch) + 1);\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        } else if (insertAt == 'lastEdit') {\n          head = getLastEditPos(cm) || head;\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = new Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = actionArgs.keepSpaces\n            ? text.replace(/\\n\\r?/g, '')\n            : text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = new Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n          text = text.split('\\n');\n          if (linewise) {\n              text.pop();\n          }\n          for (var i = 0; i < text.length; i++) {\n            text[i] = (text[i] == '') ? ' ' : text[i];\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        } else if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = new Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  new Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, new Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = new Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = new Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = new Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (match) {\n          var baseStr = match[2] || match[4];\n          var digits = match[3] || match[5];\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n          var from = new Pos(cur.line, start);\n          var to = new Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur) {\n      var vim = cm.state.vim;\n      var includeLineBreak = vim.insertMode || vim.visualMode;\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return new Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return new Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(new Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = new Pos(i, selectionStart.ch);\n            var head = new Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = new Pos(selectionStart.line, 0);\n            selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            fromCh = anchor.ch,\n            bottom = Math.max(anchor.line, head.line),\n            toCh = head.ch;\n        if (fromCh < toCh) { toCh += 1; }\n        else { fromCh += 1; }        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: new Pos(top + i, fromCh),\n            head: new Pos(top + i, toCh)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: new Pos(cur.line, start), end: new Pos(cur.line, end) };\n    }\n\n    /**\n     * Depends on the following:\n     *\n     * - editor mode should be htmlmixedmode / xml\n     * - mode/xml/xml.js should be loaded\n     * - addon/fold/xml-fold.js should be loaded\n     *\n     * If any of the above requirements are not true, this function noops.\n     *\n     * This is _NOT_ a 100% accurate implementation of vim tag text objects.\n     * The following caveats apply (based off cursory testing, I'm sure there\n     * are other discrepancies):\n     *\n     * - Does not work inside comments:\n     *   ```\n     *   <!-- <div>broken</div> -->\n     *   ```\n     * - Does not work when tags have different cases:\n     *   ```\n     *   <div>broken</DIV>\n     *   ```\n     * - Does not work when cursor is inside a broken tag:\n     *   ```\n     *   <div><brok><en></div>\n     *   ```\n     */\n    function expandTagUnderCursor(cm, head, inclusive) {\n      var cur = head;\n      if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n        return { start: cur, end: cur };\n      }\n\n      var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n      if (!tags || !tags.open || !tags.close) {\n        return { start: cur, end: cur };\n      }\n\n      if (inclusive) {\n        return { start: tags.open.from, end: tags.close.to };\n      }\n      return { start: tags.open.to, end: tags.close.from };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/^#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return new Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = new Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return new Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return new Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n      var cur = head;\n      var retval= new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      var end=cm.clipPos(retval);\n      end.ch--;\n      if (!keepHPos) {\n        vim.lastHPos = Infinity;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n      }\n      return retval;\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return new Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, new Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n  function getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n    /*\n    Takes an index object\n    {\n    line: the line string,\n    ln: line number,\n    pos: index in line,\n    dir: direction of traversal (-1 or 1)\n    }\n    and modifies the pos member to represent the\n    next valid position or sets the line to null if there are\n    no more valid positions.\n   */\n    function nextChar(curr) {\n      if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n          curr.line = null;\n        }\n      else {\n        curr.pos += curr.dir;\n      }\n    }\n    /*\n    Performs one iteration of traversal in forward direction\n    Returns an index object of the new location\n   */\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      if (curr.line === \"\") {\n        return { ln: curr.ln, pos: curr.pos };\n      }\n\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        lastSentencePos = curr.pos;\n        if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return { ln: curr.ln, pos: curr.pos + 1 };\n          } else {\n            nextChar(curr);\n            while (curr.line !== null ) {\n              if (isWhiteSpaceString(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n                nextChar(curr);\n              } else {\n                break;\n              }\n            }\n            return { ln: curr.ln, pos: lastSentencePos + 1, };\n          }\n        }\n        nextChar(curr);\n      }\n      return { ln: curr.ln, pos: lastSentencePos + 1 };\n    }\n\n    /*\n    Performs one iteration of traversal in reverse direction\n    Returns an index object of the new location\n   */\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      if (curr.line === \"\") {\n        return { ln: curr.ln, pos: curr.pos };\n      }\n\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          lastSentencePos = curr.pos;\n        }\n\n        else if (isEndOfSentenceSymbol(curr.line[curr.pos]) ) {\n          if (!inclusive) {\n            return { ln: curr.ln, pos: lastSentencePos };\n          } else {\n              if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n                return { ln: curr.ln, pos: curr.pos + 1, };\n              } else {\n                return {ln: curr.ln, pos: lastSentencePos};\n              }\n          }\n        }\n\n        nextChar(curr);\n      }\n      curr.line = line;\n      if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n        return { ln: curr.ln, pos: curr.pos };\n      } else {\n        return { ln: curr.ln, pos: lastSentencePos };\n      }\n\n    }\n\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch,\n    };\n\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n\n  function findSentence(cm, cur, repeat, dir) {\n\n    /*\n    Takes an index object\n    {\n    line: the line string,\n    ln: line number,\n    pos: index in line,\n    dir: direction of traversal (-1 or 1)\n    }\n    and modifies the line, ln, and pos members to represent the\n    next valid position or sets them to null if there are\n    no more valid positions.\n   */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n          idx.pos += idx.dir;\n        }\n      }\n\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n            && !stop\n            && (curr.pos === curr.line.length - 1\n              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: null,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            }\n            else {\n              return { ln: curr.ln, pos: curr.pos };\n            }\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n              && last_valid.pos !== null\n              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          }\n          else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = { ln: curr.ln, pos: curr.pos };\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return new Pos(curr_index.ln, curr_index.pos);\n    }\n\n    // TODO: perhaps this finagling of start and end positions belongs\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: new Pos(cur.line, start),\n        end: new Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator)\n        separator = '/';\n\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&':'&'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'im' : 'm');\n      return regexp;\n    }\n\n    /**\n     * dom - Document Object Manipulator\n     * Usage:\n     *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])\n     * Examples:\n     *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))\n     *   dom(document.head, dom('script', 'alert(\"hello!\")'))\n     * Not supported:\n     *   dom('p', ['arrays are objects'], Error('objects specify attributes'))\n     */\n    function dom(n) {\n      if (typeof n === 'string') n = document.createElement(n);\n      for (var a, i = 1; i < arguments.length; i++) {\n        if (!(a = arguments[i])) continue;\n        if (typeof a !== 'object') a = document.createTextNode(a);\n        if (a.nodeType) n.appendChild(a);\n        else for (var key in a) {\n          if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n          if (key[0] === '$') n.style[key.slice(1)] = a[key];\n          else n.setAttribute(key, a[key]);\n        }\n      }\n      return n;\n    }\n\n    function showConfirm(cm, template) {\n      var pre = dom('div', {$color: 'red', $whiteSpace: 'pre', class: 'cm-vim-message'}, template);\n      if (cm.openNotification) {\n        cm.openNotification(pre, {bottom: true, duration: 5000});\n      } else {\n        alert(pre.innerText);\n      }\n    }\n\n    function makePrompt(prefix, desc) {\n      return dom(document.createDocumentFragment(),\n               dom('span', {$fontFamily: 'monospace', $whiteSpace: 'pre'},\n                 prefix,\n                 dom('input', {type: 'text', autocorrect: 'off',\n                               autocapitalize: 'off', spellcheck: 'false'})),\n               desc && dom('span', {$color: '#888'}, desc));\n    }\n\n    function showPrompt(cm, options) {\n      var template = makePrompt(options.prefix, options.desc);\n      if (cm.openDialog) {\n        cm.openDialog(template, options.onClose, {\n          onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n          bottom: true, selectValueOnOpen: false, value: options.value\n        });\n      }\n      else {\n        var shortText = '';\n        if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n        if (options.desc) shortText += \" \" + options.desc;\n        options.onClose(prompt(shortText, ''));\n      }\n    }\n\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    var highlightTimeout = 0;\n    function highlightSearchMatches(cm, query) {\n      clearTimeout(highlightTimeout);\n      highlightTimeout = setTimeout(function() {\n        if (!cm.state.vim) return;\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (!overlay || query != overlay.query) {\n          if (overlay) {\n            cm.removeOverlay(overlay);\n          }\n          overlay = searchOverlay(query);\n          cm.addOverlay(overlay);\n          if (cm.showMatchesOnScrollbar) {\n            if (searchState.getScrollbarAnnotate()) {\n              searchState.getScrollbarAnnotate().clear();\n            }\n            searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n          }\n          searchState.setOverlay(overlay);\n        }\n      }, 50);\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n            var lastEndPos = prev ? cursor.from() : cursor.to();\n            found = cursor.find(prev);\n            if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n              if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)\n                found = cursor.find(prev);\n            }\n          }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    /**\n     * Pretty much the same as `findNext`, except for the following differences:\n     *\n     * 1. Before starting the search, move to the previous search. This way if our cursor is\n     * already inside a match, we should return the current match.\n     * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.\n     */\n    function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n\n        // Go back one result to ensure that if the cursor is currently a match, we keep it.\n        var found = cursor.find(!prev);\n\n        // If we haven't moved, go back one more (similar to if i==0 logic in findNext).\n        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n          cursor.find(!prev);\n        }\n\n        for (var i = 0; i < repeat; i++) {\n          found = cursor.find(prev);\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return [cursor.from(), cursor.to()];\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (typeof end == 'number') {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n      } else if (markName == '.') {\n        return getLastEditPos(cm);\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    function getLastEditPos(cm) {\n      var done = cm.doc.history.done;\n      for (var i = done.length; i--;) {\n        if (done[i].changes) {\n          return copyCursor(done[i].changes[0].to);\n        }\n      }\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                vimApi.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return true;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return true;\n            }\n          }\n        }\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n        }\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------\\n\\n';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '\\n';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = new Pos(lineStart, 0);\n        var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      vglobal: function(cm, params) {\n        // global inspects params.commandName\n        this.global(cm, params);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        var inverted = params.commandName[0] === 'v';\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [];\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var line = cm.getLineHandle(i);\n          var matched = query.test(line.text);\n          if (matched !== inverted) {\n            matchedLines.push(cmd ? line : line.text);\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, matchedLines.join('\\n'));\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var line = matchedLines[index++];\n            var lineNum = cm.getLineNumber(line);\n            if (lineNum == null) {\n              nextCommand();\n              return;\n            }\n            var command = (lineNum + 1) + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          if (getOption('pcre') && regexPart !== '') {\n              regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n          }\n          replacePart = tokens[1];\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g,\"$1$$&\"));\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n            }\n            if (getOption('pcre')) {\n               regexPart = regexPart + '/' + flagsPart;\n            } else {\n               regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n            }\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using JavaScript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos, modifiedLineNumber, joined;\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        var unmodifiedLineNumber = searchCursor.to().line;\n        searchCursor.replace(newText);\n        modifiedLineNumber = searchCursor.to().line;\n        lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n        joined = modifiedLineNumber < unmodifiedLineNumber;\n      }\n      function findNextValidMatch() {\n        var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n        var match = searchCursor.findNext();\n        if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n          match = searchCursor.findNext();\n        }\n        return match;\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(findNextValidMatch() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); }\n        return;\n      }\n      showPrompt(cm, {\n        prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!isPlaying) {\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          vimApi.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (lastChange.ignoreCount > 1) {\n            lastChange.ignoreCount--;\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var selectionCount = cm.listSelections().length;\n            if (selectionCount > 1)\n              lastChange.ignoreCount = selectionCount;\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (text) {\n              if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n              } else {\n                lastChange.changes.push(text);\n              }\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n      if (visualBlock) {\n        // Set up block selection again for repeating the changes.\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            cm.replaceSelection(change);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n            cm.setCursor(end);\n          }\n        }\n      }\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    // multiselect support\n    function cloneVimState(state) {\n      var n = new state.constructor();\n      Object.keys(state).forEach(function(key) {\n        var o = state[key];\n        if (Array.isArray(o))\n          o = o.slice();\n        else if (o && typeof o == \"object\" && o.constructor != Object)\n          o = cloneVimState(o);\n        n[key] = o;\n      });\n      if (state.sel) {\n        n.sel = {\n          head: state.sel.head && copyCursor(state.sel.head),\n          anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n        };\n      }\n      return n;\n    }\n    function multiSelectHandleKey(cm, key, origin) {\n      var isHandled = false;\n      var vim = vimApi.maybeInitVimState_(cm);\n      var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n\n      var wasMultiselect = cm.isInMultiSelectMode();\n      if (vim.wasInVisualBlock && !wasMultiselect) {\n        vim.wasInVisualBlock = false;\n      } else if (wasMultiselect && vim.visualBlock) {\n         vim.wasInVisualBlock = true;\n      }\n\n      if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect && vim.status == \"<Esc>\") {\n        // allow editor to exit multiselect\n        clearInputState(cm);\n      } else if (visualBlock || !wasMultiselect || cm.inVirtualSelectionMode) {\n        isHandled = vimApi.handleKey(cm, key, origin);\n      } else {\n        var old = cloneVimState(vim);\n\n        cm.operation(function() {\n          cm.curOp.isVimOp = true;\n          cm.forEachSelection(function() {\n            var head = cm.getCursor(\"head\");\n            var anchor = cm.getCursor(\"anchor\");\n            var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n            var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n            head = offsetCursor(head, 0, headOffset);\n            anchor = offsetCursor(anchor, 0, anchorOffset);\n            cm.state.vim.sel.head = head;\n            cm.state.vim.sel.anchor = anchor;\n\n            isHandled = vimApi.handleKey(cm, key, origin);\n            if (cm.virtualSelection) {\n              cm.state.vim = cloneVimState(old);\n            }\n          });\n          if (cm.curOp.cursorActivity && !isHandled)\n            cm.curOp.cursorActivity = false;\n          cm.state.vim = vim;\n        }, true);\n      }\n      // some commands may bring visualMode and selection out of sync\n      if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n        handleExternalSelection(cm, vim);\n      }\n      return isHandled;\n    }\n    resetVimGlobalState();\n\n  return vimApi;\n}\n\nfunction initVim(CodeMirror5) {\r\n  CodeMirror5.Vim = initVim$1(CodeMirror5);\r\n  return CodeMirror5.Vim;\r\n}\n\n\n\n    CodeMirror.Vim = initVim(CodeMirror);\n  });\n  ","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var WORD = /[\\w$]+/, RANGE = 500;\n\n  CodeMirror.registerHelper(\"hint\", \"anyword\", function(editor, options) {\n    var word = options && options.word || WORD;\n    var range = options && options.range || RANGE;\n    var cur = editor.getCursor(), curLine = editor.getLine(cur.line);\n    var end = cur.ch, start = end;\n    while (start && word.test(curLine.charAt(start - 1))) --start;\n    var curWord = start != end && curLine.slice(start, end);\n\n    var list = options && options.list || [], seen = {};\n    var re = new RegExp(word.source, \"g\");\n    for (var dir = -1; dir <= 1; dir += 2) {\n      var line = cur.line, endLine = Math.min(Math.max(line + dir * range, editor.firstLine()), editor.lastLine()) + dir;\n      for (; line != endLine; line += dir) {\n        var text = editor.getLine(line), m;\n        while (m = re.exec(text)) {\n          if (line == cur.line && m[0] === curWord) continue;\n          if ((!curWord || m[0].lastIndexOf(curWord, 0) == 0) && !Object.prototype.hasOwnProperty.call(seen, m[0])) {\n            seen[m[0]] = true;\n            list.push(m[0]);\n          }\n        }\n      }\n    }\n    return {list: list, from: CodeMirror.Pos(cur.line, start), to: CodeMirror.Pos(cur.line, end)};\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var GUTTER_ID = \"CodeMirror-lint-markers\";\n  var LINT_LINE_ID = \"CodeMirror-lint-line-\";\n\n  function showTooltip(cm, e, content) {\n    var tt = document.createElement(\"div\");\n    tt.className = \"CodeMirror-lint-tooltip cm-s-\" + cm.options.theme;\n    tt.appendChild(content.cloneNode(true));\n    if (cm.state.lint.options.selfContain)\n      cm.getWrapperElement().appendChild(tt);\n    else\n      document.body.appendChild(tt);\n\n    function position(e) {\n      if (!tt.parentNode) return CodeMirror.off(document, \"mousemove\", position);\n      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + \"px\";\n      tt.style.left = (e.clientX + 5) + \"px\";\n    }\n    CodeMirror.on(document, \"mousemove\", position);\n    position(e);\n    if (tt.style.opacity != null) tt.style.opacity = 1;\n    return tt;\n  }\n  function rm(elt) {\n    if (elt.parentNode) elt.parentNode.removeChild(elt);\n  }\n  function hideTooltip(tt) {\n    if (!tt.parentNode) return;\n    if (tt.style.opacity == null) rm(tt);\n    tt.style.opacity = 0;\n    setTimeout(function() { rm(tt); }, 600);\n  }\n\n  function showTooltipFor(cm, e, content, node) {\n    var tooltip = showTooltip(cm, e, content);\n    function hide() {\n      CodeMirror.off(node, \"mouseout\", hide);\n      if (tooltip) { hideTooltip(tooltip); tooltip = null; }\n    }\n    var poll = setInterval(function() {\n      if (tooltip) for (var n = node;; n = n.parentNode) {\n        if (n && n.nodeType == 11) n = n.host;\n        if (n == document.body) return;\n        if (!n) { hide(); break; }\n      }\n      if (!tooltip) return clearInterval(poll);\n    }, 400);\n    CodeMirror.on(node, \"mouseout\", hide);\n  }\n\n  function LintState(cm, conf, hasGutter) {\n    this.marked = [];\n    if (conf instanceof Function) conf = {getAnnotations: conf};\n    if (!conf || conf === true) conf = {};\n    this.options = {};\n    this.linterOptions = conf.options || {};\n    for (var prop in defaults) this.options[prop] = defaults[prop];\n    for (var prop in conf) {\n      if (defaults.hasOwnProperty(prop)) {\n        if (conf[prop] != null) this.options[prop] = conf[prop];\n      } else if (!conf.options) {\n        this.linterOptions[prop] = conf[prop];\n      }\n    }\n    this.timeout = null;\n    this.hasGutter = hasGutter;\n    this.onMouseOver = function(e) { onMouseOver(cm, e); };\n    this.waitingFor = 0\n  }\n\n  var defaults = {\n    highlightLines: false,\n    tooltips: true,\n    delay: 500,\n    lintOnChange: true,\n    getAnnotations: null,\n    async: false,\n    selfContain: null,\n    formatAnnotation: null,\n    onUpdateLinting: null\n  }\n\n  function clearMarks(cm) {\n    var state = cm.state.lint;\n    if (state.hasGutter) cm.clearGutter(GUTTER_ID);\n    if (state.options.highlightLines) clearErrorLines(cm);\n    for (var i = 0; i < state.marked.length; ++i)\n      state.marked[i].clear();\n    state.marked.length = 0;\n  }\n\n  function clearErrorLines(cm) {\n    cm.eachLine(function(line) {\n      var has = line.wrapClass && /\\bCodeMirror-lint-line-\\w+\\b/.exec(line.wrapClass);\n      if (has) cm.removeLineClass(line, \"wrap\", has[0]);\n    })\n  }\n\n  function makeMarker(cm, labels, severity, multiple, tooltips) {\n    var marker = document.createElement(\"div\"), inner = marker;\n    marker.className = \"CodeMirror-lint-marker CodeMirror-lint-marker-\" + severity;\n    if (multiple) {\n      inner = marker.appendChild(document.createElement(\"div\"));\n      inner.className = \"CodeMirror-lint-marker CodeMirror-lint-marker-multiple\";\n    }\n\n    if (tooltips != false) CodeMirror.on(inner, \"mouseover\", function(e) {\n      showTooltipFor(cm, e, labels, inner);\n    });\n\n    return marker;\n  }\n\n  function getMaxSeverity(a, b) {\n    if (a == \"error\") return a;\n    else return b;\n  }\n\n  function groupByLine(annotations) {\n    var lines = [];\n    for (var i = 0; i < annotations.length; ++i) {\n      var ann = annotations[i], line = ann.from.line;\n      (lines[line] || (lines[line] = [])).push(ann);\n    }\n    return lines;\n  }\n\n  function annotationTooltip(ann) {\n    var severity = ann.severity;\n    if (!severity) severity = \"error\";\n    var tip = document.createElement(\"div\");\n    tip.className = \"CodeMirror-lint-message CodeMirror-lint-message-\" + severity;\n    if (typeof ann.messageHTML != 'undefined') {\n      tip.innerHTML = ann.messageHTML;\n    } else {\n      tip.appendChild(document.createTextNode(ann.message));\n    }\n    return tip;\n  }\n\n  function lintAsync(cm, getAnnotations) {\n    var state = cm.state.lint\n    var id = ++state.waitingFor\n    function abort() {\n      id = -1\n      cm.off(\"change\", abort)\n    }\n    cm.on(\"change\", abort)\n    getAnnotations(cm.getValue(), function(annotations, arg2) {\n      cm.off(\"change\", abort)\n      if (state.waitingFor != id) return\n      if (arg2 && annotations instanceof CodeMirror) annotations = arg2\n      cm.operation(function() {updateLinting(cm, annotations)})\n    }, state.linterOptions, cm);\n  }\n\n  function startLinting(cm) {\n    var state = cm.state.lint;\n    if (!state) return;\n    var options = state.options;\n    /*\n     * Passing rules in `options` property prevents JSHint (and other linters) from complaining\n     * about unrecognized rules like `onUpdateLinting`, `delay`, `lintOnChange`, etc.\n     */\n    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), \"lint\");\n    if (!getAnnotations) return;\n    if (options.async || getAnnotations.async) {\n      lintAsync(cm, getAnnotations)\n    } else {\n      var annotations = getAnnotations(cm.getValue(), state.linterOptions, cm);\n      if (!annotations) return;\n      if (annotations.then) annotations.then(function(issues) {\n        cm.operation(function() {updateLinting(cm, issues)})\n      });\n      else cm.operation(function() {updateLinting(cm, annotations)})\n    }\n  }\n\n  function updateLinting(cm, annotationsNotSorted) {\n    var state = cm.state.lint;\n    if (!state) return;\n    var options = state.options;\n    clearMarks(cm);\n\n    var annotations = groupByLine(annotationsNotSorted);\n\n    for (var line = 0; line < annotations.length; ++line) {\n      var anns = annotations[line];\n      if (!anns) continue;\n\n      // filter out duplicate messages\n      var message = [];\n      anns = anns.filter(function(item) { return message.indexOf(item.message) > -1 ? false : message.push(item.message) });\n\n      var maxSeverity = null;\n      var tipLabel = state.hasGutter && document.createDocumentFragment();\n\n      for (var i = 0; i < anns.length; ++i) {\n        var ann = anns[i];\n        var severity = ann.severity;\n        if (!severity) severity = \"error\";\n        maxSeverity = getMaxSeverity(maxSeverity, severity);\n\n        if (options.formatAnnotation) ann = options.formatAnnotation(ann);\n        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));\n\n        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {\n          className: \"CodeMirror-lint-mark CodeMirror-lint-mark-\" + severity,\n          __annotation: ann\n        }));\n      }\n      // use original annotations[line] to show multiple messages\n      if (state.hasGutter)\n        cm.setGutterMarker(line, GUTTER_ID, makeMarker(cm, tipLabel, maxSeverity, annotations[line].length > 1,\n                                                       options.tooltips));\n\n      if (options.highlightLines)\n        cm.addLineClass(line, \"wrap\", LINT_LINE_ID + maxSeverity);\n    }\n    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.lint;\n    if (!state) return;\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay);\n  }\n\n  function popupTooltips(cm, annotations, e) {\n    var target = e.target || e.srcElement;\n    var tooltip = document.createDocumentFragment();\n    for (var i = 0; i < annotations.length; i++) {\n      var ann = annotations[i];\n      tooltip.appendChild(annotationTooltip(ann));\n    }\n    showTooltipFor(cm, e, tooltip, target);\n  }\n\n  function onMouseOver(cm, e) {\n    var target = e.target || e.srcElement;\n    if (!/\\bCodeMirror-lint-mark-/.test(target.className)) return;\n    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;\n    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, \"client\"));\n\n    var annotations = [];\n    for (var i = 0; i < spans.length; ++i) {\n      var ann = spans[i].__annotation;\n      if (ann) annotations.push(ann);\n    }\n    if (annotations.length) popupTooltips(cm, annotations, e);\n  }\n\n  CodeMirror.defineOption(\"lint\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      clearMarks(cm);\n      if (cm.state.lint.options.lintOnChange !== false)\n        cm.off(\"change\", onChange);\n      CodeMirror.off(cm.getWrapperElement(), \"mouseover\", cm.state.lint.onMouseOver);\n      clearTimeout(cm.state.lint.timeout);\n      delete cm.state.lint;\n    }\n\n    if (val) {\n      var gutters = cm.getOption(\"gutters\"), hasLintGutter = false;\n      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;\n      var state = cm.state.lint = new LintState(cm, val, hasLintGutter);\n      if (state.options.lintOnChange)\n        cm.on(\"change\", onChange);\n      if (state.options.tooltips != false && state.options.tooltips != \"gutter\")\n        CodeMirror.on(cm.getWrapperElement(), \"mouseover\", state.onMouseOver);\n\n      startLinting(cm);\n    }\n  });\n\n  CodeMirror.defineExtension(\"performLint\", function() {\n    startLinting(this);\n  });\n});\n","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../@vue/cli-service/node_modules/css-loader/dist/cjs.js??ref--7-oneOf-3-1!../../postcss-loader/src/index.js??ref--7-oneOf-3-2!../../postcss-loader/src/index.js??ref--7-oneOf-3-3!./base16-dark.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"a9f2f270\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\", \"<\": \">>\", \">\": \"<<\"};\n\n  function bracketRegex(config) {\n    return config && config.bracketRegex || /[(){}[\\]]/\n  }\n\n  function findMatchingBracket(cm, where, config) {\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n    var afterCursor = config && config.afterCursor\n    if (afterCursor == null)\n      afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className)\n    var re = bracketRegex(config)\n\n    // A cursor is defined as between two characters, but in in vim command mode\n    // (i.e. not insert mode), the cursor is visually represented as a\n    // highlighted box on top of the 2nd character. Otherwise, we allow matches\n    // from before or after the cursor.\n    var match = (!afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)]) ||\n        re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (config && config.strict && (dir > 0) != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config);\n    if (found == null) return null;\n    return {from: Pos(where.line, pos), to: found && found.pos,\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\n  }\n\n  // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n\n    var stack = [];\n    var re = bracketRegex(config)\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n        if (re.test(ch) && (style === undefined ||\n                            (cm.getTokenTypeAt(Pos(lineNo, pos + 1)) || \"\") == (style || \"\"))) {\n          var match = matching[ch];\n          if (match && (match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n          else stack.pop();\n        }\n      }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000,\n      highlightNonMatching = config && config.highlightNonMatching;\n    var marks = [], ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);\n      if (match && (match.match || highlightNonMatching !== false) && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textarea whenever this fires.\n      if (ie_lt8 && cm.state.focused) cm.focus();\n\n      var clear = function() {\n        cm.operation(function() {\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\n        });\n      };\n      if (autoclear) setTimeout(clear, 800);\n      else return clear;\n    }\n  }\n\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (cm.state.matchBrackets.currentlyHighlighted) {\n        cm.state.matchBrackets.currentlyHighlighted();\n        cm.state.matchBrackets.currentlyHighlighted = null;\n      }\n      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  function clearHighlighted(cm) {\n    if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {\n      cm.state.matchBrackets.currentlyHighlighted();\n      cm.state.matchBrackets.currentlyHighlighted = null;\n    }\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.off(\"cursorActivity\", doMatchBrackets);\n      cm.off(\"focus\", doMatchBrackets)\n      cm.off(\"blur\", clearHighlighted)\n      clearHighlighted(cm);\n    }\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n      cm.on(\"focus\", doMatchBrackets)\n      cm.on(\"blur\", clearHighlighted)\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, config, oldConfig){\n    // Backwards-compatibility kludge\n    if (oldConfig || typeof config == \"boolean\") {\n      if (!oldConfig) {\n        config = config ? {strict: true} : null\n      } else {\n        oldConfig.strict = config\n        config = oldConfig\n      }\n    }\n    return findMatchingBracket(this, pos, config)\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});\n","// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../../../@vue/cli-service/node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \".CodeMirror-hints{position:absolute;z-index:10;overflow:hidden;list-style:none;margin:0;padding:2px;box-shadow:2px 3px 5px rgba(0,0,0,.2);border-radius:3px;border:1px solid silver;background:#fff;font-size:90%;font-family:monospace;max-height:20em;overflow-y:auto;box-sizing:border-box}.CodeMirror-hint{margin:0;padding:0 4px;border-radius:2px;white-space:pre;color:#000;cursor:pointer}li.CodeMirror-hint-active{background:#08f;color:#fff}\", \"\"]);\n// Exports\nmodule.exports = exports;\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// A rough approximation of Sublime Text's keybindings\n// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/edit/matchbrackets\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n\n  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.\n  function findPosSubword(doc, start, dir) {\n    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));\n    var line = doc.getLine(start.line);\n    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));\n    var state = \"start\", type, startPos = start.ch;\n    for (var pos = startPos, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n      var next = line.charAt(dir < 0 ? pos - 1 : pos);\n      var cat = next != \"_\" && CodeMirror.isWordChar(next) ? \"w\" : \"o\";\n      if (cat == \"w\" && next.toUpperCase() == next) cat = \"W\";\n      if (state == \"start\") {\n        if (cat != \"o\") { state = \"in\"; type = cat; }\n        else startPos = pos + dir\n      } else if (state == \"in\") {\n        if (type != cat) {\n          if (type == \"w\" && cat == \"W\" && dir < 0) pos--;\n          if (type == \"W\" && cat == \"w\" && dir > 0) { // From uppercase to lowercase\n            if (pos == startPos + 1) { type = \"w\"; continue; }\n            else pos--;\n          }\n          break;\n        }\n      }\n    }\n    return Pos(start.line, pos);\n  }\n\n  function moveSubword(cm, dir) {\n    cm.extendSelectionsBy(function(range) {\n      if (cm.display.shift || cm.doc.extend || range.empty())\n        return findPosSubword(cm.doc, range.head, dir);\n      else\n        return dir < 0 ? range.from() : range.to();\n    });\n  }\n\n  cmds.goSubwordLeft = function(cm) { moveSubword(cm, -1); };\n  cmds.goSubwordRight = function(cm) { moveSubword(cm, 1); };\n\n  cmds.scrollLineUp = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, \"local\");\n      if (cm.getCursor().line >= visibleBottomLine)\n        cm.execCommand(\"goLineUp\");\n    }\n    cm.scrollTo(null, info.top - cm.defaultTextHeight());\n  };\n  cmds.scrollLineDown = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleTopLine = cm.lineAtHeight(info.top, \"local\")+1;\n      if (cm.getCursor().line <= visibleTopLine)\n        cm.execCommand(\"goLineDown\");\n    }\n    cm.scrollTo(null, info.top + cm.defaultTextHeight());\n  };\n\n  cmds.splitSelectionByLine = function(cm) {\n    var ranges = cm.listSelections(), lineRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      for (var line = from.line; line <= to.line; ++line)\n        if (!(to.line > from.line && line == to.line && to.ch == 0))\n          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),\n                           head: line == to.line ? to : Pos(line)});\n    }\n    cm.setSelections(lineRanges, 0);\n  };\n\n  cmds.singleSelectionTop = function(cm) {\n    var range = cm.listSelections()[0];\n    cm.setSelection(range.anchor, range.head, {scroll: false});\n  };\n\n  cmds.selectLine = function(cm) {\n    var ranges = cm.listSelections(), extended = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      extended.push({anchor: Pos(range.from().line, 0),\n                     head: Pos(range.to().line + 1, 0)});\n    }\n    cm.setSelections(extended);\n  };\n\n  function insertLine(cm, above) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    cm.operation(function() {\n      var len = cm.listSelections().length, newSelection = [], last = -1;\n      for (var i = 0; i < len; i++) {\n        var head = cm.listSelections()[i].head;\n        if (head.line <= last) continue;\n        var at = Pos(head.line + (above ? 0 : 1), 0);\n        cm.replaceRange(\"\\n\", at, null, \"+insertLine\");\n        cm.indentLine(at.line, null, true);\n        newSelection.push({head: at, anchor: at});\n        last = head.line + 1;\n      }\n      cm.setSelections(newSelection);\n    });\n    cm.execCommand(\"indentAuto\");\n  }\n\n  cmds.insertLineAfter = function(cm) { return insertLine(cm, false); };\n\n  cmds.insertLineBefore = function(cm) { return insertLine(cm, true); };\n\n  function wordAt(cm, pos) {\n    var start = pos.ch, end = start, line = cm.getLine(pos.line);\n    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;\n    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};\n  }\n\n  cmds.selectNextOccurrence = function(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      cm.setSelection(word.from, word.to);\n      fullWord = true;\n    } else {\n      var text = cm.getRange(from, to);\n      var query = fullWord ? new RegExp(\"\\\\b\" + text + \"\\\\b\") : text;\n      var cur = cm.getSearchCursor(query, to);\n      var found = cur.findNext();\n      if (!found) {\n        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n        found = cur.findNext();\n      }\n      if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to())) return\n      cm.addSelection(cur.from(), cur.to());\n    }\n    if (fullWord)\n      cm.state.sublimeFindFullWord = cm.doc.sel;\n  };\n\n  cmds.skipAndSelectNextOccurrence = function(cm) {\n    var prevAnchor = cm.getCursor(\"anchor\"), prevHead = cm.getCursor(\"head\");\n    cmds.selectNextOccurrence(cm);\n    if (CodeMirror.cmpPos(prevAnchor, prevHead) != 0) {\n      cm.doc.setSelections(cm.doc.listSelections()\n          .filter(function (sel) {\n            return sel.anchor != prevAnchor || sel.head != prevHead;\n          }));\n    }\n  }\n\n  function addCursorToSelection(cm, dir) {\n    var ranges = cm.listSelections(), newRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      var newAnchor = cm.findPosV(\n          range.anchor, dir, \"line\", range.anchor.goalColumn);\n      var newHead = cm.findPosV(\n          range.head, dir, \"line\", range.head.goalColumn);\n      newAnchor.goalColumn = range.anchor.goalColumn != null ?\n          range.anchor.goalColumn : cm.cursorCoords(range.anchor, \"div\").left;\n      newHead.goalColumn = range.head.goalColumn != null ?\n          range.head.goalColumn : cm.cursorCoords(range.head, \"div\").left;\n      var newRange = {anchor: newAnchor, head: newHead};\n      newRanges.push(range);\n      newRanges.push(newRange);\n    }\n    cm.setSelections(newRanges);\n  }\n  cmds.addCursorToPrevLine = function(cm) { addCursorToSelection(cm, -1); };\n  cmds.addCursorToNextLine = function(cm) { addCursorToSelection(cm, 1); };\n\n  function isSelectedRange(ranges, from, to) {\n    for (var i = 0; i < ranges.length; i++)\n      if (CodeMirror.cmpPos(ranges[i].from(), from) == 0 &&\n          CodeMirror.cmpPos(ranges[i].to(), to) == 0) return true\n    return false\n  }\n\n  var mirror = \"(){}[]\";\n  function selectBetweenBrackets(cm) {\n    var ranges = cm.listSelections(), newRanges = []\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], pos = range.head, opening = cm.scanForBracket(pos, -1);\n      if (!opening) return false;\n      for (;;) {\n        var closing = cm.scanForBracket(pos, 1);\n        if (!closing) return false;\n        if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n          var startPos = Pos(opening.pos.line, opening.pos.ch + 1);\n          if (CodeMirror.cmpPos(startPos, range.from()) == 0 &&\n              CodeMirror.cmpPos(closing.pos, range.to()) == 0) {\n            opening = cm.scanForBracket(opening.pos, -1);\n            if (!opening) return false;\n          } else {\n            newRanges.push({anchor: startPos, head: closing.pos});\n            break;\n          }\n        }\n        pos = Pos(closing.pos.line, closing.pos.ch + 1);\n      }\n    }\n    cm.setSelections(newRanges);\n    return true;\n  }\n\n  cmds.selectScope = function(cm) {\n    selectBetweenBrackets(cm) || cm.execCommand(\"selectAll\");\n  };\n  cmds.selectBetweenBrackets = function(cm) {\n    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;\n  };\n\n  function puncType(type) {\n    return !type ? null : /\\bpunctuation\\b/.test(type) ? type : undefined\n  }\n\n  cmds.goToBracket = function(cm) {\n    cm.extendSelectionsBy(function(range) {\n      var next = cm.scanForBracket(range.head, 1, puncType(cm.getTokenTypeAt(range.head)));\n      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;\n      var prev = cm.scanForBracket(range.head, -1, puncType(cm.getTokenTypeAt(Pos(range.head.line, range.head.ch + 1))));\n      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\n    });\n  };\n\n  cmds.swapLineUp = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from().line - 1, to = range.to().line;\n      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),\n                    head: Pos(range.head.line - 1, range.head.ch)});\n      if (range.to().ch == 0 && !range.empty()) --to;\n      if (from > at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = 0; i < linesToMove.length; i += 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        if (to > cm.lastLine())\n          cm.replaceRange(\"\\n\" + line, Pos(cm.lastLine()), null, \"+swapLine\");\n        else\n          cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.setSelections(newSels);\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.swapLineDown = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var range = ranges[i], from = range.to().line + 1, to = range.from().line;\n      if (range.to().ch == 0 && !range.empty()) from--;\n      if (from < at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        if (from == cm.lastLine())\n          cm.replaceRange(\"\", Pos(from - 1), Pos(from), \"+swapLine\");\n        else\n          cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.toggleCommentIndented = function(cm) {\n    cm.toggleComment({ indent: true });\n  }\n\n  cmds.joinLines = function(cm) {\n    var ranges = cm.listSelections(), joined = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from();\n      var start = from.line, end = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)\n        end = ranges[++i].to().line;\n      joined.push({start: start, end: end, anchor: !range.empty() && from});\n    }\n    cm.operation(function() {\n      var offset = 0, ranges = [];\n      for (var i = 0; i < joined.length; i++) {\n        var obj = joined[i];\n        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\n        for (var line = obj.start; line <= obj.end; line++) {\n          var actual = line - offset;\n          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);\n          if (actual < cm.lastLine()) {\n            cm.replaceRange(\" \", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n            ++offset;\n          }\n        }\n        ranges.push({anchor: anchor || head, head: head});\n      }\n      cm.setSelections(ranges, 0);\n    });\n  };\n\n  cmds.duplicateLine = function(cm) {\n    cm.operation(function() {\n      var rangeCount = cm.listSelections().length;\n      for (var i = 0; i < rangeCount; i++) {\n        var range = cm.listSelections()[i];\n        if (range.empty())\n          cm.replaceRange(cm.getLine(range.head.line) + \"\\n\", Pos(range.head.line, 0));\n        else\n          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n\n  function sortLines(cm, caseSensitive, direction) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), toSort = [], selected;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      if (range.empty()) continue;\n      var from = range.from().line, to = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\n        to = ranges[++i].to().line;\n      if (!ranges[i].to().ch) to--;\n      toSort.push(from, to);\n    }\n    if (toSort.length) selected = true;\n    else toSort.push(cm.firstLine(), cm.lastLine());\n\n    cm.operation(function() {\n      var ranges = [];\n      for (var i = 0; i < toSort.length; i += 2) {\n        var from = toSort[i], to = toSort[i + 1];\n        var start = Pos(from, 0), end = Pos(to);\n        var lines = cm.getRange(start, end, false);\n        if (caseSensitive)\n          lines.sort(function(a, b) { return a < b ? -direction : a == b ? 0 : direction; });\n        else\n          lines.sort(function(a, b) {\n            var au = a.toUpperCase(), bu = b.toUpperCase();\n            if (au != bu) { a = au; b = bu; }\n            return a < b ? -direction : a == b ? 0 : direction;\n          });\n        cm.replaceRange(lines, start, end);\n        if (selected) ranges.push({anchor: start, head: Pos(to + 1, 0)});\n      }\n      if (selected) cm.setSelections(ranges, 0);\n    });\n  }\n\n  cmds.sortLines = function(cm) { sortLines(cm, true, 1); };\n  cmds.reverseSortLines = function(cm) { sortLines(cm, true, -1); };\n  cmds.sortLinesInsensitive = function(cm) { sortLines(cm, false, 1); };\n  cmds.reverseSortLinesInsensitive = function(cm) { sortLines(cm, false, -1); };\n\n  cmds.nextBookmark = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      var current = marks.shift();\n      var found = current.find();\n      if (found) {\n        marks.push(current);\n        return cm.setSelection(found.from, found.to);\n      }\n    }\n  };\n\n  cmds.prevBookmark = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      marks.unshift(marks.pop());\n      var found = marks[marks.length - 1].find();\n      if (!found)\n        marks.pop();\n      else\n        return cm.setSelection(found.from, found.to);\n    }\n  };\n\n  cmds.toggleBookmark = function(cm) {\n    var ranges = cm.listSelections();\n    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      var found = ranges[i].empty() ? cm.findMarksAt(from) : cm.findMarks(from, to);\n      for (var j = 0; j < found.length; j++) {\n        if (found[j].sublimeBookmark) {\n          found[j].clear();\n          for (var k = 0; k < marks.length; k++)\n            if (marks[k] == found[j])\n              marks.splice(k--, 1);\n          break;\n        }\n      }\n      if (j == found.length)\n        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));\n    }\n  };\n\n  cmds.clearBookmarks = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n    marks.length = 0;\n  };\n\n  cmds.selectBookmarks = function(cm) {\n    var marks = cm.state.sublimeBookmarks, ranges = [];\n    if (marks) for (var i = 0; i < marks.length; i++) {\n      var found = marks[i].find();\n      if (!found)\n        marks.splice(i--, 0);\n      else\n        ranges.push({anchor: found.from, head: found.to});\n    }\n    if (ranges.length)\n      cm.setSelections(ranges, 0);\n  };\n\n  function modifyWordOrSelection(cm, mod) {\n    cm.operation(function() {\n      var ranges = cm.listSelections(), indices = [], replacements = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.empty()) { indices.push(i); replacements.push(\"\"); }\n        else replacements.push(mod(cm.getRange(range.from(), range.to())));\n      }\n      cm.replaceSelections(replacements, \"around\", \"case\");\n      for (var i = indices.length - 1, at; i >= 0; i--) {\n        var range = ranges[indices[i]];\n        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;\n        var word = wordAt(cm, range.head);\n        at = word.from;\n        cm.replaceRange(mod(word.word), word.from, word.to);\n      }\n    });\n  }\n\n  cmds.smartBackspace = function(cm) {\n    if (cm.somethingSelected()) return CodeMirror.Pass;\n\n    cm.operation(function() {\n      var cursors = cm.listSelections();\n      var indentUnit = cm.getOption(\"indentUnit\");\n\n      for (var i = cursors.length - 1; i >= 0; i--) {\n        var cursor = cursors[i].head;\n        var toStartOfLine = cm.getRange({line: cursor.line, ch: 0}, cursor);\n        var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption(\"tabSize\"));\n\n        // Delete by one character by default\n        var deletePos = cm.findPosH(cursor, -1, \"char\", false);\n\n        if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n          var prevIndent = new Pos(cursor.line,\n            CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));\n\n          // Smart delete only if we found a valid prevIndent location\n          if (prevIndent.ch != cursor.ch) deletePos = prevIndent;\n        }\n\n        cm.replaceRange(\"\", deletePos, cursor, \"+delete\");\n      }\n    });\n  };\n\n  cmds.delLineRight = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = ranges.length - 1; i >= 0; i--)\n        cm.replaceRange(\"\", ranges[i].anchor, Pos(ranges[i].to().line), \"+delete\");\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.upcaseAtCursor = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });\n  };\n  cmds.downcaseAtCursor = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });\n  };\n\n  cmds.setSublimeMark = function(cm) {\n    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();\n    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n  };\n  cmds.selectToSublimeMark = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) cm.setSelection(cm.getCursor(), found);\n  };\n  cmds.deleteToSublimeMark = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      var from = cm.getCursor(), to = found;\n      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }\n      cm.state.sublimeKilled = cm.getRange(from, to);\n      cm.replaceRange(\"\", from, to);\n    }\n  };\n  cmds.swapWithSublimeMark = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      cm.state.sublimeMark.clear();\n      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n      cm.setCursor(found);\n    }\n  };\n  cmds.sublimeYank = function(cm) {\n    if (cm.state.sublimeKilled != null)\n      cm.replaceSelection(cm.state.sublimeKilled, null, \"paste\");\n  };\n\n  cmds.showInCenter = function(cm) {\n    var pos = cm.cursorCoords(null, \"local\");\n    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n  };\n\n  function getTarget(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      from = word.from;\n      to = word.to;\n    }\n    return {from: from, to: to, query: cm.getRange(from, to), word: word};\n  }\n\n  function findAndGoTo(cm, forward) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var query = target.query;\n    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\n\n    if (forward ? cur.findNext() : cur.findPrevious()) {\n      cm.setSelection(cur.from(), cur.to());\n    } else {\n      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)\n                                              : cm.clipPos(Pos(cm.lastLine())));\n      if (forward ? cur.findNext() : cur.findPrevious())\n        cm.setSelection(cur.from(), cur.to());\n      else if (target.word)\n        cm.setSelection(target.from, target.to);\n    }\n  };\n  cmds.findUnder = function(cm) { findAndGoTo(cm, true); };\n  cmds.findUnderPrevious = function(cm) { findAndGoTo(cm,false); };\n  cmds.findAllUnder = function(cm) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var cur = cm.getSearchCursor(target.query);\n    var matches = [];\n    var primaryIndex = -1;\n    while (cur.findNext()) {\n      matches.push({anchor: cur.from(), head: cur.to()});\n      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)\n        primaryIndex++;\n    }\n    cm.setSelections(matches, primaryIndex);\n  };\n\n\n  var keyMap = CodeMirror.keyMap;\n  keyMap.macSublime = {\n    \"Cmd-Left\": \"goLineStartSmart\",\n    \"Shift-Tab\": \"indentLess\",\n    \"Shift-Ctrl-K\": \"deleteLine\",\n    \"Alt-Q\": \"wrapLines\",\n    \"Ctrl-Left\": \"goSubwordLeft\",\n    \"Ctrl-Right\": \"goSubwordRight\",\n    \"Ctrl-Alt-Up\": \"scrollLineUp\",\n    \"Ctrl-Alt-Down\": \"scrollLineDown\",\n    \"Cmd-L\": \"selectLine\",\n    \"Shift-Cmd-L\": \"splitSelectionByLine\",\n    \"Esc\": \"singleSelectionTop\",\n    \"Cmd-Enter\": \"insertLineAfter\",\n    \"Shift-Cmd-Enter\": \"insertLineBefore\",\n    \"Cmd-D\": \"selectNextOccurrence\",\n    \"Shift-Cmd-Space\": \"selectScope\",\n    \"Shift-Cmd-M\": \"selectBetweenBrackets\",\n    \"Cmd-M\": \"goToBracket\",\n    \"Cmd-Ctrl-Up\": \"swapLineUp\",\n    \"Cmd-Ctrl-Down\": \"swapLineDown\",\n    \"Cmd-/\": \"toggleCommentIndented\",\n    \"Cmd-J\": \"joinLines\",\n    \"Shift-Cmd-D\": \"duplicateLine\",\n    \"F5\": \"sortLines\",\n    \"Shift-F5\": \"reverseSortLines\",\n    \"Cmd-F5\": \"sortLinesInsensitive\",\n    \"Shift-Cmd-F5\": \"reverseSortLinesInsensitive\",\n    \"F2\": \"nextBookmark\",\n    \"Shift-F2\": \"prevBookmark\",\n    \"Cmd-F2\": \"toggleBookmark\",\n    \"Shift-Cmd-F2\": \"clearBookmarks\",\n    \"Alt-F2\": \"selectBookmarks\",\n    \"Backspace\": \"smartBackspace\",\n    \"Cmd-K Cmd-D\": \"skipAndSelectNextOccurrence\",\n    \"Cmd-K Cmd-K\": \"delLineRight\",\n    \"Cmd-K Cmd-U\": \"upcaseAtCursor\",\n    \"Cmd-K Cmd-L\": \"downcaseAtCursor\",\n    \"Cmd-K Cmd-Space\": \"setSublimeMark\",\n    \"Cmd-K Cmd-A\": \"selectToSublimeMark\",\n    \"Cmd-K Cmd-W\": \"deleteToSublimeMark\",\n    \"Cmd-K Cmd-X\": \"swapWithSublimeMark\",\n    \"Cmd-K Cmd-Y\": \"sublimeYank\",\n    \"Cmd-K Cmd-C\": \"showInCenter\",\n    \"Cmd-K Cmd-G\": \"clearBookmarks\",\n    \"Cmd-K Cmd-Backspace\": \"delLineLeft\",\n    \"Cmd-K Cmd-1\": \"foldAll\",\n    \"Cmd-K Cmd-0\": \"unfoldAll\",\n    \"Cmd-K Cmd-J\": \"unfoldAll\",\n    \"Ctrl-Shift-Up\": \"addCursorToPrevLine\",\n    \"Ctrl-Shift-Down\": \"addCursorToNextLine\",\n    \"Cmd-F3\": \"findUnder\",\n    \"Shift-Cmd-F3\": \"findUnderPrevious\",\n    \"Alt-F3\": \"findAllUnder\",\n    \"Shift-Cmd-[\": \"fold\",\n    \"Shift-Cmd-]\": \"unfold\",\n    \"Cmd-I\": \"findIncremental\",\n    \"Shift-Cmd-I\": \"findIncrementalReverse\",\n    \"Cmd-H\": \"replace\",\n    \"F3\": \"findNext\",\n    \"Shift-F3\": \"findPrev\",\n    \"fallthrough\": \"macDefault\"\n  };\n  CodeMirror.normalizeKeyMap(keyMap.macSublime);\n\n  keyMap.pcSublime = {\n    \"Shift-Tab\": \"indentLess\",\n    \"Shift-Ctrl-K\": \"deleteLine\",\n    \"Alt-Q\": \"wrapLines\",\n    \"Ctrl-T\": \"transposeChars\",\n    \"Alt-Left\": \"goSubwordLeft\",\n    \"Alt-Right\": \"goSubwordRight\",\n    \"Ctrl-Up\": \"scrollLineUp\",\n    \"Ctrl-Down\": \"scrollLineDown\",\n    \"Ctrl-L\": \"selectLine\",\n    \"Shift-Ctrl-L\": \"splitSelectionByLine\",\n    \"Esc\": \"singleSelectionTop\",\n    \"Ctrl-Enter\": \"insertLineAfter\",\n    \"Shift-Ctrl-Enter\": \"insertLineBefore\",\n    \"Ctrl-D\": \"selectNextOccurrence\",\n    \"Shift-Ctrl-Space\": \"selectScope\",\n    \"Shift-Ctrl-M\": \"selectBetweenBrackets\",\n    \"Ctrl-M\": \"goToBracket\",\n    \"Shift-Ctrl-Up\": \"swapLineUp\",\n    \"Shift-Ctrl-Down\": \"swapLineDown\",\n    \"Ctrl-/\": \"toggleCommentIndented\",\n    \"Ctrl-J\": \"joinLines\",\n    \"Shift-Ctrl-D\": \"duplicateLine\",\n    \"F9\": \"sortLines\",\n    \"Shift-F9\": \"reverseSortLines\",\n    \"Ctrl-F9\": \"sortLinesInsensitive\",\n    \"Shift-Ctrl-F9\": \"reverseSortLinesInsensitive\",\n    \"F2\": \"nextBookmark\",\n    \"Shift-F2\": \"prevBookmark\",\n    \"Ctrl-F2\": \"toggleBookmark\",\n    \"Shift-Ctrl-F2\": \"clearBookmarks\",\n    \"Alt-F2\": \"selectBookmarks\",\n    \"Backspace\": \"smartBackspace\",\n    \"Ctrl-K Ctrl-D\": \"skipAndSelectNextOccurrence\",\n    \"Ctrl-K Ctrl-K\": \"delLineRight\",\n    \"Ctrl-K Ctrl-U\": \"upcaseAtCursor\",\n    \"Ctrl-K Ctrl-L\": \"downcaseAtCursor\",\n    \"Ctrl-K Ctrl-Space\": \"setSublimeMark\",\n    \"Ctrl-K Ctrl-A\": \"selectToSublimeMark\",\n    \"Ctrl-K Ctrl-W\": \"deleteToSublimeMark\",\n    \"Ctrl-K Ctrl-X\": \"swapWithSublimeMark\",\n    \"Ctrl-K Ctrl-Y\": \"sublimeYank\",\n    \"Ctrl-K Ctrl-C\": \"showInCenter\",\n    \"Ctrl-K Ctrl-G\": \"clearBookmarks\",\n    \"Ctrl-K Ctrl-Backspace\": \"delLineLeft\",\n    \"Ctrl-K Ctrl-1\": \"foldAll\",\n    \"Ctrl-K Ctrl-0\": \"unfoldAll\",\n    \"Ctrl-K Ctrl-J\": \"unfoldAll\",\n    \"Ctrl-Alt-Up\": \"addCursorToPrevLine\",\n    \"Ctrl-Alt-Down\": \"addCursorToNextLine\",\n    \"Ctrl-F3\": \"findUnder\",\n    \"Shift-Ctrl-F3\": \"findUnderPrevious\",\n    \"Alt-F3\": \"findAllUnder\",\n    \"Shift-Ctrl-[\": \"fold\",\n    \"Shift-Ctrl-]\": \"unfold\",\n    \"Ctrl-I\": \"findIncremental\",\n    \"Shift-Ctrl-I\": \"findIncrementalReverse\",\n    \"Ctrl-H\": \"replace\",\n    \"F3\": \"findNext\",\n    \"Shift-F3\": \"findPrev\",\n    \"fallthrough\": \"pcDefault\"\n  };\n  CodeMirror.normalizeKeyMap(keyMap.pcSublime);\n\n  var mac = keyMap.default == keyMap.macDefault;\n  keyMap.sublime = mac ? keyMap.macSublime : keyMap.pcSublime;\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// declare global: DOMRect\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var HINT_ELEMENT_CLASS        = \"CodeMirror-hint\";\n  var ACTIVE_HINT_ELEMENT_CLASS = \"CodeMirror-hint-active\";\n\n  // This is the old interface, kept around for now to stay\n  // backwards-compatible.\n  CodeMirror.showHint = function(cm, getHints, options) {\n    if (!getHints) return cm.showHint(options);\n    if (options && options.async) getHints.async = true;\n    var newOpts = {hint: getHints};\n    if (options) for (var prop in options) newOpts[prop] = options[prop];\n    return cm.showHint(newOpts);\n  };\n\n  CodeMirror.defineExtension(\"showHint\", function(options) {\n    options = parseOptions(this, this.getCursor(\"start\"), options);\n    var selections = this.listSelections()\n    if (selections.length > 1) return;\n    // By default, don't allow completion when something is selected.\n    // A hint function can have a `supportsSelection` property to\n    // indicate that it can handle selections.\n    if (this.somethingSelected()) {\n      if (!options.hint.supportsSelection) return;\n      // Don't try with cross-line selections\n      for (var i = 0; i < selections.length; i++)\n        if (selections[i].head.line != selections[i].anchor.line) return;\n    }\n\n    if (this.state.completionActive) this.state.completionActive.close();\n    var completion = this.state.completionActive = new Completion(this, options);\n    if (!completion.options.hint) return;\n\n    CodeMirror.signal(this, \"startCompletion\", this);\n    completion.update(true);\n  });\n\n  CodeMirror.defineExtension(\"closeHint\", function() {\n    if (this.state.completionActive) this.state.completionActive.close()\n  })\n\n  function Completion(cm, options) {\n    this.cm = cm;\n    this.options = options;\n    this.widget = null;\n    this.debounce = 0;\n    this.tick = 0;\n    this.startPos = this.cm.getCursor(\"start\");\n    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;\n\n    if (this.options.updateOnCursorActivity) {\n      var self = this;\n      cm.on(\"cursorActivity\", this.activityFunc = function() { self.cursorActivity(); });\n    }\n  }\n\n  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {\n    return setTimeout(fn, 1000/60);\n  };\n  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n\n  Completion.prototype = {\n    close: function() {\n      if (!this.active()) return;\n      this.cm.state.completionActive = null;\n      this.tick = null;\n      if (this.options.updateOnCursorActivity) {\n        this.cm.off(\"cursorActivity\", this.activityFunc);\n      }\n\n      if (this.widget && this.data) CodeMirror.signal(this.data, \"close\");\n      if (this.widget) this.widget.close();\n      CodeMirror.signal(this.cm, \"endCompletion\", this.cm);\n    },\n\n    active: function() {\n      return this.cm.state.completionActive == this;\n    },\n\n    pick: function(data, i) {\n      var completion = data.list[i], self = this;\n      this.cm.operation(function() {\n        if (completion.hint)\n          completion.hint(self.cm, data, completion);\n        else\n          self.cm.replaceRange(getText(completion), completion.from || data.from,\n                               completion.to || data.to, \"complete\");\n        CodeMirror.signal(data, \"pick\", completion);\n        self.cm.scrollIntoView();\n      });\n      if (this.options.closeOnPick) {\n        this.close();\n      }\n    },\n\n    cursorActivity: function() {\n      if (this.debounce) {\n        cancelAnimationFrame(this.debounce);\n        this.debounce = 0;\n      }\n\n      var identStart = this.startPos;\n      if(this.data) {\n        identStart = this.data.from;\n      }\n\n      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);\n      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||\n          pos.ch < identStart.ch || this.cm.somethingSelected() ||\n          (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {\n        this.close();\n      } else {\n        var self = this;\n        this.debounce = requestAnimationFrame(function() {self.update();});\n        if (this.widget) this.widget.disable();\n      }\n    },\n\n    update: function(first) {\n      if (this.tick == null) return\n      var self = this, myTick = ++this.tick\n      fetchHints(this.options.hint, this.cm, this.options, function(data) {\n        if (self.tick == myTick) self.finishUpdate(data, first)\n      })\n    },\n\n    finishUpdate: function(data, first) {\n      if (this.data) CodeMirror.signal(this.data, \"update\");\n\n      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);\n      if (this.widget) this.widget.close();\n\n      this.data = data;\n\n      if (data && data.list.length) {\n        if (picked && data.list.length == 1) {\n          this.pick(data, 0);\n        } else {\n          this.widget = new Widget(this, data);\n          CodeMirror.signal(data, \"shown\");\n        }\n      }\n    }\n  };\n\n  function parseOptions(cm, pos, options) {\n    var editor = cm.options.hintOptions;\n    var out = {};\n    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];\n    if (editor) for (var prop in editor)\n      if (editor[prop] !== undefined) out[prop] = editor[prop];\n    if (options) for (var prop in options)\n      if (options[prop] !== undefined) out[prop] = options[prop];\n    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)\n    return out;\n  }\n\n  function getText(completion) {\n    if (typeof completion == \"string\") return completion;\n    else return completion.text;\n  }\n\n  function buildKeyMap(completion, handle) {\n    var baseMap = {\n      Up: function() {handle.moveFocus(-1);},\n      Down: function() {handle.moveFocus(1);},\n      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},\n      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},\n      Home: function() {handle.setFocus(0);},\n      End: function() {handle.setFocus(handle.length - 1);},\n      Enter: handle.pick,\n      Tab: handle.pick,\n      Esc: handle.close\n    };\n\n    var mac = /Mac/.test(navigator.platform);\n\n    if (mac) {\n      baseMap[\"Ctrl-P\"] = function() {handle.moveFocus(-1);};\n      baseMap[\"Ctrl-N\"] = function() {handle.moveFocus(1);};\n    }\n\n    var custom = completion.options.customKeys;\n    var ourMap = custom ? {} : baseMap;\n    function addBinding(key, val) {\n      var bound;\n      if (typeof val != \"string\")\n        bound = function(cm) { return val(cm, handle); };\n      // This mechanism is deprecated\n      else if (baseMap.hasOwnProperty(val))\n        bound = baseMap[val];\n      else\n        bound = val;\n      ourMap[key] = bound;\n    }\n    if (custom)\n      for (var key in custom) if (custom.hasOwnProperty(key))\n        addBinding(key, custom[key]);\n    var extra = completion.options.extraKeys;\n    if (extra)\n      for (var key in extra) if (extra.hasOwnProperty(key))\n        addBinding(key, extra[key]);\n    return ourMap;\n  }\n\n  function getHintElement(hintsElement, el) {\n    while (el && el != hintsElement) {\n      if (el.nodeName.toUpperCase() === \"LI\" && el.parentNode == hintsElement) return el;\n      el = el.parentNode;\n    }\n  }\n\n  function Widget(completion, data) {\n    this.id = \"cm-complete-\" + Math.floor(Math.random(1e6))\n    this.completion = completion;\n    this.data = data;\n    this.picked = false;\n    var widget = this, cm = completion.cm;\n    var ownerDocument = cm.getInputField().ownerDocument;\n    var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;\n\n    var hints = this.hints = ownerDocument.createElement(\"ul\");\n    hints.setAttribute(\"role\", \"listbox\")\n    hints.setAttribute(\"aria-expanded\", \"true\")\n    hints.id = this.id\n    var theme = completion.cm.options.theme;\n    hints.className = \"CodeMirror-hints \" + theme;\n    this.selectedHint = data.selectedHint || 0;\n\n    var completions = data.list;\n    for (var i = 0; i < completions.length; ++i) {\n      var elt = hints.appendChild(ownerDocument.createElement(\"li\")), cur = completions[i];\n      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? \"\" : \" \" + ACTIVE_HINT_ELEMENT_CLASS);\n      if (cur.className != null) className = cur.className + \" \" + className;\n      elt.className = className;\n      if (i == this.selectedHint) elt.setAttribute(\"aria-selected\", \"true\")\n      elt.id = this.id + \"-\" + i\n      elt.setAttribute(\"role\", \"option\")\n      if (cur.render) cur.render(elt, data, cur);\n      else elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));\n      elt.hintId = i;\n    }\n\n    var container = completion.options.container || ownerDocument.body;\n    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);\n    var left = pos.left, top = pos.bottom, below = true;\n    var offsetLeft = 0, offsetTop = 0;\n    if (container !== ownerDocument.body) {\n      // We offset the cursor position because left and top are relative to the offsetParent's top left corner.\n      var isContainerPositioned = ['absolute', 'relative', 'fixed'].indexOf(parentWindow.getComputedStyle(container).position) !== -1;\n      var offsetParent = isContainerPositioned ? container : container.offsetParent;\n      var offsetParentPosition = offsetParent.getBoundingClientRect();\n      var bodyPosition = ownerDocument.body.getBoundingClientRect();\n      offsetLeft = (offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft);\n      offsetTop = (offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop);\n    }\n    hints.style.left = (left - offsetLeft) + \"px\";\n    hints.style.top = (top - offsetTop) + \"px\";\n\n    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.\n    var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);\n    var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);\n    container.appendChild(hints);\n    cm.getInputField().setAttribute(\"aria-autocomplete\", \"list\")\n    cm.getInputField().setAttribute(\"aria-owns\", this.id)\n    cm.getInputField().setAttribute(\"aria-activedescendant\", this.id + \"-\" + this.selectedHint)\n\n    var box = completion.options.moveOnOverlap ? hints.getBoundingClientRect() : new DOMRect();\n    var scrolls = completion.options.paddingForScrollbar ? hints.scrollHeight > hints.clientHeight + 1 : false;\n\n    // Compute in the timeout to avoid reflow on init\n    var startScroll;\n    setTimeout(function() { startScroll = cm.getScrollInfo(); });\n\n    var overlapY = box.bottom - winH;\n    if (overlapY > 0) { // Does not fit below\n      var height = box.bottom - box.top, spaceAbove = box.top - (pos.bottom - pos.top) - 2\n      if (winH - box.top < spaceAbove) { // More room at the top\n        if (height > spaceAbove) hints.style.height = (height = spaceAbove) + \"px\";\n        hints.style.top = ((top = pos.top - height) + offsetTop) + \"px\";\n        below = false;\n      } else {\n        hints.style.height = (winH - box.top - 2) + \"px\";\n      }\n    }\n    var overlapX = box.right - winW;\n    if (scrolls) overlapX += cm.display.nativeBarWidth;\n    if (overlapX > 0) {\n      if (box.right - box.left > winW) {\n        hints.style.width = (winW - 5) + \"px\";\n        overlapX -= (box.right - box.left) - winW;\n      }\n      hints.style.left = (left = Math.max(pos.left - overlapX - offsetLeft, 0)) + \"px\";\n    }\n    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)\n      node.style.paddingRight = cm.display.nativeBarWidth + \"px\"\n\n    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {\n      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },\n      setFocus: function(n) { widget.changeActive(n); },\n      menuSize: function() { return widget.screenAmount(); },\n      length: completions.length,\n      close: function() { completion.close(); },\n      pick: function() { widget.pick(); },\n      data: data\n    }));\n\n    if (completion.options.closeOnUnfocus) {\n      var closingOnBlur;\n      cm.on(\"blur\", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });\n      cm.on(\"focus\", this.onFocus = function() { clearTimeout(closingOnBlur); });\n    }\n\n    cm.on(\"scroll\", this.onScroll = function() {\n      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();\n      if (!startScroll) startScroll = cm.getScrollInfo();\n      var newTop = top + startScroll.top - curScroll.top;\n      var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);\n      if (!below) point += hints.offsetHeight;\n      if (point <= editor.top || point >= editor.bottom) return completion.close();\n      hints.style.top = newTop + \"px\";\n      hints.style.left = (left + startScroll.left - curScroll.left) + \"px\";\n    });\n\n    CodeMirror.on(hints, \"dblclick\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}\n    });\n\n    CodeMirror.on(hints, \"click\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {\n        widget.changeActive(t.hintId);\n        if (completion.options.completeOnSingleClick) widget.pick();\n      }\n    });\n\n    CodeMirror.on(hints, \"mousedown\", function() {\n      setTimeout(function(){cm.focus();}, 20);\n    });\n\n    // The first hint doesn't need to be scrolled to on init\n    var selectedHintRange = this.getSelectedHintRange();\n    if (selectedHintRange.from !== 0 || selectedHintRange.to !== 0) {\n      this.scrollToActive();\n    }\n\n    CodeMirror.signal(data, \"select\", completions[this.selectedHint], hints.childNodes[this.selectedHint]);\n    return true;\n  }\n\n  Widget.prototype = {\n    close: function() {\n      if (this.completion.widget != this) return;\n      this.completion.widget = null;\n      if (this.hints.parentNode) this.hints.parentNode.removeChild(this.hints);\n      this.completion.cm.removeKeyMap(this.keyMap);\n      var input = this.completion.cm.getInputField()\n      input.removeAttribute(\"aria-activedescendant\")\n      input.removeAttribute(\"aria-owns\")\n\n      var cm = this.completion.cm;\n      if (this.completion.options.closeOnUnfocus) {\n        cm.off(\"blur\", this.onBlur);\n        cm.off(\"focus\", this.onFocus);\n      }\n      cm.off(\"scroll\", this.onScroll);\n    },\n\n    disable: function() {\n      this.completion.cm.removeKeyMap(this.keyMap);\n      var widget = this;\n      this.keyMap = {Enter: function() { widget.picked = true; }};\n      this.completion.cm.addKeyMap(this.keyMap);\n    },\n\n    pick: function() {\n      this.completion.pick(this.data, this.selectedHint);\n    },\n\n    changeActive: function(i, avoidWrap) {\n      if (i >= this.data.list.length)\n        i = avoidWrap ? this.data.list.length - 1 : 0;\n      else if (i < 0)\n        i = avoidWrap ? 0  : this.data.list.length - 1;\n      if (this.selectedHint == i) return;\n      var node = this.hints.childNodes[this.selectedHint];\n      if (node) {\n        node.className = node.className.replace(\" \" + ACTIVE_HINT_ELEMENT_CLASS, \"\");\n        node.removeAttribute(\"aria-selected\")\n      }\n      node = this.hints.childNodes[this.selectedHint = i];\n      node.className += \" \" + ACTIVE_HINT_ELEMENT_CLASS;\n      node.setAttribute(\"aria-selected\", \"true\")\n      this.completion.cm.getInputField().setAttribute(\"aria-activedescendant\", node.id)\n      this.scrollToActive()\n      CodeMirror.signal(this.data, \"select\", this.data.list[this.selectedHint], node);\n    },\n\n    scrollToActive: function() {\n      var selectedHintRange = this.getSelectedHintRange();\n      var node1 = this.hints.childNodes[selectedHintRange.from];\n      var node2 = this.hints.childNodes[selectedHintRange.to];\n      var firstNode = this.hints.firstChild;\n      if (node1.offsetTop < this.hints.scrollTop)\n        this.hints.scrollTop = node1.offsetTop - firstNode.offsetTop;\n      else if (node2.offsetTop + node2.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)\n        this.hints.scrollTop = node2.offsetTop + node2.offsetHeight - this.hints.clientHeight + firstNode.offsetTop;\n    },\n\n    screenAmount: function() {\n      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n    },\n\n    getSelectedHintRange: function() {\n      var margin = this.completion.options.scrollMargin || 0;\n      return {\n        from: Math.max(0, this.selectedHint - margin),\n        to: Math.min(this.data.list.length - 1, this.selectedHint + margin),\n      };\n    }\n  };\n\n  function applicableHelpers(cm, helpers) {\n    if (!cm.somethingSelected()) return helpers\n    var result = []\n    for (var i = 0; i < helpers.length; i++)\n      if (helpers[i].supportsSelection) result.push(helpers[i])\n    return result\n  }\n\n  function fetchHints(hint, cm, options, callback) {\n    if (hint.async) {\n      hint(cm, callback, options)\n    } else {\n      var result = hint(cm, options)\n      if (result && result.then) result.then(callback)\n      else callback(result)\n    }\n  }\n\n  function resolveAutoHints(cm, pos) {\n    var helpers = cm.getHelpers(pos, \"hint\"), words\n    if (helpers.length) {\n      var resolved = function(cm, callback, options) {\n        var app = applicableHelpers(cm, helpers);\n        function run(i) {\n          if (i == app.length) return callback(null)\n          fetchHints(app[i], cm, options, function(result) {\n            if (result && result.list.length > 0) callback(result)\n            else run(i + 1)\n          })\n        }\n        run(0)\n      }\n      resolved.async = true\n      resolved.supportsSelection = true\n      return resolved\n    } else if (words = cm.getHelper(cm.getCursor(), \"hintWords\")) {\n      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }\n    } else if (CodeMirror.hint.anyword) {\n      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }\n    } else {\n      return function() {}\n    }\n  }\n\n  CodeMirror.registerHelper(\"hint\", \"auto\", {\n    resolve: resolveAutoHints\n  });\n\n  CodeMirror.registerHelper(\"hint\", \"fromList\", function(cm, options) {\n    var cur = cm.getCursor(), token = cm.getTokenAt(cur)\n    var term, from = CodeMirror.Pos(cur.line, token.start), to = cur\n    if (token.start < cur.ch && /\\w/.test(token.string.charAt(cur.ch - token.start - 1))) {\n      term = token.string.substr(0, cur.ch - token.start)\n    } else {\n      term = \"\"\n      from = cur\n    }\n    var found = [];\n    for (var i = 0; i < options.words.length; i++) {\n      var word = options.words[i];\n      if (word.slice(0, term.length) == term)\n        found.push(word);\n    }\n\n    if (found.length) return {list: found, from: from, to: to};\n  });\n\n  CodeMirror.commands.autocomplete = CodeMirror.showHint;\n\n  var defaultOptions = {\n    hint: CodeMirror.hint.auto,\n    completeSingle: true,\n    alignWithWord: true,\n    closeCharacters: /[\\s()\\[\\]{};:>,]/,\n    closeOnPick: true,\n    closeOnUnfocus: true,\n    updateOnCursorActivity: true,\n    completeOnSingleClick: true,\n    container: null,\n    customKeys: null,\n    extraKeys: null,\n    paddingForScrollbar: true,\n    moveOnOverlap: true,\n  };\n\n  CodeMirror.defineOption(\"hintOptions\", null);\n});\n","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../@vue/cli-service/node_modules/css-loader/dist/cjs.js??ref--7-oneOf-3-1!../../postcss-loader/src/index.js??ref--7-oneOf-3-2!../../postcss-loader/src/index.js??ref--7-oneOf-3-3!./codemirror.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"2ad31d40\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\n// Depends on js-yaml.js from https://github.com/nodeca/js-yaml\n\n// declare global: jsyaml\n\nCodeMirror.registerHelper(\"lint\", \"yaml\", function(text) {\n  var found = [];\n  if (!window.jsyaml) {\n    if (window.console) {\n      window.console.error(\"Error: window.jsyaml not defined, CodeMirror YAML linting cannot run.\");\n    }\n    return found;\n  }\n  try { jsyaml.loadAll(text); }\n  catch(e) {\n      var loc = e.mark,\n          // js-yaml YAMLException doesn't always provide an accurate lineno\n          // e.g., when there are multiple yaml docs\n          // ---\n          // ---\n          // foo:bar\n          from = loc ? CodeMirror.Pos(loc.line, loc.column) : CodeMirror.Pos(0, 0),\n          to = from;\n      found.push({ from: from, to: to, message: e.message });\n  }\n  return found;\n});\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n  var Pos = CodeMirror.Pos\n\n  function regexpFlags(regexp) {\n    var flags = regexp.flags\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\")\n      + (regexp.global ? \"g\" : \"\")\n      + (regexp.multiline ? \"m\" : \"\")\n  }\n\n  function ensureFlags(regexp, flags) {\n    var current = regexpFlags(regexp), target = current\n    for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1)\n      target += flags.charAt(i)\n    return current == target ? regexp : new RegExp(regexp.source, target)\n  }\n\n  function maybeMultiline(regexp) {\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source)\n  }\n\n  function searchRegexpForward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n      regexp.lastIndex = ch\n      var string = doc.getLine(line), match = regexp.exec(string)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpForwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)\n\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunk = 1\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\n      // This grows the search buffer in exponentially-sized chunks\n      // between matches, so that nearby matches are fast and don't\n      // require concatenating the whole document (in case we're\n      // searching for something that has tons of matches), but at the\n      // same time, the amount of retries is limited.\n      for (var i = 0; i < chunk; i++) {\n        if (line > last) break\n        var curLine = doc.getLine(line++)\n        string = string == null ? curLine : string + \"\\n\" + curLine\n      }\n      chunk = chunk * 2\n      regexp.lastIndex = start.ch\n      var match = regexp.exec(string)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  function lastMatchIn(string, regexp, endMargin) {\n    var match, from = 0\n    while (from <= string.length) {\n      regexp.lastIndex = from\n      var newMatch = regexp.exec(string)\n      if (!newMatch) break\n      var end = newMatch.index + newMatch[0].length\n      if (end > string.length - endMargin) break\n      if (!match || end > match.index + match[0].length)\n        match = newMatch\n      from = newMatch.index + 1\n    }\n    return match\n  }\n\n  function searchRegexpBackward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n      var string = doc.getLine(line)\n      var match = lastMatchIn(string, regexp, ch < 0 ? 0 : string.length - ch)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpBackward(doc, regexp, start)\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunkSize = 1, endMargin = doc.getLine(start.line).length - start.ch\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\n      for (var i = 0; i < chunkSize && line >= first; i++) {\n        var curLine = doc.getLine(line--)\n        string = string == null ? curLine : curLine + \"\\n\" + string\n      }\n      chunkSize *= 2\n\n      var match = lastMatchIn(string, regexp, endMargin)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = line + before.length, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  var doFold, noFold\n  if (String.prototype.normalize) {\n    doFold = function(str) { return str.normalize(\"NFD\").toLowerCase() }\n    noFold = function(str) { return str.normalize(\"NFD\") }\n  } else {\n    doFold = function(str) { return str.toLowerCase() }\n    noFold = function(str) { return str }\n  }\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos, foldFunc) {\n    if (orig.length == folded.length) return pos\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\n      if (min == max) return min\n      var mid = (min + max) >> 1\n      var len = foldFunc(orig.slice(0, mid)).length\n      if (len == pos) return mid\n      else if (len > pos) max = mid\n      else min = mid + 1\n    }\n  }\n\n  function searchStringForward(doc, query, start, caseFold) {\n    // Empty string would match anything and never progress, so we\n    // define it to match nothing instead.\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n      var orig = doc.getLine(line).slice(ch), string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.indexOf(lines[0])\n        if (found == -1) continue search\n        var start = adjustPos(orig, string, found, fold) + ch\n        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}\n      } else {\n        var cutFrom = string.length - lines[0].length\n        if (string.slice(cutFrom) != lines[0]) continue search\n        for (var i = 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search\n        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]\n        if (endString.slice(0, lastLine.length) != lastLine) continue search\n        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function searchStringBackward(doc, query, start, caseFold) {\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n      var orig = doc.getLine(line)\n      if (ch > -1) orig = orig.slice(0, ch)\n      var string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.lastIndexOf(lines[0])\n        if (found == -1) continue search\n        return {from: Pos(line, adjustPos(orig, string, found, fold)),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}\n      } else {\n        var lastLine = lines[lines.length - 1]\n        if (string.slice(0, lastLine.length) != lastLine) continue search\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search\n        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search\n        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function SearchCursor(doc, query, pos, options) {\n    this.atOccurrence = false\n    this.afterEmptyMatch = false\n    this.doc = doc\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0)\n    this.pos = {from: pos, to: pos}\n\n    var caseFold\n    if (typeof options == \"object\") {\n      caseFold = options.caseFold\n    } else { // Backwards compat for when caseFold was the 4th argument\n      caseFold = options\n      options = null\n    }\n\n    if (typeof query == \"string\") {\n      if (caseFold == null) caseFold = false\n      this.matches = function(reverse, pos) {\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)\n      }\n    } else {\n      query = ensureFlags(query, \"gm\")\n      if (!options || options.multiline !== false)\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)\n        }\n      else\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)\n        }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false)},\n    findPrevious: function() {return this.find(true)},\n\n    find: function(reverse) {\n      var head = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n      if (this.afterEmptyMatch && this.atOccurrence) {\n        // do not return the same 0 width match twice\n        head = Pos(head.line, head.ch)\n        if (reverse) {\n          head.ch--;\n          if (head.ch < 0) {\n            head.line--;\n            head.ch = (this.doc.getLine(head.line) || \"\").length;\n          }\n        } else {\n          head.ch++;\n          if (head.ch > (this.doc.getLine(head.line) || \"\").length) {\n            head.ch = 0;\n            head.line++;\n          }\n        }\n        if (CodeMirror.cmpPos(head, this.doc.clipPos(head)) != 0) {\n           return this.atOccurrence = false\n        }\n      }\n      var result = this.matches(reverse, head)\n      this.afterEmptyMatch = result && CodeMirror.cmpPos(result.from, result.to) == 0\n\n      if (result) {\n        this.pos = result\n        this.atOccurrence = true\n        return this.pos.match || true\n      } else {\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)\n        this.pos = {from: end, to: end}\n        return this.atOccurrence = false\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from},\n    to: function() {if (this.atOccurrence) return this.pos.to},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return\n      var lines = CodeMirror.splitLines(newText)\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold)\n  })\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold)\n  })\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = []\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold)\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break\n      ranges.push({anchor: cur.from(), head: cur.to()})\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0)\n  })\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./foldcode\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./foldcode\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"foldGutter\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.clearGutter(cm.state.foldGutter.options.gutter);\n      cm.state.foldGutter = null;\n      cm.off(\"gutterClick\", onGutterClick);\n      cm.off(\"changes\", onChange);\n      cm.off(\"viewportChange\", onViewportChange);\n      cm.off(\"fold\", onFold);\n      cm.off(\"unfold\", onFold);\n      cm.off(\"swapDoc\", onChange);\n      cm.off(\"optionChange\", optionChange);\n    }\n    if (val) {\n      cm.state.foldGutter = new State(parseOptions(val));\n      updateInViewport(cm);\n      cm.on(\"gutterClick\", onGutterClick);\n      cm.on(\"changes\", onChange);\n      cm.on(\"viewportChange\", onViewportChange);\n      cm.on(\"fold\", onFold);\n      cm.on(\"unfold\", onFold);\n      cm.on(\"swapDoc\", onChange);\n      cm.on(\"optionChange\", optionChange);\n    }\n  });\n\n  var Pos = CodeMirror.Pos;\n\n  function State(options) {\n    this.options = options;\n    this.from = this.to = 0;\n  }\n\n  function parseOptions(opts) {\n    if (opts === true) opts = {};\n    if (opts.gutter == null) opts.gutter = \"CodeMirror-foldgutter\";\n    if (opts.indicatorOpen == null) opts.indicatorOpen = \"CodeMirror-foldgutter-open\";\n    if (opts.indicatorFolded == null) opts.indicatorFolded = \"CodeMirror-foldgutter-folded\";\n    return opts;\n  }\n\n  function isFolded(cm, line) {\n    var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));\n    for (var i = 0; i < marks.length; ++i) {\n      if (marks[i].__isFold) {\n        var fromPos = marks[i].find(-1);\n        if (fromPos && fromPos.line === line)\n          return marks[i];\n      }\n    }\n  }\n\n  function marker(spec) {\n    if (typeof spec == \"string\") {\n      var elt = document.createElement(\"div\");\n      elt.className = spec + \" CodeMirror-guttermarker-subtle\";\n      return elt;\n    } else {\n      return spec.cloneNode(true);\n    }\n  }\n\n  function updateFoldInfo(cm, from, to) {\n    var opts = cm.state.foldGutter.options, cur = from - 1;\n    var minSize = cm.foldOption(opts, \"minFoldSize\");\n    var func = cm.foldOption(opts, \"rangeFinder\");\n    // we can reuse the built-in indicator element if its className matches the new state\n    var clsFolded = typeof opts.indicatorFolded == \"string\" && classTest(opts.indicatorFolded);\n    var clsOpen = typeof opts.indicatorOpen == \"string\" && classTest(opts.indicatorOpen);\n    cm.eachLine(from, to, function(line) {\n      ++cur;\n      var mark = null;\n      var old = line.gutterMarkers;\n      if (old) old = old[opts.gutter];\n      if (isFolded(cm, cur)) {\n        if (clsFolded && old && clsFolded.test(old.className)) return;\n        mark = marker(opts.indicatorFolded);\n      } else {\n        var pos = Pos(cur, 0);\n        var range = func && func(cm, pos);\n        if (range && range.to.line - range.from.line >= minSize) {\n          if (clsOpen && old && clsOpen.test(old.className)) return;\n          mark = marker(opts.indicatorOpen);\n        }\n      }\n      if (!mark && !old) return;\n      cm.setGutterMarker(line, opts.gutter, mark);\n    });\n  }\n\n  // copied from CodeMirror/src/util/dom.js\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\n  function updateInViewport(cm) {\n    var vp = cm.getViewport(), state = cm.state.foldGutter;\n    if (!state) return;\n    cm.operation(function() {\n      updateFoldInfo(cm, vp.from, vp.to);\n    });\n    state.from = vp.from; state.to = vp.to;\n  }\n\n  function onGutterClick(cm, line, gutter) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    if (gutter != opts.gutter) return;\n    var folded = isFolded(cm, line);\n    if (folded) folded.clear();\n    else cm.foldCode(Pos(line, 0), opts);\n  }\n\n  function optionChange(cm, option) {\n    if (option == \"mode\") onChange(cm)\n  }\n\n  function onChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    state.from = state.to = 0;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);\n  }\n\n  function onViewportChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() {\n      var vp = cm.getViewport();\n      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n        updateInViewport(cm);\n      } else {\n        cm.operation(function() {\n          if (vp.from < state.from) {\n            updateFoldInfo(cm, vp.from, state.from);\n            state.from = vp.from;\n          }\n          if (vp.to > state.to) {\n            updateFoldInfo(cm, state.to, vp.to);\n            state.to = vp.to;\n          }\n        });\n      }\n    }, opts.updateViewportTimeSpan || 400);\n  }\n\n  function onFold(cm, from) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var line = from.line;\n    if (line >= state.from && line < state.to)\n      updateFoldInfo(cm, line, line + 1);\n  }\n});\n","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../@vue/cli-service/node_modules/css-loader/dist/cjs.js??ref--7-oneOf-3-1!../../postcss-loader/src/index.js??ref--7-oneOf-3-2!../../postcss-loader/src/index.js??ref--7-oneOf-3-3!./base16-light.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"52a65d08\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"yaml\", function() {\n\n  var cons = ['true', 'false', 'on', 'off', 'yes', 'no'];\n  var keywordRegex = new RegExp(\"\\\\b((\"+cons.join(\")|(\")+\"))$\", 'i');\n\n  return {\n    token: function(stream, state) {\n      var ch = stream.peek();\n      var esc = state.escaped;\n      state.escaped = false;\n      /* comments */\n      if (ch == \"#\" && (stream.pos == 0 || /\\s/.test(stream.string.charAt(stream.pos - 1)))) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      if (stream.match(/^('([^']|\\\\.)*'?|\"([^\"]|\\\\.)*\"?)/))\n        return \"string\";\n\n      if (state.literal && stream.indentation() > state.keyCol) {\n        stream.skipToEnd(); return \"string\";\n      } else if (state.literal) { state.literal = false; }\n      if (stream.sol()) {\n        state.keyCol = 0;\n        state.pair = false;\n        state.pairStart = false;\n        /* document start */\n        if(stream.match('---')) { return \"def\"; }\n        /* document end */\n        if (stream.match('...')) { return \"def\"; }\n        /* array list item */\n        if (stream.match(/\\s*-\\s+/)) { return 'meta'; }\n      }\n      /* inline pairs/lists */\n      if (stream.match(/^(\\{|\\}|\\[|\\])/)) {\n        if (ch == '{')\n          state.inlinePairs++;\n        else if (ch == '}')\n          state.inlinePairs--;\n        else if (ch == '[')\n          state.inlineList++;\n        else\n          state.inlineList--;\n        return 'meta';\n      }\n\n      /* list separator */\n      if (state.inlineList > 0 && !esc && ch == ',') {\n        stream.next();\n        return 'meta';\n      }\n      /* pairs separator */\n      if (state.inlinePairs > 0 && !esc && ch == ',') {\n        state.keyCol = 0;\n        state.pair = false;\n        state.pairStart = false;\n        stream.next();\n        return 'meta';\n      }\n\n      /* start of value of a pair */\n      if (state.pairStart) {\n        /* block literals */\n        if (stream.match(/^\\s*(\\||\\>)\\s*/)) { state.literal = true; return 'meta'; };\n        /* references */\n        if (stream.match(/^\\s*(\\&|\\*)[a-z0-9\\._-]+\\b/i)) { return 'variable-2'; }\n        /* numbers */\n        if (state.inlinePairs == 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?$/)) { return 'number'; }\n        if (state.inlinePairs > 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?(?=(,|}))/)) { return 'number'; }\n        /* keywords */\n        if (stream.match(keywordRegex)) { return 'keyword'; }\n      }\n\n      /* pairs (associative arrays) -> key */\n      if (!state.pair && stream.match(/^\\s*(?:[,\\[\\]{}&*!|>'\"%@`][^\\s'\":]|[^,\\[\\]{}#&*!|>'\"%@`])[^#]*?(?=\\s*:($|\\s))/)) {\n        state.pair = true;\n        state.keyCol = stream.indentation();\n        return \"atom\";\n      }\n      if (state.pair && stream.match(/^:\\s*/)) { state.pairStart = true; return 'meta'; }\n\n      /* nothing found, continue */\n      state.pairStart = false;\n      state.escaped = (ch == '\\\\');\n      stream.next();\n      return null;\n    },\n    startState: function() {\n      return {\n        pair: false,\n        pairStart: false,\n        keyCol: 0,\n        inlinePairs: 0,\n        inlineList: 0,\n        literal: false,\n        escaped: false\n      };\n    },\n    lineComment: \"#\",\n    fold: \"indent\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-yaml\", \"yaml\");\nCodeMirror.defineMIME(\"text/yaml\", \"yaml\");\n\n});\n","// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../../@vue/cli-service/node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \".CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-fat-cursor .CodeMirror-line::selection,.cm-fat-cursor .CodeMirror-line>span::selection,.cm-fat-cursor .CodeMirror-line>span>span::selection{background:transparent}.cm-fat-cursor .CodeMirror-line::-moz-selection,.cm-fat-cursor .CodeMirror-line>span::-moz-selection,.cm-fat-cursor .CodeMirror-line>span>span::-moz-selection{background:transparent}.cm-fat-cursor{caret-color:transparent}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:0;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta,.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-invalidchar,.cm-s-default .cm-error{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0b0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#a22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-50px;margin-right:-50px;padding-bottom:50px;height:100%;outline:none;position:relative;z-index:0}.CodeMirror-sizer{position:relative;border-right:50px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none;outline:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-50px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:none!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like{border-radius:0;border-width:0;background:transparent;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;font-variant-ligatures:contextual}.CodeMirror-wrap pre.CodeMirror-line,.CodeMirror-wrap pre.CodeMirror-line-like{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;padding:.1px}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:none}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}.CodeMirror-focused div.CodeMirror-cursors,div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:\\\"\\\"}span.CodeMirror-selectedtext{background:none}\", \"\"]);\n// Exports\nmodule.exports = exports;\n","/*\n * NOTE: This isn't actually a real plugin anymore, it's is dynamically loaded in components/CodeMirror.vue\n * so that it doesn't all get loaded put into vendor.js\n */\n\nimport CodeMirror from 'codemirror';\n\nimport 'codemirror/lib/codemirror.css';\nimport 'codemirror/mode/yaml/yaml.js';\nimport 'codemirror/mode/javascript/javascript.js';\n\nimport 'codemirror/theme/base16-light.css';\nimport 'codemirror/theme/base16-dark.css';\n\nimport 'codemirror/keymap/vim.js';\nimport 'codemirror/keymap/emacs.js';\nimport 'codemirror/keymap/sublime.js';\n\nimport 'codemirror/addon/lint/lint.css';\nimport 'codemirror/addon/lint/lint.js';\nimport 'codemirror/addon/lint/yaml-lint.js';\n\nimport 'codemirror/addon/fold/foldgutter.css';\nimport 'codemirror/addon/fold/foldgutter.js';\n\nimport 'codemirror/addon/hint/show-hint.css';\nimport 'codemirror/addon/hint/show-hint.js';\nimport 'codemirror/addon/hint/anyword-hint.js';\n\nimport { strPad } from '@shell/utils/string';\n\nfunction isLineComment(cm, lineNo) {\n  return /\\bcomment\\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, 0)));\n}\n\nfunction commentIndent(cm, lineNo) {\n  const text = cm.getLine(lineNo).substr(1);\n  const spaceTo = text.search(/\\S/);\n\n  if (spaceTo === -1 ) {\n    return -1;\n  }\n\n  const out = CodeMirror.countColumn(text, null, cm.getOption('tabSize'));\n\n  return out;\n}\n\n// Like the regular indent in codemirror, but treat a YAML array\n// item that's at the same level as the parent key as intented on level more\n//\n// foo:\n// - a\n// - b\nfunction lineIndent(cm, lineNo) {\n  let text = cm.getLine(lineNo);\n  const match = text.match(/(\\s*(-\\s+)?)(\\S.*)/);\n\n  if ( !match ) {\n    return -1;\n  }\n\n  const spaceTo = match[1].length;\n\n  text = strPad('', spaceTo) + match[3];\n\n  if ( /\\bcomment\\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, spaceTo + 1)))) {\n    return -1;\n  }\n\n  return CodeMirror.countColumn(text, null, cm.getOption('tabSize'));\n}\n\n// https://github.com/codemirror/CodeMirror/blob/master/addon/fold/indent-fold.js\nCodeMirror.registerHelper('fold', 'indent', (cm, start) => {\n  const myIndent = lineIndent(cm, start.line);\n\n  if (myIndent < 0) {\n    return;\n  }\n  let lastLineInFold = null;\n\n  // Go through lines until we find a line that definitely doesn't belong in\n  // the block we're folding, or to the end.\n  for (let i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {\n    const indent = lineIndent(cm, i);\n\n    if (indent === -1) {\n    } else if (indent > myIndent) {\n      // Lines with a greater indent are considered part of the block.\n      lastLineInFold = i;\n    } else {\n      // If this line has non-space, non-comment content, and is\n      // indented less or equal to the start line, it is the start of\n      // another block.\n      break;\n    }\n  }\n  if (lastLineInFold) {\n    return {\n      from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),\n      to:   CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)\n    };\n  }\n});\n\nCodeMirror.defineExtension('foldLinesMatching', function(regex) {\n  this.operation(() => {\n    for (let i = this.firstLine(), e = this.lastLine(); i <= e; i++) {\n      const line = this.getLine(i);\n\n      if ( line.match(regex) ) {\n        this.foldCode(CodeMirror.Pos(i, 0), null, 'fold');\n      }\n    }\n  });\n});\n\nfunction countSpaces(line) {\n  for (let i = 0; i < line.length; i++) {\n    if (line[i] !== ' ') {\n      return i;\n    }\n  }\n\n  return line.length;\n}\n\nCodeMirror.defineExtension('foldYaml', function(path) {\n  this.operation(() => {\n    let elements = [];\n\n    for (let i = this.firstLine(), e = this.lastLine(); i <= e; i++) {\n      const line = this.getLine(i);\n      const index = countSpaces(line);\n      const trimmed = line.trim();\n\n      if (trimmed.endsWith(':') || trimmed.endsWith(': >-')) {\n        const name = trimmed.split(':')[0].substr(0, trimmed.length - 1);\n\n        // Remove all elements of the same are greater index\n        elements = elements.filter((e) => e.index < index);\n\n        // Add on this one\n        elements.push({\n          index,\n          name\n        });\n\n        const currentPath = elements.map((e) => e.name).join('.');\n\n        if (currentPath === path) {\n          this.foldCode(CodeMirror.Pos(i, 0), null, 'fold');\n        }\n      }\n    }\n  });\n});\n\nCodeMirror.registerHelper('fold', 'yamlcomments', (cm, start) => {\n  if ( !isLineComment(cm, start.line) ) {\n    return;\n  }\n\n  const myIndent = commentIndent(cm, start.line);\n\n  if (myIndent < 0) {\n    return;\n  }\n\n  let lastLineInFold = null;\n\n  // Go through lines until we find a line that definitely doesn't belong in\n  // the block we're folding, or to the end.\n  for (let i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {\n    if ( !isLineComment(cm, i) ) {\n      break;\n    }\n\n    const indent = commentIndent(cm, i);\n\n    if (indent === -1) {\n      // empty?\n    } else if (indent > myIndent) {\n      // Lines with a greater indent are considered part of the block.\n      lastLineInFold = i;\n    } else {\n      // If this line has non-space, non-comment content, and is\n      // indented less or equal to the start line, it is the start of\n      // another block.\n      break;\n    }\n  }\n\n  if (lastLineInFold) {\n    return {\n      from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),\n      to:   CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)\n    };\n  }\n});\n\n/**\n * It display a dot for each space character in the text;\n * used in combination with 'as-text-area' css properties in CodeMirror.vue to display line break markdowns\n */\nCodeMirror.defineOption('showMarkdownLineBreaks', false, (codeMirror) => {\n  codeMirror.addOverlay({\n    name:  'show-markdown-line-breaks',\n    token: (stream) => {\n      if (stream.string[stream.pos].match(/\\s/)) {\n        stream.next();\n\n        return stream.pos % 2 === 0 ? 'markdown-single-trailing-space-even' : 'markdown-single-trailing-space-odd';\n      }\n\n      stream.next();\n\n      return null;\n    }\n  });\n});\n\n/**\n * It enables the text color selection in CodeMirror.vue\n * references:\n *   demo:   https://codemirror.net/5/demo/markselection.html#\n *   add-on: https://codemirror.net/5/doc/manual.html#addon_mark-selection\n *   source: https://codemirror.net/5/addon/selection/mark-selection.js\n */\nCodeMirror.defineOption('styleSelectedText', false, (cm, val, old) => {\n  const prev = old && old !== CodeMirror.Init;\n\n  if (val && !prev) {\n    cm.state.markedSelection = [];\n    cm.state.markedSelectionStyle = typeof val === 'string' ? val : 'CodeMirror-selectedtext';\n    reset(cm);\n    cm.on('cursorActivity', onCursorActivity);\n    cm.on('change', onChange);\n  } else if (!val && prev) {\n    cm.off('cursorActivity', onCursorActivity);\n    cm.off('change', onChange);\n    clear(cm);\n    cm.state.markedSelection = cm.state.markedSelectionStyle = null;\n  }\n});\n\nfunction onCursorActivity(cm) {\n  if (cm.state.markedSelection) {\n    cm.operation(() => {\n      update(cm);\n    });\n  }\n}\n\nfunction onChange(cm) {\n  if (cm.state.markedSelection && cm.state.markedSelection.length) {\n    cm.operation(() => {\n      clear(cm);\n    });\n  }\n}\n\nconst CHUNK_SIZE = 8;\nconst Pos = CodeMirror.Pos;\nconst cmp = CodeMirror.cmpPos;\n\nfunction coverRange(cm, from, to, addAt) {\n  if (cmp(from, to) === 0) {\n    return;\n  }\n  const array = cm.state.markedSelection;\n  const cls = cm.state.markedSelectionStyle;\n\n  for (let line = from.line;;) {\n    const start = line === from.line ? from : Pos(line, 0);\n    const endLine = line + CHUNK_SIZE; const atEnd = endLine >= to.line;\n    const end = atEnd ? to : Pos(endLine, 0);\n    const mark = cm.markText(start, end, { className: cls });\n\n    if (addAt === null || addAt === undefined) {\n      array.push(mark);\n    } else {\n      array.splice(addAt++, 0, mark);\n    }\n    if (atEnd) {\n      break;\n    }\n    line = endLine;\n  }\n}\n\nfunction clear(cm) {\n  const array = cm.state.markedSelection;\n\n  for (let i = 0; i < array.length; ++i) {\n    array[i].clear();\n  }\n  array.length = 0;\n}\n\nfunction reset(cm) {\n  clear(cm);\n  const ranges = cm.listSelections();\n\n  for (let i = 0; i < ranges.length; i++) {\n    coverRange(cm, ranges[i].from(), ranges[i].to());\n  }\n}\n\nfunction update(cm) {\n  if (!cm.somethingSelected()) {\n    return clear(cm);\n  }\n  if (cm.listSelections().length > 1) {\n    return reset(cm);\n  }\n\n  const from = cm.getCursor('start'); const to = cm.getCursor('end');\n\n  const array = cm.state.markedSelection;\n\n  if (!array.length) {\n    return coverRange(cm, from, to);\n  }\n\n  let coverStart = array[0].find(); let coverEnd = array[array.length - 1].find();\n\n  if (!coverStart || !coverEnd || to.line - from.line <= CHUNK_SIZE ||\n      cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0) {\n    return reset(cm);\n  }\n\n  while (cmp(from, coverStart.from) > 0) {\n    array.shift().clear();\n    coverStart = array[0].find();\n  }\n  if (cmp(from, coverStart.from) < 0) {\n    if (coverStart.to.line - from.line < CHUNK_SIZE) {\n      array.shift().clear();\n      coverRange(cm, from, coverStart.to, 0);\n    } else {\n      coverRange(cm, from, coverStart.from, 0);\n    }\n  }\n\n  while (cmp(to, coverEnd.to) < 0) {\n    array.pop().clear();\n    coverEnd = array[array.length - 1].find();\n  }\n  if (cmp(to, coverEnd.to) > 0) {\n    if (to.line - coverEnd.from.line < CHUNK_SIZE) {\n      array.pop().clear();\n      coverRange(cm, coverEnd.from, to);\n    } else {\n      coverRange(cm, coverEnd.to, to);\n    }\n  }\n}\n","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../@vue/cli-service/node_modules/css-loader/dist/cjs.js??ref--7-oneOf-3-1!../../../postcss-loader/src/index.js??ref--7-oneOf-3-2!../../../postcss-loader/src/index.js??ref--7-oneOf-3-3!./show-hint.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"1f31d586\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../../../@vue/cli-service/node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \".CodeMirror-foldmarker{color:#00f;text-shadow:#b9f 1px 1px 2px,#b9f -1px -1px 2px,#b9f 1px -1px 2px,#b9f -1px 1px 2px;font-family:arial;line-height:.3;cursor:pointer}.CodeMirror-foldgutter{width:.7em}.CodeMirror-foldgutter-folded,.CodeMirror-foldgutter-open{cursor:pointer}.CodeMirror-foldgutter-open:after{content:\\\"\\\\25BE\\\"}.CodeMirror-foldgutter-folded:after{content:\\\"\\\\25B8\\\"}\", \"\"]);\n// Exports\nmodule.exports = exports;\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var trackScope = parserConfig.trackScope !== false\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    return {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C\n    };\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\" && stream.peek() == \"!\") {\n      stream.skipToEnd();\n      return ret(\"meta\", \"meta\");\n    } else if (ch == \"#\" && stream.eatWhile(wordRE)) {\n      return ret(\"variable\", \"property\")\n    } else if (ch == \"<\" && stream.match(\"!--\") ||\n               (ch == \"-\" && stream.match(\"->\") && !/\\S/.test(stream.string.slice(0, stream.start)))) {\n      stream.skipToEnd()\n      return ret(\"comment\", \"comment\")\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n        } else if (/[<>*+\\-|&?]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == \">\") stream.eat(ch)\n        }\n      }\n      if (ch == \"?\" && stream.eat(\".\")) return ret(\".\")\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == \"async\" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n          return ret(\"async\", \"keyword\", word)\n      }\n      return ret(\"variable\", \"variable\", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/`]/.test(ch)) {\n        for (;; --pos) {\n          if (pos == 0) return\n          var next = stream.string.charAt(pos - 1)\n          if (next == ch && stream.string.charAt(pos - 2) != \"\\\\\") { pos--; break }\n        }\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true,\n                     \"regexp\": true, \"this\": true, \"import\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    if (!trackScope) return false\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next) if (v.name == name) return true\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (!trackScope) return\n    if (state.context) {\n      if (state.lexical.info == \"var\" && state.context && state.context.block) {\n        // FIXME function decls are also not block scoped\n        var newContext = registerVarScoped(varname, state.context)\n        if (newContext != null) {\n          state.context = newContext\n          return\n        }\n      } else if (!inList(varname, state.localVars)) {\n        state.localVars = new Var(varname, state.localVars)\n        return\n      }\n    }\n    // Fall through means this is global\n    if (parserConfig.globalVars && !inList(varname, state.globalVars))\n      state.globalVars = new Var(varname, state.globalVars)\n  }\n  function registerVarScoped(varname, context) {\n    if (!context) {\n      return null\n    } else if (context.block) {\n      var inner = registerVarScoped(varname, context.prev)\n      if (!inner) return null\n      if (inner == context.prev) return context\n      return new Context(inner, context.vars, true)\n    } else if (inList(varname, context.vars)) {\n      return context\n    } else {\n      return new Context(context.prev, new Var(varname, context.vars), false)\n    }\n  }\n\n  function isModifier(name) {\n    return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\"\n  }\n\n  // Combinators\n\n  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\n  function Var(name, next) { this.name = name; this.next = next }\n\n  var defaultVars = new Var(\"this\", new Var(\"arguments\", null))\n  function pushcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\n    cx.state.localVars = defaultVars\n  }\n  function pushblockcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\n    cx.state.localVars = null\n  }\n  pushcontext.lex = pushblockcontext.lex = true\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars\n    cx.state.context = cx.state.context.prev\n  }\n  popcontext.lex = true\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\" || type == \"}\" || type == \")\" || type == \"]\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), pushblockcontext, forspec, statement, popcontext, poplex);\n    if (type == \"class\" || (isTS && value == \"interface\")) {\n      cx.marked = \"keyword\"\n      return cont(pushlex(\"form\", type == \"class\" ? type : value), className, poplex)\n    }\n    if (type == \"variable\") {\n      if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n        cx.marked = \"keyword\"\n        if (value == \"enum\") return cont(enumdef);\n        else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\n        else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n      } else if (isTS && value == \"namespace\") {\n        cx.marked = \"keyword\"\n        return cont(pushlex(\"form\"), expression, statement, poplex)\n      } else if (isTS && value == \"abstract\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext,\n                                      block, poplex, poplex, popcontext);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function maybeCatchBinding(type) {\n    if (type == \"(\") return cont(funarg, expect(\")\"))\n  }\n  function expression(type, value) {\n    return expressionInner(type, value, false);\n  }\n  function expressionNoComma(type, value) {\n    return expressionInner(type, value, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, value, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), classExpression, poplex); }\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(maybeexpression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (isTS && value == \"<\" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n        return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(maybeexpression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (isTS && isModifier(value)) {\n      cx.marked = \"keyword\"\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      if (sep && sep.indexOf(\";\") > -1) return pass(what)\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function maybetypeOrIn(type, value) {\n    if (isTS && (type == \":\" || value == \"in\")) return cont(typeexpr)\n  }\n  function mayberettype(type) {\n    if (isTS && type == \":\") {\n      if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\n      else return cont(typeexpr)\n    }\n  }\n  function isKW(_, value) {\n    if (value == \"is\") {\n      cx.marked = \"keyword\"\n      return cont()\n    }\n  }\n  function typeexpr(type, value) {\n    if (value == \"keyof\" || value == \"typeof\" || value == \"infer\" || value == \"readonly\") {\n      cx.marked = \"keyword\"\n      return cont(value == \"typeof\" ? expressionNoComma : typeexpr)\n    }\n    if (type == \"variable\" || value == \"void\") {\n      cx.marked = \"type\"\n      return cont(afterType)\n    }\n    if (value == \"|\" || value == \"&\") return cont(typeexpr)\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n    if (type == \"{\") return cont(pushlex(\"}\"), typeprops, poplex, afterType)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType)\n    if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr)\n    if (type == \"quasi\") { return pass(quasiType, afterType); }\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprops(type) {\n    if (type.match(/[\\}\\)\\]]/)) return cont()\n    if (type == \",\" || type == \";\") return cont(typeprops)\n    return pass(typeprop, typeprops)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\" || type == \"number\" || type == \"string\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    } else if (type == \"[\") {\n      return cont(expect(\"variable\"), maybetypeOrIn, expect(\"]\"), typeprop)\n    } else if (type == \"(\") {\n      return pass(functiondecl, typeprop)\n    } else if (!type.match(/[;\\}\\)\\],]/)) {\n      return cont()\n    }\n  }\n  function quasiType(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasiType);\n    return cont(typeexpr, continueQuasiType);\n  }\n  function continueQuasiType(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasiType);\n    }\n  }\n  function typearg(type, value) {\n    if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg)\n    if (type == \":\") return cont(typeexpr)\n    if (type == \"spread\") return cont(typearg)\n    return pass(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr)\n    if (type == \"[\") return cont(typeexpr, expect(\"]\"), afterType)\n    if (value == \"extends\" || value == \"implements\") { cx.marked = \"keyword\"; return cont(typeexpr) }\n    if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr)\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n  }\n  function typeparam() {\n    return pass(typeexpr, maybeTypeDefault)\n  }\n  function maybeTypeDefault(_, value) {\n    if (value == \"=\") return cont(typeexpr)\n  }\n  function vardef(_, value) {\n    if (value == \"enum\") {cx.marked = \"keyword\"; return cont(enumdef)}\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(pattern) }\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(eltpattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    if (type == \"[\") return cont(expression, expect(']'), expect(':'), proppattern);\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function eltpattern() {\n    return pass(pattern, maybeAssign)\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type, value) {\n    if (value == \"await\") return cont(forspec);\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, forspec2);\n    if (type == \"variable\") return cont(forspec2);\n    return pass(forspec2)\n  }\n  function forspec2(type, value) {\n    if (type == \")\") return cont()\n    if (type == \";\") return cont(forspec2)\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression, forspec2) }\n    return pass(expression, forspec2)\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef)\n  }\n  function functiondecl(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondecl);}\n    if (type == \"variable\") {register(value); return cont(functiondecl);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl)\n  }\n  function typename(type, value) {\n    if (type == \"keyword\" || type == \"variable\") {\n      cx.marked = \"type\"\n      return cont(typename)\n    } else if (value == \"<\") {\n      return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex)\n    }\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg)\n    if (type == \"spread\") return cont(funarg);\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(funarg); }\n    if (isTS && type == \"this\") return cont(maybetype, maybeAssign)\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\")) {\n      if (value == \"implements\") cx.marked = \"keyword\";\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    }\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"async\" ||\n        (type == \"variable\" &&\n         (value == \"static\" || value == \"get\" || value == \"set\" || (isTS && isModifier(value))) &&\n         cx.stream.match(/^\\s+#?[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(classfield, classBody);\n    }\n    if (type == \"number\" || type == \"string\") return cont(classfield, classBody);\n    if (type == \"[\")\n      return cont(expression, maybetype, expect(\"]\"), classfield, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (isTS && type == \"(\") return pass(functiondecl, classBody)\n    if (type == \";\" || type == \",\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"!\") return cont(classfield)\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\"\n    return pass(isInterface ? functiondecl : functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    if (type == \"(\") return pass(expression);\n    if (type == \".\") return pass(maybeoperatorComma);\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function enumdef() {\n    return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex)\n  }\n  function enummember() {\n    return pass(pattern, maybeAssign);\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && new Context(null, null, false),\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse && c != popcontext) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    blockCommentContinue: jsonMode ? null : \" * \",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      parseJS(state, \"atom\", \"atom\", \"true\", new CodeMirror.StringStream(\"\", 2, null))\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/x-json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/manifest+json\", { name: \"javascript\", json: true })\nCodeMirror.defineMIME(\"application/ld+json\", { name: \"javascript\", jsonld: true });\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n"],"sourceRoot":""}